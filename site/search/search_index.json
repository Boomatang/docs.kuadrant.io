{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#component-documentation","title":"Component Documentation","text":"<ul> <li>Authorino</li> <li>Limitador</li> <li>Kuadrant Operator</li> <li>Multicluster Gateway Controller</li> </ul>"},{"location":"kuadrant-operator/","title":"Kuadrant Operator","text":"<p>The Operator to install and manage the lifecycle of the Kuadrant components deployments.</p> <ul> <li>Overview</li> <li>Architecture<ul> <li>Kuadrant components</li> <li>Provided APIs</li> </ul> </li> <li>Getting started<ul> <li>Pre-requisites</li> <li>Installing Kuadrant</li> <li>Protect Your Service</li> <li>If you are an API Provider</li> <li>If you are a Cluster Operator</li> </ul> </li> <li>User guides</li> <li>Kuadrant Rate Limiting</li> <li>Documentation</li> <li>Contributing</li> <li>Licensing</li> </ul>"},{"location":"kuadrant-operator/#overview","title":"Overview","text":"<p>Kuadrant is a re-architecture of API Management using Cloud Native concepts and separating the components to be less coupled, more reusable and leverage the underlying kubernetes platform. It aims to deliver a smooth experience to providers and consumers of applications &amp; services when it comes to rate limiting, authentication, authorization, discoverability, change management, usage contracts, insights, etc.</p> <p>Kuadrant aims to produce a set of loosely coupled functionalities built directly on top of Kubernetes. Furthermore it only strives to provide what Kubernetes doesn\u2019t offer out of the box, i.e. Kuadrant won\u2019t be designing a new Gateway/proxy, instead it will opt to connect with what\u2019s there and what\u2019s being developed (think Envoy, Istio, GatewayAPI).</p> <p>Kuadrant is a system of cloud-native k8s components that grows as users\u2019 needs grow. * From simple protection of a Service (via AuthN) that is used by teammates working on the same cluster, or \u201csibling\u201d services, up to AuthZ of users using OIDC plus custom policies. * From no rate-limiting to rate-limiting for global service protection on to rate-limiting by users/plans</p>"},{"location":"kuadrant-operator/#architecture","title":"Architecture","text":"<p>Kuadrant relies on Istio and the Gateway API to operate the cluster (istio's) ingress gateway to provide API management with authentication (authN), authorization (authZ) and rate limiting capabilities.</p>"},{"location":"kuadrant-operator/#kuadrant-components","title":"Kuadrant components","text":"CRD Description Control Plane The control plane takes the customer desired configuration (declaratively as kubernetes custom resources) as input and ensures all components are configured to obey customer's desired behavior. This repository contains the source code of the kuadrant control plane Kuadrant Operator A Kubernetes Operator to manage the lifecycle of the kuadrant deployment Authorino The AuthN/AuthZ enforcer. As the external istio authorizer (envoy external authorization serving gRPC service) Limitador The external rate limiting service. It exposes a gRPC service implementing the Envoy Rate Limit protocol (v3) Authorino Operator A Kubernetes Operator to manage Authorino instances Limitador Operator A Kubernetes Operator to manage Limitador instances"},{"location":"kuadrant-operator/#provided-apis","title":"Provided APIs","text":"<p>The kuadrant control plane owns the following Custom Resource Definitions, CRDs:</p> CRD Description Example RateLimitPolicy CRD [doc] [reference] Enable access control on workloads based on HTTP rate limiting RateLimitPolicy CR AuthPolicy CRD Enable AuthN and AuthZ based access control on workloads AuthPolicy CR <p>Additionally, Kuadrant provides the following CRDs</p> CRD Owner Description Example Kuadrant CRD Kuadrant Operator Represents an instance of kuadrant Kuadrant CR Limitador CRD Limitador Operator Represents an instance of Limitador Limitador CR Authorino CRD Authorino Operator Represents an instance of Authorino Authorino CR <p></p>"},{"location":"kuadrant-operator/#getting-started","title":"Getting started","text":""},{"location":"kuadrant-operator/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Istio is installed in the cluster. Otherwise, refer to the   Istio getting started guide.</li> <li>Kubernetes Gateway API is installed in the cluster. Otherwise,   configure Istio to expose a service using the Kubernetes Gateway API.</li> </ul>"},{"location":"kuadrant-operator/#installing-kuadrant","title":"Installing Kuadrant","text":"<p>Installing Kuadrant is a two-step procedure. Firstly, install the Kuadrant Operator and seconly, request a Kuadrant instance by creating a Kuadrant custom resource.</p>"},{"location":"kuadrant-operator/#1-install-the-kuadrant-operator","title":"1. Install the Kuadrant Operator","text":"<p>The Kuadrant Operator is available in public community operator catalogs, such as the Kubernetes OperatorHub.io and the Openshift Container Platform and OKD OperatorHub.</p> <p>Kubernetes</p> <p>The operator is available from OperatorHub.io. Just go to the linked page and follow installation steps (or just run these two commands):</p> <pre><code># Install Operator Lifecycle Manager (OLM), a tool to help manage the operators running on your cluster.\n\n$ curl -sL https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.23.1/install.sh | bash -s v0.23.1\n\n# Install the operator by running the following command:\n\n$ kubectl create -f https://operatorhub.io/install/kuadrant-operator.yaml\n</code></pre> <p>Openshift</p> <p>The operator is available from the Openshift Console OperatorHub. Just follow installation steps choosing the \"Kuadrant Operator\" from the catalog:</p> <p></p>"},{"location":"kuadrant-operator/#2-request-a-kuadrant-instance","title":"2. Request a Kuadrant instance","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace kuadrant\n</code></pre> <p>Apply the <code>Kuadrant</code> custom resource:</p> <pre><code>kubectl apply -n kuadrant -f -&lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\nname: kuadrant\nspec: {}\nEOF\n</code></pre>"},{"location":"kuadrant-operator/#protect-your-service","title":"Protect your service","text":""},{"location":"kuadrant-operator/#if-you-are-an-api-provider","title":"If you are an API Provider","text":"<ul> <li>Deploy the service/API to be protected (\"Upstream\")</li> <li>Expose the service/API using the kubernetes Gateway API, ie   HTTPRoute object.</li> <li>Write and apply the Kuadrant's RateLimitPolicy and/or   AuthPolicy custom resources targeting the HTTPRoute resource   to have your API protected.</li> </ul>"},{"location":"kuadrant-operator/#if-you-are-a-cluster-operator","title":"If you are a Cluster Operator","text":"<ul> <li>(Optionally) deploy istio ingress gateway using the   Gateway resource.</li> <li>Write and apply the Kuadrant's RateLimitPolicy and/or   AuthPolicy custom resources targeting the Gateway resource   to have your gateway traffic protected.</li> </ul>"},{"location":"kuadrant-operator/#user-guides","title":"User guides","text":"<p>The user guides section of the docs gathers several use-cases as well as the instructions to implement them using kuadrant.</p> <ul> <li>Simple rate limiting for API owners</li> <li>Authenticated rate limiting for API owners</li> <li>Gateway rate limiting for cluster operators</li> <li>Authenticated rate limiting with JWTs and Kubernetes authnz</li> </ul>"},{"location":"kuadrant-operator/#kuadrant-rate-limiting","title":"Kuadrant Rate Limiting","text":""},{"location":"kuadrant-operator/#documentation","title":"Documentation","text":"<p>Docs can be found on the Kuadrant website.</p>"},{"location":"kuadrant-operator/#contributing","title":"Contributing","text":"<p>The Development guide describes how to build the kuadrant operator and how to test your changes before submitting a patch or opening a PR.</p> <p>Join us on kuadrant.slack.com for live discussions about the roadmap and more.</p>"},{"location":"kuadrant-operator/#licensing","title":"Licensing","text":"<p>This software is licensed under the Apache 2.0 license.</p> <p>See the LICENSE and NOTICE files that should have been provided along with this software for details.</p>"},{"location":"kuadrant-operator/development/","title":"Development Guide","text":"<ul> <li>Technology stack required for development</li> <li>Build</li> <li>Run locally</li> <li>Deploy the operator in a deployment object</li> <li>Deploy kuadrant operator using OLM</li> <li>Build custom OLM catalog<ul> <li>Build kuadrant operator bundle image</li> <li>Build custom catalog</li> <li>Deploy kuadrant operator using OLM</li> </ul> </li> <li>Cleaning up</li> <li>Run tests<ul> <li>Unit tests</li> <li>Integration tests</li> <li>All tests</li> <li>Lint tests</li> </ul> </li> <li>(Un)Install Kuadrant CRDs</li> </ul>"},{"location":"kuadrant-operator/development/#technology-stack-required-for-development","title":"Technology stack required for development","text":"<ul> <li>operator-sdk version v1.22.0</li> <li>kind version v0.11.1</li> <li>git</li> <li>go version 1.18+</li> <li>kubernetes version v1.19+</li> <li>kubectl version v1.19+</li> </ul>"},{"location":"kuadrant-operator/development/#build","title":"Build","text":"<pre><code>make\n</code></pre>"},{"location":"kuadrant-operator/development/#run-locally","title":"Run locally","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Optionally, run kind and deploy kuadrant deps</p> <pre><code>make local-env-setup\n</code></pre> <p>Then, run the operator locally</p> <pre><code>make run\n</code></pre>"},{"location":"kuadrant-operator/development/#deploy-the-operator-in-a-deployment-object","title":"Deploy the operator in a deployment object","text":"<pre><code>make local-setup\n</code></pre> <p>List of tasks done by the command above:</p> <ul> <li>Create local cluster using kind</li> <li>Build kuadrant docker image from the current working directory</li> <li>Deploy Kuadrant control plane (including istio, authorino and limitador)</li> </ul> <p>TODO: customize with custom authorino and limitador git refs. Make sure Makefile propagates variable to <code>deploy</code> target</p>"},{"location":"kuadrant-operator/development/#deploy-kuadrant-operator-using-olm","title":"Deploy kuadrant operator using OLM","text":"<p>You can deploy kuadrant using OLM just running few commands. No need to build any image. Kuadrant engineering team provides <code>latest</code> and release version tagged images. They are available in the Quay.io/Kuadrant image repository.</p> <p>Create kind cluster</p> <pre><code>make kind-create-cluster\n</code></pre> <p>Deploy OLM system</p> <pre><code>make install-olm\n</code></pre> <p>Deploy kuadrant using OLM. The <code>make deploy-catalog</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>CATALOG_IMG</code> Kuadrant operator catalog image URL <code>quay.io/kuadrant/kuadrant-operator-catalog:latest</code> <pre><code>make deploy-catalog [CATALOG_IMG=quay.io/kuadrant/kuadrant-operator-catalog:latest]\n</code></pre>"},{"location":"kuadrant-operator/development/#build-custom-olm-catalog","title":"Build custom OLM catalog","text":"<p>If you want to deploy (using OLM) a custom kuadrant operator, you need to build your own catalog. Furthermore, if you want to deploy a custom limitador or authorino operator, you also need to build your own catalog. The kuadrant operator bundle includes the authorino or limtador operator dependency version, hence using other than <code>latest</code> version requires a custom kuadrant operator bundle and a custom catalog including the custom bundle.</p>"},{"location":"kuadrant-operator/development/#build-kuadrant-operator-bundle-image","title":"Build kuadrant operator bundle image","text":"<p>The <code>make bundle</code> target accepts the following variables:</p> Makefile Variable Description Default value Notes <code>IMG</code> Kuadrant operator image URL <code>quay.io/kuadrant/kuadrant-operator:latest</code> <code>TAG</code> var could be use to build this URL, defaults to latest  if not provided <code>VERSION</code> Bundle version <code>0.0.0</code> <code>LIMITADOR_OPERATOR_BUNDLE_IMG</code> Limitador operator bundle URL <code>quay.io/kuadrant/limitador-operator-bundle:latest</code> <code>LIMITADOR_OPERATOR_VERSION</code> var could be used to build this, defaults to latest if not provided <code>AUTHORINO_OPERATOR_BUNDLE_IMG</code> Authorino operator bundle URL <code>quay.io/kuadrant/authorino-operator-bundle:latest</code> <code>AUTHORINO_OPERATOR_VERSION</code> var could be used to build this, defaults to latest if not provided <code>RELATED_IMAGE_WASMSHIM</code> WASM shim image URL <code>oci://quay.io/kuadrant/wasm-shim:latest</code> <code>WASM_SHIM_VERSION</code> var could be used to build this, defaults to latest if not provided <ul> <li>Build the bundle manifests</li> </ul> <pre><code>make bundle [IMG=quay.io/kuadrant/kuadrant-operator:latest] \\\n[VERSION=0.0.0] \\\n[LIMITADOR_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/limitador-operator-bundle:latest] \\\n[AUTHORINO_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/authorino-operator-bundle:latest] \\\n[RELATED_IMAGE_WASMSHIM=oci://quay.io/kuadrant/wasm-shim:latest]\n</code></pre> <ul> <li>Build the bundle image from the manifests</li> </ul> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Kuadrant operator bundle image URL <code>quay.io/kuadrant/kuadrant-operator-bundle:latest</code> <pre><code>make bundle-build [BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest]\n</code></pre> <ul> <li>Push the bundle image to a registry</li> </ul> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Kuadrant operator bundle image URL <code>quay.io/kuadrant/kuadrant-operator-bundle:latest</code> <pre><code>make bundle-push [BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest]\n</code></pre> <p>Frequently, you may need to build custom kuadrant bundle with the default (<code>latest</code>) Limitador and Authorino bundles. These are the example commands to build the manifests, build the bundle image and push to the regitry.</p> <p>In the example, a new kuadrant operator bundle version <code>0.8.0</code> will be created that references the kuadrant operator image <code>quay.io/kuadrant/kuadrant-operator:v0.5.0</code> and latest Limitador and Authorino bundles.</p> <pre><code># manifests\nmake bundle IMG=quay.io/kuadrant/kuadrant-operator:v0.5.0 VERSION=0.8.0\n\n# bundle image\nmake bundle-build BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:my-bundle\n\n# push bundle image\nmake bundle-push BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:my-bundle\n</code></pre>"},{"location":"kuadrant-operator/development/#build-custom-catalog","title":"Build custom catalog","text":"<p>The catalog's format will be File-based Catalg.</p> <p>Make sure all the required bundles are pushed to the registry. It is required by the <code>opm</code> tool.</p> <p>The <code>make catalog</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Kuadrant operator bundle image URL <code>quay.io/kuadrant/kuadrant-operator-bundle:latest</code> <code>LIMITADOR_OPERATOR_BUNDLE_IMG</code> Limitador operator bundle URL <code>quay.io/kuadrant/limitador-operator-bundle:latest</code> <code>AUTHORINO_OPERATOR_BUNDLE_IMG</code> Authorino operator bundle URL <code>quay.io/kuadrant/authorino-operator-bundle:latest</code> <pre><code>make catalog [BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest] \\\n[LIMITADOR_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/limitador-operator-bundle:latest] \\\n[AUTHORINO_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/authorino-operator-bundle:latest]\n</code></pre> <ul> <li>Build the catalog image from the manifests</li> </ul> Makefile Variable Description Default value <code>CATALOG_IMG</code> Kuadrant operator catalog image URL <code>quay.io/kuadrant/kuadrant-operator-catalog:latest</code> <pre><code>make catalog-build [CATALOG_IMG=quay.io/kuadrant/kuadrant-operator-catalog:latest]\n</code></pre> <ul> <li>Push the catalog image to a registry</li> </ul> <pre><code>make catalog-push [CATALOG_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest]\n</code></pre> <p>You can try out your custom catalog image following the steps of the Deploy kuadrant operator using OLM section.</p>"},{"location":"kuadrant-operator/development/#cleaning-up","title":"Cleaning up","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/development/#run-tests","title":"Run tests","text":""},{"location":"kuadrant-operator/development/#unittests","title":"Unittests","text":"<pre><code>make test-unit\n</code></pre> <p>Optionally, add <code>TEST_NAME</code> makefile variable to run specific test</p> <pre><code>make test-unit TEST_NAME=TestLimitIndexEquals\n</code></pre> <p>or even subtest</p> <pre><code>make test-unit TEST_NAME=TestLimitIndexEquals/empty_indexes_are_equal\n</code></pre>"},{"location":"kuadrant-operator/development/#integration-tests","title":"Integration tests","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Optionally, run kind and deploy kuadrant deps</p> <pre><code>make local-env-setup\n</code></pre> <p>Run integration tests</p> <pre><code>make test-integration\n</code></pre>"},{"location":"kuadrant-operator/development/#all-tests","title":"All tests","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Optionally, run kind and deploy kuadrant deps</p> <pre><code>make local-env-setup\n</code></pre> <p>Run all tests</p> <pre><code>make test\n</code></pre>"},{"location":"kuadrant-operator/development/#lint-tests","title":"Lint tests","text":"<pre><code>make run-lint\n</code></pre>"},{"location":"kuadrant-operator/development/#uninstall-kuadrant-crds","title":"(Un)Install Kuadrant CRDs","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Remove CRDs</p> <pre><code>make uninstall\n</code></pre>"},{"location":"kuadrant-operator/logging/","title":"Logging","text":"<p>The kuadrant operator outputs 3 levels of log messages: (from lowest to highest level) 1. <code>debug</code> 2. <code>info</code> (default) 3. <code>error</code></p> <p><code>info</code> logging is restricted to high-level information. Actions like creating, deleteing or updating kubernetes resources will be logged with reduced details about the corresponding objects, and without any further detailed logs of the steps in between, except for errors.</p> <p>Only <code>debug</code> logging will include processing details.</p> <p>To configure the desired log level, set the environment variable <code>LOG_LEVEL</code> to one of the supported values listed above. Default log level is <code>info</code>.</p> <p>Apart from log level, the operator can output messages to the logs in 2 different formats: - <code>production</code> (default): each line is a parseable JSON object with properties <code>{\"level\":string, \"ts\":int, \"msg\":string, \"logger\":string, extra values...}</code> - <code>development</code>: more human-readable outputs, extra stack traces and logging info, plus extra values output as JSON, in the format: <code>&lt;timestamp-iso-8601&gt;\\t&lt;log-level&gt;\\t&lt;logger&gt;\\t&lt;message&gt;\\t{extra-values-as-json}</code></p> <p>To configure the desired log mode, set the environment variable <code>LOG_MODE</code> to one of the supported values listed above. Default log level is <code>production</code>.</p>"},{"location":"kuadrant-operator/rate-limiting/","title":"Kuadrant Rate Limiting","text":""},{"location":"kuadrant-operator/rate-limiting/#goals","title":"Goals","text":"<p>Kuadrant sees the following requirements for an ingress gateway based rate limit policy:</p> <ul> <li>Allow it to target routing/network resources such as HTTPRoute and Gateway and use these resources to provide needed context (which traffic workload (hostname), which gateway).</li> <li>Use it to define when to invoke rate limiting (what paths, what methods etc) and the needed metadata IE actions and descriptors that are needed to enforce the rate limiting requirements.</li> <li>Avoid exposing the end user to the complexity of the underlying configuration resources that has a much broader remit and surface area.</li> <li>Allow administrators (cluster operators) to set overrides and defaults that govern what can be done at the lower levels.</li> </ul>"},{"location":"kuadrant-operator/rate-limiting/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/rate-limiting/#envoys-rate-limit-service-potocol","title":"Envoy's Rate Limit Service Potocol","text":"<p>Kuadrant's rate limit implementation relies on the Rate Limit Service (RLS) protocol. The workflow per request would be:</p> <ol> <li>On incoming request, the gateway sends (optionally, depending on the context) one RateLimitRequest to the external rate limiting service.</li> <li>The external rate limiting service answers with a RateLimitResponse back to the gateway with either <code>OK</code> or <code>OVER_LIMIT</code> response code.</li> </ol> <p>The RateLimitPolicy contains the bits to configure both the gateway and the external rate limiting service.</p>"},{"location":"kuadrant-operator/rate-limiting/#the-ratelimitpolicy-object-overview","title":"The RateLimitPolicy object overview","text":"<p>The <code>RateLimitPolicy</code> resource includes, basically, three parts:</p> <ul> <li>A reference to existing routing/networing Gateway API resource.</li> <li>location: <code>spec.targetRef</code></li> <li>Gateway configuration to produce rate limit descriptors.</li> <li>location: <code>spec.rateLimits[].configurations</code> and <code>spec.rateLimits[].rules</code></li> <li>External rate limiting service, Limitador's configuration.</li> <li>location: <code>spec.rateLimits[].limits</code></li> </ul> <pre><code>---\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: my-rate-limit-policy\nspec:\n#  targetRef defines a reference to existing routing/networking resource object to apply policy to.\ntargetRef: { ... }\ngroup: gateway.networking.k8s.io\nkind: HTTPRoute / Gateway\nname: myroute / mygateway\nrateLimits:\n# Rules defines the list of conditions for which rate limit configuration will apply.\n# Used to configure ingress gateway.\n- rules: [ ... ]\n# Each configuration object represents one action configuration.\n# Each configuration produces, at most, one rate limit descriptor.\n# Used to configure ingress gateway.\nconfigurations: [ ... ]\n# Limits are used to configure rate limiting boundaries on time periods.\n# Used to configure kuadrant's external rate limiting service.\nlimits: [ ... ]\n</code></pre>"},{"location":"kuadrant-operator/rate-limiting/#using-the-ratelimitpolicy","title":"Using the RateLimitPolicy","text":""},{"location":"kuadrant-operator/rate-limiting/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When a rate limit policy targets an HTTPRoute, the policy is scoped by the domains defined at the referenced HTTPRoute's hostnames.</p> <p>The rate limit policy targeting an HTTPRoute will be applied to every single ingress gateway referenced by the HTTPRoute in the <code>spec.parentRefs</code> field.</p> <p>Targeting is defined with the <code>spec.targetRef</code> field, as follows:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: &lt;RLP name&gt;\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: HTTPRoute\nname: &lt;HTTPRoute Name&gt;\nrateLimits: [ ... ]\n</code></pre> <p></p> <p>Multiple HTTPRoutes with the same hostname</p> <p>When there are multiple HTTPRoutes with the same hostname, HTTPRoutes are all admitted and the ingress gateway will merge the routing configurations in the same virtualhost. In these cases, kuadrant control plane will also merge rate limit policies referencing HTTPRoutes with the same hostname.</p> <p>Overlapping HTTPRoutes</p> <p>If one RLP targets a route for <code>*.com</code> and other RLP targets another route for <code>api.com</code>, the kuadrant's control plane does not do any merging. A request coming for <code>api.com</code> will be rate limited according to the rules from the RLP targeting the route <code>api.com</code>. On the other hand, a request coming for <code>other.com</code> will be rate limited with the rules from the RLP targeting the route <code>*.com</code>.</p> <p>For example, let's say we have three rate limit policies in place:</p> <pre><code>RLP A -&gt; HTTPRoute A (api.toystore.com)\n\nRLP B -&gt; HTTPRoute B (other.toystore.com)\n\nRLP H -&gt; HTTPRoute H (*.toystore.com)\n</code></pre> <p>Request 1 (api.toystore.com) -&gt; RLP A will be applied</p> <p>Request 2 (other.toystore.com) -&gt; RLP B will be applied</p> <p>Request 3 (unknown.toystore.com) -&gt; RLP H will be applied</p>"},{"location":"kuadrant-operator/rate-limiting/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>A key use case is being able to provide governance over what service providers can and cannot do when exposing a service via a shared ingress gateway. As well as providing certainty that no service is exposed without my ability as a cluster administrator to protect my infrastructure from unplanned load from badly behaving clients etc.</p> <p>When a rate limit policy targets Gateway, the policy will be applied to all HTTP traffic hitting the gateway.</p> <p>Targeting is defined with the <code>spec.targetRef</code> field, as follows:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: &lt;RLP name&gt;\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: Gateway\nname: &lt;Gateway Name&gt;\nrateLimits: [ ... ]\n</code></pre> <p></p> <p>The kuadrant control plane will aggregate all the rate limit policies that apply to a gateway, including multiple RLP targeting HTTPRoutes and Gateways. For example, let's say we have four rate limit policies in place:</p> <pre><code>RLP A -&gt; HTTPRoute A (`api.toystore.com`) -&gt; Gateway G (`*.com`)\n\nRLP B -&gt; HTTPRoute B (`other.toystore.com`) -&gt; Gateway G (`*.com`)\n\nRLP H -&gt; HTTPRoute H (`*.toystore.com`) -&gt; Gateway G (`*.com`)\n\nRLP G -&gt; Gateway G (`*.com`)\n</code></pre> <p>Request 1 (<code>api.toystore.com</code>) -&gt; apply RLP A and RLP G</p> <p>Request 2 (<code>other.toystore.com</code>) -&gt; apply RLP B and RLP G</p> <p>Request 3 (<code>unknown.toystore.com</code>) -&gt; apply RLP H and RLP G</p> <p>Request 4 (<code>other.com</code>) -&gt; apply RLP G</p> <p>Note: When a request falls under the scope of multiple policies, all the policies will be applied. Following the rate limiting design guidelines, the most restrictive policy will be enforced.</p>"},{"location":"kuadrant-operator/rate-limiting/#action-configurations","title":"Action configurations","text":"<p>Action configurations are defined via rate limit configuration objects. The rate limit configuration object is the equivalent of the config.route.v3.RateLimit envoy object. One configuration is, in turn, a list of rate limit actions. Each action populates a descriptor entry. A list of descriptor entries compose a descriptor. A list of descriptors compose a RateLimitRequest. Each configuration produces, at most, one descriptor. Depending on the incoming request, one configuration may or may not produce a rate limit descriptor. These rate limiting configuration rules provide flexibility to produce multiple descriptors.</p> <p>An example to illustrate</p> <pre><code>configurations:\n- actions:\n- request_headers:\nheader_name: \"X-MY-CUSTOM-HEADER\"\ndescriptor_key: \"custom-header\"\nskip_if_absent: true\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"1\"\n</code></pre> <p>A request without \"X-MY-CUSTOM-HEADER\" would generate one descriptor with one entry:</p> <pre><code>(\"admin\": \"1\")\n</code></pre> <p>A request with a header \"X-MY-CUSTOM-HEADER=MY-VALUE\" would generate two descriptors, one entry each descriptor:</p> <pre><code>(\"admin\": \"1\")\n(\"custom-header\": \"MY-VALUE\")\n</code></pre> <p>Note: If one action is not able to populate a descriptor entry, the entire descriptor is discarded.</p> <p>Note: The external rate limiting service will be called only when there is at least one not empty descriptor.</p>"},{"location":"kuadrant-operator/rate-limiting/#policy-default-action-configurations","title":"Policy default action configurations","text":"<p>When a rate limit policy does not specify any action configuration, the Kuadrant control plane will assign a generic default action configuration for the traffic related to the targeted network resource. This default action configuration allows defining global limits for all the traffic related the targeted network resource. For instance, the following rate limit policy is valid:</p> <pre><code>spec:\ntargetRef: { ... }\nrateLimits:\n- limits:\n- maxValue: 5\nseconds: 10\n</code></pre>"},{"location":"kuadrant-operator/rate-limiting/#rate-limiting-configuration-rules","title":"Rate limiting configuration rules","text":"<p>Configuration rules allow rate limit configurations to be activated conditionally depending on the current context (the incoming HTTP request properties). Each rate limit configuration list can define, optionally, a list of rules to match the request. A match occurs when at least one rule matches the request.</p> <p>An example to illustrate. Given these rate limit configurations,</p> <pre><code>spec:\nrateLimits:\n- configurations:\n- actions:\n- generic_key:\ndescriptor_key: toystore-app\ndescriptor_value: \"1\"\n- rules:\n- hosts: [\"api.toystore.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: api\ndescriptor_value: \"1\"\n- rules:\n- hosts: [\"admin.toystore.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"1\"\n</code></pre> <ul> <li>When a request for <code>api.toystore.com</code> hits the gateway, the descriptors generated would be:</li> </ul> <pre><code>(\"toystore-app\", \"1\")\n(\"api\", \"1\")\n</code></pre> <ul> <li>When a request for <code>admin.toystore.com</code> hits the gateway, the descriptors generated would be:</li> </ul> <pre><code>(\"toystore-app\", \"1\")\n(\"admin\", \"1\")\n</code></pre> <ul> <li>When a request for <code>other.toystore.com</code> hits the gateway, the descriptors generated would be:</li> </ul> <pre><code>(\"toystore-app\", \"1\")\n</code></pre> <p>Note: If rules are not set, it is equivalent to matching all the requests.</p>"},{"location":"kuadrant-operator/rate-limiting/#known-limitations","title":"Known limitations","text":"<ul> <li>One HTTPRoute can only be targeted by one rate limit policy.</li> <li>One Gateway can only be targeted by one rate limit policy.</li> <li>Only supporting HTTPRoute/Gateway references from within the same namespace.</li> <li><code>hosts</code> in rules, <code>spec.rateLimits[].rules</code>, do not support wildcard prefixes.</li> </ul>"},{"location":"kuadrant-operator/rate-limiting/#how-implementation-details","title":"How: Implementation details","text":""},{"location":"kuadrant-operator/rate-limiting/#the-wasm-filter","title":"The WASM Filter","text":"<p>On designing kuadrant rate limiting and considering Istio/Envoy's rate limiting offering, we hit two limitations.</p> <ul> <li>Shared Rate Limiting Domain: The rate limiting domain used in the global rate limiting filter in Envoy are shared across the Ingress Gateway. This is because Istio creates only one filter chain by default at the listener level. This means the rate limiting filter configuration is shared at the gateway level (which rate limiting service to call, which domain to use). The triggering of actual rate limiting calls happens at the virtual host / route level by adding actions and descriptors. This need to have shared domains causes several issues:</li> <li>All rate limit configurations applied to limitador need to use a shared domain or set of   shared domains (when using stages). This means that for each rate limiting request,   limitador will need to iterate through each of the rate limit resources within the shared domain   and evaluate each of their conditions to find which one applies. As the number of APIs increases   so would the number of resources that limitador would need to evaluate.</li> <li>With a shared domain comes the risk of a clash. To avoid a potential clash, either the user or   Kuadrant operator would need to inject a globally unique condition into each rate limit   resource.</li> <li>Limited ability to invoke rate limiting based on the method or path: Although Envoy supports applying rate limits at both the virtual host and also the route level, via Istio this currently only works if you are using a VirtualService. This is because the EnvoyFilter needed to configure rate limiting needs a named route in order to match and apply a change to a specific route. This means for non VirtualService routing (IE HTTPRoute) path, header and method conditional rules must all be applied in Limitador directly which naturally creates additional load on Limitador, latency for endpoints that don\u2019t need/want rate limiting and the descriptors needed to apply rate limiting rules must all be defined at the host level rather than based on the path / method. Issues capturing this limitation are linked below:</li> <li>https://github.com/istio/istio/issues/36790</li> <li>https://github.com/istio/istio/issues/37346</li> <li>https://github.com/kubernetes-sigs/gateway-api/pull/996</li> </ul> <p>Therefore, not giving up entirely in existing Envoy's RateLimit Filter, we decided to move on and leverage the Envoy's Wasm Network Filter and implement rate limiting wasm-shim module compliant with the Envoy's Rate Limit Service (RLS). This wasm-shim module accepts a PluginConfig struct object as input configuration object.</p> <p>WASM filter configuration object (PluginConfig struct):</p> <pre><code>#  The filter\u2019s behaviour in case the rate limiting service does not respond back. When it is set to true, Envoy will not allow traffic in case of communication failure between rate limiting service and the proxy.\nfailure_mode_deny: true\nrate_limit_policies:\n- name: toystore\nrate_limit_domain: toystore-app\nupstream_cluster: rate-limit-cluster\nhostnames: [\"*.toystore.com\"]\ngateway_actions:\n- rules:\n- paths: [\"/admin/toy\"]\nmethods: [\"GET\"]\nhosts: [\"pets.toystore.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"1\"\n</code></pre> <p>The WASM filter configuration resources are part of the  internal configuration and therefore not exposed to the end user.</p> <p>At the WASM filter level, there are no HTTPRoute level or Gateway level rate limit policies. The rate limit policies in the wasm plugin configuration may not map 1:1 to user managed RateLimitPolicy custom resources. WASM rate limit policies have an internal logical name and a set of hostnames to activate it based on the incoming request\u2019s host header.</p> <p>Kuadrant deploys one WASM filter for rate limiting per gateway. Only when rate limiting needs to be applied in a gateway.</p> <p>The WASM filter builds a tree based data structure holding the rate limit policies. The longest (sub)domain match is used to select the policy to be applied. Only one policy is being applied per invocation.</p>"},{"location":"kuadrant-operator/ratelimitpolicy-reference/","title":"The RateLimitPolicy Custom Resource Definition (CRD)","text":"<ul> <li>The RateLimitPolicy Custom Resource Definition (CRD)</li> <li>RateLimitPolicy</li> <li>RateLimitPolicySpec<ul> <li>RateLimit<ul> <li>Configuration</li> <li>ActionSpecifier</li> <li>Rule</li> <li>Limit</li> </ul> </li> </ul> </li> <li>RateLimitPolicyStatus<ul> <li>ConditionSpec</li> </ul> </li> </ul> <p>Generated using github-markdown-toc</p>"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#ratelimitpolicy","title":"RateLimitPolicy","text":"json/yaml field Type Required Description <code>spec</code> RateLimitPolicySpec Yes The specfication for RateLimitPolicy custom resource <code>status</code> RateLimitPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#ratelimitpolicyspec","title":"RateLimitPolicySpec","text":"json/yaml field Type Required Default value Description <code>targetRef</code> gatewayapiv1alpha2.PolicyTargetReference Yes N/A identifies an API object to apply policy to <code>rateLimits</code> []RateLimit No empy list list of rate limit configurations"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#ratelimit","title":"RateLimit","text":"json/yaml field Type Required Default value Description <code>configurations</code> []Configuration No Empty list of action configurations <code>rules</code> []Rule No Empty. All configurations apply list of action configurations rules. Rate limit configuration will apply when at least one rule matches the request <code>limits</code> []Limit No Empty list of Limitador limit objects"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#configuration","title":"Configuration","text":"json/yaml field Type Required Default value Description <code>actions</code> []ActionSpecifier No empty list of action specifiers. Each action specifier can only define one action type."},{"location":"kuadrant-operator/ratelimitpolicy-reference/#actionspecifier","title":"ActionSpecifier","text":"json/yaml field Type Required Default value Description <code>generic_key</code> config.route.v3.RateLimit.Action.GenericKey No null generic key action <code>metadata</code> config.route.v3.RateLimit.Action.MetaData No null descriptor entry is appended when the metadata contains a key value <code>remote_address</code> config.route.v3.RateLimit.Action.RemoteAddress No null descriptor entry is appended to the descriptor and is populated using the trusted address from x-forwarded-for <code>request_headers</code> config.route.v3.RateLimit.Action.RequestHeaders No null descriptor entry is appended when a header contains a key that matches the header_name"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#rule","title":"Rule","text":"json/yaml field Type Required Default value Description <code>paths</code> []string No null list of paths. Request matches when one from the list matches <code>methods</code> []string No null list of methods to match. Request matches when one from the list matches <code>hosts</code> []string No null list of hostnames to match. Wildcard hostnames are valid. Request matches when one from the list matches. Each defined hostname must be subset of one of the hostnames defined by the targeted network resource"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#limit","title":"Limit","text":"json/yaml field Type Required Default value Description <code>maxValue</code> int Yes N/A max number of request for the specified time period <code>seconds</code> int Yes N/A time period in seconds <code>conditions</code> []string No Empty list Limit conditions. Check Limitador for more information <code>variables</code> []string No Empty list Limit variables. Check Limitador for more information"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#ratelimitpolicystatus","title":"RateLimitPolicyStatus","text":"json field  Type Info <code>observedGeneration</code> string helper field to see if status info is up to date with latest resource spec <code>conditions</code> array of conditions resource conditions"},{"location":"kuadrant-operator/ratelimitpolicy-reference/#conditionspec","title":"ConditionSpec","text":"<p>The status object has an array of Conditions through which the resource has or has not passed. Each element of the Condition array has the following fields:</p> <ul> <li>The lastTransitionTime field provides a timestamp for when the entity last transitioned from one status to another.</li> <li>The message field is a human-readable message indicating details about the transition.</li> <li>The reason field is a unique, one-word, CamelCase reason for the condition\u2019s last transition.</li> <li>The status field is a string, with possible values True, False, and Unknown.</li> <li>The type field is a string with the following possible values:</li> <li>Available: the resource has successfully configured;</li> </ul> Field json field Type Info Type <code>type</code> string Condition Type Status <code>status</code> string Status: True, False, Unknown Reason <code>reason</code> string Condition state reason Message <code>message</code> string Condition state description LastTransitionTime <code>lastTransitionTime</code> timestamp Last transition timestamp"},{"location":"kuadrant-operator/proposals/authpolicy-crd/","title":"AuthPolicy Proposal","text":"<p>Authors: Rahul Anand (rahanand@redhat.com), Craig Brookes (cbrookes@redhat.com)</p>"},{"location":"kuadrant-operator/proposals/authpolicy-crd/#introduction","title":"Introduction","text":"<p>Istio offers an AuthorizationPolicy resource which requires it to be applied in the namespace of the workload. This means that all the configuration is completely decoupled from routing logic like hostnames and paths. For managed gateway scenario, users need to either ask cluster operator to apply their policies in the gateway's namespace (which is not scalable) or use sidecars/personal gateway for their workloads in their own namepsace which is not optimal.</p> <p>The new GatewayAPI defines a standard policy attachment mechanism for hierarchical effect of vendor specific policies. We believe creating a new CRD with concepts from Gateway API that solves use cases of Istio's AuthorizationPolicy plus its limitations as described above.</p>"},{"location":"kuadrant-operator/proposals/authpolicy-crd/#goals","title":"Goals","text":"<p>With <code>targetRef</code>  from policy attachment concept, following are the goals: - Application developer should be able target <code>HTTPRoute</code> object in their own namespace. This will define authorization policy at the hostname/domain/vHost level. - Cluster operator should be able to target <code>Gateway</code> object along with HTTPRoute in the gateway's namespace. This will define policy at the listener level. - To reduce context sharing at the gateway and external authorization provider, action type and auth-provider are defaulted to <code>CUSTOM</code> and authorino respectively.</p>"},{"location":"kuadrant-operator/proposals/authpolicy-crd/#proposed-solution","title":"Proposed Solution","text":"<p>Following is the proposed new CRD that combines policy attachment concepts with Istio's AuthorizationPolicy:</p> <p>```yaml= apiVersion: kuadrant.io/v1beta1 kind: AuthPolicy metadata:   name: toystore spec:   targetRef:     group: # Only takes gateway.networking.k8s.io     kind: HTTPRoute | Gateway     name: toystore   rules:     - hosts: [\".toystore.com\"]       methods: [\"GET\", \"POST\"]       paths: [\"/admin\"]   authScheme: # Embedded AuthConfigs     hosts: [\"admin.toystore.com\"]     identity:     - name: idp-users       oidc:         endpoint: https://my-idp.com/auth/realm     authorization:     - name: check-claim       json:         rules:         - selector: auth.identity.group           operator: eq           value: allowed-users status:   conditions:     - lastTransitionTime: \"2022-06-06T11:03:04Z\"       message: HTTPRoute/Gateway is protected/Error       reason: HTTPRouteProtected/GatewayProtected/Error       status: \"True\" | \"False\"       type: Available     observedGeneration: 1 <pre><code>### Target Reference\n`targetRef` field is taken from [policy attachment's target reference API](https://gateway-api.sigs.k8s.io/v1alpha2/references/policy-attachment/#target-reference-api). It can only target one resource at a time. Fields included inside:\n- `Group` is the group of the target resource. Only valid option is `gateway.networking.k8s.io`.\n- `Kind` is kind of the target resource. Only valid options are `HTTPRoute` and `Gateway`.\n- `Name` is the name of the target resource.\n- `Namespace` is the namespace of the referent. Currently only local objects can be referred so value is ignored.\n\n### Rule objects\n`rules` field describe the requests that will be routed to external authorization provider (like authorino). It includes:\n- `hosts`: a host is matched over `Host` request header or `SNI` if TLS is used.\n\n**Note**: Each rule's host in a route level policy must match at least one hostname regex described in [HTTPRoute's `hostnames`](https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.Hostname) but Gateway level policies have no such restriction.\n</code></pre>                             targetRef        HTTPRoute  \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  AuthPolicy   hostnames: [\".toystore.com\"]             rules:                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             Rejected Rule: \u2502- hosts: [\"*.carstore.com\"] \u2502                             Regex mismatch \u2502  methods: [\"GET\", \"DELETE\"]\u2502                                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518</p> <pre><code>                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        Accepted Rule: \u2502- hosts: [\"admin.toystore.com\"]\u2502\n                        Regex match    \u2502  methods: [\"POST\", \"DELETE\"]  \u2502\n                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p><code>- `paths`: a path matches over request path like `/admin/`. - `methods`: a method matches over request method like `DELETE`.  Fields in a rule object are ANDed together but inner fields follow OR semantics. For example,</code> hosts: [\".toystore.com\"] methods: [\"GET\", \"POST\"] paths: [\"/admin\"] <code>`` The above rule matches if the host matches</code>.toystore.com<code>AND the method is</code>POST<code>OR</code>GET<code>; AND path is</code>/admin<code>Internally, All the rules in a AuthPolicy are translated into list of [</code>Operations`](https://istio.io/latest/docs/reference/config/security/authorization-policy/#Operation) under a single Istio's AuthorizationPolicy with CUSTOM action type and external authorization provider as authorino. </p>"},{"location":"kuadrant-operator/proposals/authpolicy-crd/#authscheme-object","title":"AuthScheme object","text":"<p>AuthScheme is embedded form of Authorino's AuthConfig. Applying an AuthPolicy resource with AuthScheme defined, would create an AuthConfig in the Gateway's namespace.  Note: Following the heirarchial constraints, <code>spec.AuthScheme.Hosts</code> must match at least one <code>spec.Hosts</code> for AuthPolicy to be validated.  The example AuthPolicy showed above will create the following AuthConfig:  <code>yaml= apiVersion: authorino.kuadrant.io/v1beta1 kind: AuthConfig metadata:   name: default-toystore-1 spec:   hosts:   - \"admin.toystore.com\"   identity:     - name: idp-users       oidc:         endpoint: https://my-idp.com/auth/realm   authorization:     - name: check-claim       json:         rules:           - selector: auth.identity.group             operator: eq             value: allowed-users</code></p> <p>Overall control structure looks like the following between the developer and the kuadrant operator: </p>"},{"location":"kuadrant-operator/proposals/authpolicy-crd/#checklist","title":"Checklist","text":"<ul> <li>Issue tracking this proposal: https://github.com/Kuadrant/kuadrant-operator/issues/130</li> </ul>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/","title":"RLP can target a Gateway resource","text":"<p>Previous version: https://hackmd.io/IKEYD6NrSzuGQG1nVhwbcw</p> <p>Based on: https://hackmd.io/_1k6eLCNR2eb9RoSzOZetg</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#introduction","title":"Introduction","text":"<p>The current RateLimitPolicy CRD already implements a <code>targetRef</code> with a reference to Gateway API's HTTPRoute. This doc  captures the design and some implementation details of allowing the <code>targetRef</code> to reference a Gateway API's Gateway.</p> <p>Having in place this HTTPRoute - Gateway hierarchy, we are also considering to apply Policy Attachment's defaults/overrides approach to the RateLimitPolicy CRD. But for now, it will only be about targeting the Gateway resource.</p> <p></p> <p>On designing kuadrant rate limiting and considering Istio/Envoy's rate limiting offering, we hit two limitations (described here). Therefore, not giving up entirely in existing Envoy's RateLimit Filter, we decided to move on and leverage the Envoy's Wasm Network Filter and implement rate limiting wasm-shim module compliant with the Envoy's Rate Limit Service (RLS). This wasm-shim module accepts a PluginConfig struct object as input configuration object.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#use-cases-targeting-a-gateway","title":"Use Cases targeting a gateway","text":"<p>A key use case is being able to provide governance over what service providers can and cannot do when exposing a service via a shared ingress gateway. As well as providing certainty that no service is exposed without my ability as a cluster administrator to protect my infrastructure from unplanned load from badly behaving clients etc.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#goals","title":"Goals","text":"<p>The goal of this document is to define: * The schema of this <code>PluginConfig</code> struct. * The kuadrant-operator behavior filling the <code>PluginConfig</code> struct having as input the RateLimitPolicy k8s objects * The behavior of the wasm-shim having the <code>PluginConfig</code> struct as input.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#envoys-rate-limit-service-potocol","title":"Envoy's Rate Limit Service Potocol","text":"<p>Kuadrant's rate limit relies on the Rate Limit Service (RLS) protocol, hence the gateway generates, based on a set of actions, a set of descriptors (one descriptor is a set of descriptor entries). Those descriptors are send to the external rate limit service provider. When multiple descriptors are provided, the external service provider will limit on ALL of them and return an OVER_LIMIT response if any of them are over limit.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#schema-crd-of-the-ratelimitpolicy","title":"Schema (CRD) of the RateLimitPolicy","text":"<pre><code>---\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: my-rate-limit-policy\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: HTTPRoute / Gateway\nname: myroute / mygateway\nrateLimits:\n- rules:\n- paths: [\"/admin/*\"]\nmethods: [\"GET\"]\nhosts: [\"example.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"yes\"\nlimits:\n- conditions: [\"admin == yes\"]\nmax_value: 500\nseconds: 30\nvariables: []\n</code></pre> <p><code>.spec.rateLimits</code> holds a list of rate limit configurations represented by the object <code>RateLimit</code>. Each <code>RateLimit</code> object represents a complete rate limit configuration. It contains three fields:</p> <ul> <li> <p><code>rules</code> (optional): Rules allow matching <code>hosts</code> and/or <code>methods</code> and/or <code>paths</code>. Matching occurs when at least one rule applies against the incoming request. If rules are not set, it is equivalent to matching all the requests.</p> </li> <li> <p><code>configurations</code> (required): Specifies a set of rate limit configurations that could be applied. The rate limit configuration object is the equivalent of the config.route.v3.RateLimit envoy object. One configuration is, in turn, a list of rate limit actions. Each action populates a descriptor entry. A vector of descriptor entries compose a descriptor. Each configuration produces, at most, one descriptor. Depending on the incoming request, one configuration may or may not produce a rate limit descriptor. These rate limiting configuration rules provide flexibility to produce multiple descriptors. For example, you may want to define one generic rate limit descriptor and another descriptor depending on some header. If the header does not exist, the second descriptor is not generated, but traffic keeps being rate limited based on the generic descriptor.</p> </li> </ul> <pre><code>configurations:\n- actions:\n- request_headers:\nheader_name: \"X-MY-CUSTOM-HEADER\"\ndescriptor_key: \"custom-header\"\nskip_if_absent: true\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"1\"\n</code></pre> <ul> <li><code>limits</code> (optional): configuration of the rate limiting service (Limitador). Check out limitador documentation for more information about the fields of each <code>Limit</code> object.</li> </ul> <p>Note: No <code>namespace</code>/<code>domain</code> defined. Kuadrant operator will figure out.</p> <p>Note: There is no <code>PREAUTH</code>, <code>POSTAUTH</code> stage defined. Ratelimiting filter should be placed after authorization filter to enable authenticated rate limiting. In the future, <code>stage</code> can be implemented.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#kuadrant-operators-behavior","title":"Kuadrant-operator's behavior","text":"<p>One HTTPRoute can only be targeted by one rate limit policy.</p> <p>Similarly, one Gateway can only be targeted by one rate limit policy.</p> <p>However, indirectly, one gateway will be affected by multiple rate limit policies. It is by design of the Gateway API, one gateway can be referenced by multiple HTTPRoute objects. Furthermore, one HTTPRoute can reference multiple gateways.</p> <p>The kuadrant operator will aggregate all the rate limit policies that apply for each gateway, including RLP targeting HTTPRoutes and Gateways.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#virtualhosting-ratelimitpolicies","title":"\"VirtualHosting\" RateLimitPolicies","text":"<p>Rate limit policies are scoped by the domains defined at the referenced HTTPRoute's hostnames and Gateway's Listener's Hostname.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#multiple-httproutes-with-the-same-hostname","title":"Multiple HTTPRoutes with the same hostname","text":"<p>When there are multiple HTTPRoutes with the same hostname, HTTPRoutes are all admitted and envoy merge the routing configuration in the same virtualhost. In these cases, the control plane has to \"merge\" the rate limit configuration into a single entry for the wasm filter.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#overlapping-httproutes","title":"Overlapping HTTPRoutes","text":"<p>If some RLP targets a route for <code>*.com</code> and other RLP targets another route for <code>api.com</code>, the control plane does not do any merging. A request coming for <code>api.com</code> will be rate limited with the rules from the RLP targeting the route <code>api.com</code>. Also, a request coming for <code>other.com</code> will be rate limited with the rules from the RLP targeting the route <code>*.com</code>.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#examples","title":"examples","text":"<p>RLP A -&gt; HTTPRoute A (<code>api.toystore.com</code>) -&gt; Gateway G (<code>*.com</code>)</p> <p>RLP B -&gt; HTTPRoute B (<code>other.toystore.com</code>) -&gt; Gateway G (<code>*.com</code>)</p> <p>RLP H -&gt; HTTPRoute H (<code>*.toystore.com</code>) -&gt; Gateway G (<code>*.com</code>)</p> <p>RLP G -&gt; Gateway G (<code>*.com</code>)</p> <p>Request 1 (<code>api.toystore.com</code>) -&gt; apply RLP A and RLP G</p> <p>Request 2 (<code>other.toystore.com</code>) -&gt; apply RLP B and RLP G</p> <p>Request 3 (<code>unknown.toystore.com</code>) -&gt; apply RLP H and RLP G</p> <p>Request 4 (<code>other.com</code>) -&gt; apply RLP G</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#rate-limit-domain-limitador-namespace","title":"rate limit domain / limitador namespace","text":"<p>The kuadrant operator will add <code>domain</code> attribute of the Envoy's Rate Limit Service (RLS). It will also add the <code>namespace</code> attribute of the Limitador's rate limit config. The operator will ensure that the associated actions and rate limits have a common domain/namespace.</p> <p>The value of this domain/namespace seems to be related to the virtualhost for which rate limit applies.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#schema-of-the-wasm-filter-configuration-object-the-pluginconfig","title":"Schema of the WASM filter configuration object: the <code>PluginConfig</code>","text":"<p>Currently the PluginConfig looks like this:</p> <pre><code>#  The filter\u2019s behaviour in case the rate limiting service does not respond back. When it is set to true, Envoy will not allow traffic in case of communication failure between rate limiting service and the proxy.\nfailure_mode_deny: true\nratelimitpolicies:\ndefault/toystore: # rate limit policy {NAMESPACE/NAME}\nhosts: # HTTPRoute hostnames\n- '*.toystore.com'\nrules: # route level actions\n- operations:\n- paths:\n- /admin/toy\nmethods:\n- POST\n- DELETE\nactions:\n- generic_key:\ndescriptor_value: yes\ndescriptor_key: admin\nglobal_actions: # virtualHost level actions\n- generic_key:\ndescriptor_value: yes\ndescriptor_key: vhaction\nupstream_cluster: rate-limit-cluster # Limitador address reference\ndomain: toystore-app # RLS protocol domain value\n</code></pre> <p>Proposed new design for the WASM filter configuration object (<code>PluginConfig</code> struct):</p> <pre><code>#  The filter\u2019s behaviour in case the rate limiting service does not respond back. When it is set to true, Envoy will not allow traffic in case of communication failure between rate limiting service and the proxy.\nfailure_mode_deny: true\nrate_limit_policies:\n- name: toystore\nrate_limit_domain: toystore-app\nupstream_cluster: rate-limit-cluster\nhostnames: [\"*.toystore.com\"]\ngateway_actions:\n- rules:\n- paths: [\"/admin/toy\"]\nmethods: [\"GET\"]\nhosts: [\"pets.toystore.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"1\"\n</code></pre> <p>Update highlights: * [minor] <code>rate_limit_policies</code> is a list instead of a map indexed by the name/namespace. * [major] no distinction between \"rules\" and global actions * [major] more aligned with RLS: multiple descriptors structured by \"rate limit configurations\" with matching rules</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#wasm-shim","title":"WASM-SHIM","text":"<p>WASM filter rate limit policies are not exactly the same as user managed RateLimitPolicy custom resources. The WASM filter rate limit policies is part of the  internal configuration and therefore not exposed to the end user.</p> <p>At the WASM filter level, there are no route level or gateway level rate limit policies. The rate limit policies in the wasm plugin configuration may not map 1:1 to user managed RateLimitPolicy custom resources. WASM rate limit policies have an internal logical name and a set of hostnames to activate it based on the incoming request\u2019s host header.</p> <p>The WASM filter builds a tree based data structure holding the rate limit policies. The longest (sub)domain match is used to select the policy to be applied. Only one policy is being applied per invocation.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#rate-limit-configurations","title":"rate limit configurations","text":"<p>The WASM filter configuration object contains a list of rate limit configurations to build a list of Envoy's RLS descriptors. These configurations are defined at</p> <pre><code>rate_limit_policies[*].gateway_actions[*].configurations\n</code></pre> <p>For example:</p> <pre><code>configurations:\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"1\"\n</code></pre> <p>How to read the policy:</p> <ul> <li> <p>Each configuration produces, at most, one descriptor. Depending on the incoming request, one configuration may or may not produce a rate limit descriptor.</p> </li> <li> <p>Each policy configuration has associated, optionally, a set of rules to match. Rules allow matching <code>hosts</code> and/or <code>methods</code> and/or <code>paths</code>. Matching occurs when at least one rule applies against the incoming request. If rules are not set, it is equivalent to matching all the requests.</p> </li> <li> <p>Each configuration object defines a list of actions. Each action may (or may not) produce a descriptor entry (descriptor list item). If an action cannot append a descriptor entry, no descriptor is generated for the configuration.</p> </li> </ul> <p>Note: The external rate limit service will be called when the <code>gateway_actions</code> object produces at least one not empty descriptor.</p>"},{"location":"kuadrant-operator/proposals/rlp-target-gateway-resource/#example","title":"example","text":"<p>WASM filter rate limit policy for <code>*.toystore.com</code>. I want some rate limit descriptors configuration only for <code>api.toystore.com</code> and another set of descriptors for <code>admin.toystore.com</code>. The wasm filter config would look like this:</p> <pre><code>failure_mode_deny: true\nrate_limit_policies:\n- name: toystore\nrate_limit_domain: toystore-app\nupstream_cluster: rate-limit-cluster\nhostnames: [\"*.toystore.com\"]\ngateway_actions:\n- configurations:  # no rules. Applies to all *.toystore.com traffic\n- actions:\n- generic_key:\ndescriptor_key: toystore-app\ndescriptor_value: \"1\"\n- rules:\n- hosts: [\"api.toystore.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: api\ndescriptor_value: \"1\"\n- rules:\n- hosts: [\"admin.toystore.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: admin\ndescriptor_value: \"1\"\n</code></pre> <ul> <li>When a request for <code>api.toystore.com</code> hits the filter, the descriptors generated would be:</li> </ul> <p>descriptor 1 <pre><code>(\"toystore-app\", \"1\")\n</code></pre> descriptor 2 <pre><code>(\"api\", \"1\")\n</code></pre></p> <ul> <li>When a request for <code>admin.toystore.com</code> hits the filter, the descriptors generated would be:</li> </ul> <p>descriptor 1 <pre><code>(\"toystore-app\", \"1\")\n</code></pre> descriptor 2 <pre><code>(\"admin\", \"1\")\n</code></pre></p> <ul> <li>When a request for <code>other.toystore.com</code> hits the filter, the descriptors generated would be: descriptor 1 <pre><code>(\"toystore-app\", \"1\")\n</code></pre></li> </ul>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/","title":"Authenticated rl for api owners","text":""},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#authenticated-rate-limit-for-api-owners","title":"Authenticated Rate Limit For API Owners","text":"<p>This user guide shows how to configure authenticated rate limiting. Authenticated rate limiting allows to specify rate limiting configurations based on the traffic owners, i.e. ID of the user owning the request. Authentication method used will be the API key.</p>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#clone-the-project","title":"Clone the project","text":"<pre><code>git clone https://github.com/Kuadrant/kuadrant-operator\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#setup-environment","title":"Setup environment","text":"<p>This step creates a containerized Kubernetes server locally using Kind, then it installs Istio, Kubernetes Gateway API and kuadrant.</p> <pre><code>make local-setup\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#apply-kuadrant-cr","title":"Apply Kuadrant CR","text":"<pre><code>kubectl -n kuadrant-system apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\nname: kuadrant-sample\nspec: {}\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#deploy-toystore-example-deployment","title":"Deploy toystore example deployment","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#create-httproute-to-configure-routing-to-the-toystore-service","title":"Create HTTPRoute to configure routing to the toystore service","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\n---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\nname: toystore\nlabels:\napp: toystore\nspec:\nparentRefs:\n- name: istio-ingressgateway\nnamespace: istio-system\nhostnames: [\"*.toystore.com\"]\nrules:\n- matches:\n- path:\ntype: PathPrefix\nvalue: \"/toy\"\nmethod: GET\nbackendRefs:\n- name: toystore\nport: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#check-toystore-httproute-works","title":"Check <code>toystore</code> HTTPRoute works","text":"<pre><code>curl -v -H 'Host: api.toystore.com' http://localhost:9080/toy\n</code></pre> <p>It should return <code>200 OK</code>.</p> <p>Note: This only works out of the box on linux environments. If not on linux, you may need to forward ports</p> <pre><code>kubectl port-forward -n istio-system service/istio-ingressgateway 9080:80 &amp;\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#create-api-keys-for-user-bob-and-alice","title":"Create API keys for user <code>Bob</code> and <code>Alice</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\n---\napiVersion: v1\nkind: Secret\nmetadata:\nannotations:\nsecret.kuadrant.io/user-id: bob\nname: bob-key\nlabels:\nauthorino.kuadrant.io/managed-by: authorino\napp: toystore\nstringData:\napi_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\nannotations:\nsecret.kuadrant.io/user-id: alice\nname: alice-key\nlabels:\nauthorino.kuadrant.io/managed-by: authorino\napp: toystore\nstringData:\napi_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#create-kuadrants-authpolicy-to-configure-api-key-based-authentication","title":"Create Kuadrant's <code>AuthPolicy</code> to configure API key based authentication","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: AuthPolicy\nmetadata:\nname: toystore\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: HTTPRoute\nname: toystore\nrules:\n- paths: [\"/toy*\"]\nauthScheme:\nidentity:\n- name: friends\napiKey:\nallNamespaces: true\nselector:\nmatchLabels:\napp: toystore\ncredentials:\nin: authorization_header\nkeySelector: APIKEY\nresponse:\n- json:\nproperties:\n- name: userID\nvalue: null\nvalueFrom:\nauthJSON: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nname: rate-limit-apikey\nwrapper: envoyDynamicMetadata\nwrapperKey: ext_auth_data\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#create-ratelimitpolicy-to-rate-limit-per-api-key-basis","title":"Create RateLimitPolicy to rate limit per API key basis","text":"User Rate Limits <code>Bob</code> 2 reqs / 10 secs (0.2 rps) <code>Alice</code> 5 reqs / 10 secs (0.5 rps) <pre><code>kubectl apply -f -&lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: toystore\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: HTTPRoute\nname: toystore\nrateLimits:\n- configurations:\n- actions:\n- metadata:\ndescriptor_key: \"userID\"\ndefault_value: \"no-user\"\nmetadata_key:\nkey: \"envoy.filters.http.ext_authz\"\npath:\n- segment:\nkey: \"ext_auth_data\"\n- segment:\nkey: \"userID\"\nlimits:\n- conditions:\n- \"userID == 'bob'\"\nmaxValue: 2\nseconds: 10\nvariables: []\n- conditions:\n- \"userID == 'alice'\"\nmaxValue: 5\nseconds: 10\nvariables: []\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-for-api-owners/#validating-the-rate-limit-policy","title":"Validating the rate limit policy","text":"<p>Only 2 requests every 10 allowed for Bob.</p> <pre><code>curl -v -H 'Authorization: APIKEY IAMBOB' -H 'Host: api.toystore.com' http://localhost:9080/toy\n</code></pre> <p>Only 5 requests every 10 allowed for Alice.</p> <pre><code>curl -v -H 'Authorization: APIKEY IAMALICE' -H 'Host: api.toystore.com' http://localhost:9080/toy\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/","title":"Rate-limiting and protecting an API with JSON Web Tokens (JWTs) and Kubernetes authnz using Kuadrant","text":"<p>Example of rate-limiting and protecting an API (the Toy Store API) with authentication based on ID tokens (signed JWTs) issued by an OpenId Connect (OIDC) server (Keycloak) and alternative Kubernetes Service Account tokens, and authorization based on Kubernetes RBAC, with permissions (bindings) stored as Kubernetes Roles and RoleBindings.</p>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Docker</li> <li>kubectl command-line tool</li> <li>jq</li> </ul>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#run-the-guide","title":"Run the guide \u2776 \u2192 \u277c","text":""},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#setup-the-environment","title":"\u2776 Setup the environment","text":"<p>Clone the project:</p> <pre><code>git clone https://github.com/Kuadrant/kuadrant-operator &amp;&amp; cd kuadrant-operator\n</code></pre> <p>Spin-up the cluster with all dependencies installed:</p> <pre><code>make local-env-setup deploy\n</code></pre> \ud83e\udd14 What exactly does the step above do?    1. Creates a containerized Kuberentes server using [Kind](https://kind.sigs.k8s.io/)   2. Installs [Istio](https://istio.io)   3. Installs Kuberentes [Gateway API](https://gateway-api.sigs.k8s.io/concepts/api-overview)   4. Installs the Kuadrant system (CRDs and operators)"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-the-api","title":"\u2777 Deploy the API","text":"<p>Deploy the application in the <code>default</code> namespace:</p> <pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre> <p>Create the <code>HTTPRoute</code>:</p> <pre><code>kubectl apply -f examples/toystore/httproute.yaml\n</code></pre> <p>Expose the API:</p> <pre><code>kubectl port-forward -n istio-system service/istio-ingressgateway 9080:80 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#api-lifecycle","title":"API lifecycle","text":""},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-unprotected","title":"Try the API unprotected","text":"<pre><code>curl -H 'Host: api.toystore.com' http://localhost:9080/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#request-the-kuadrant-instance","title":"\u2778 Request the Kuadrant instance","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\nspec: {}\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-keycloak","title":"\u2779 Deploy Keycloak","text":"<p>Create the namesapce:</p> <pre><code>kubectl create namespace keycloak\n</code></pre> <p>Deploy Keycloak:</p> <pre><code>kubectl apply -n keycloak -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>The step above deploys Keycloak with a preconfigured realm and a couple of clients and users created.</p> <p>The Keycloak server may take a couple minutes to be ready.</p>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#create-the-authpolicy","title":"\u277a Create the <code>AuthPolicy</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: AuthPolicy\nmetadata:\n  name: toystore-protection\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  authScheme:\n    identity:\n      - name: keycloak-users\n        oidc:\n          endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n      - name: k8s-service-accounts\n        kubernetes:\n          audiences:\n            - https://kubernetes.default.svc.cluster.local\n    authorization:\n      - name: k8s-rbac\n        kubernetes:\n          user:\n            valueFrom:\n              authJSON: auth.identity.sub\n    response:\n      - name: rate-limit\n        json:\n          properties:\n            - name: userID\n              valueFrom:\n                authJSON: auth.identity.sub\n        wrapper: envoyDynamicMetadata\n        wrapperKey: ext_auth_data\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-missing-authentication","title":"Try the API missing authentication","text":"<pre><code>curl -H 'Host: api.toystore.com' http://localhost:9080/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-users\"\n# www-authenticate: Bearer realm=\"k8s-service-accounts\"\n# x-ext-auth-reason: {\"k8s-service-accounts\":\"credential not found\",\"keycloak-users\":\"credential not found\"}\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-without-permission","title":"Try the API without permission","text":"<p>Obtain an access token with the Keycloak server:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>Send requests to the API as the Keycloak-authenticated user (missing permission):</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://localhost:9080/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>Create a Kubernetes Service Account to represent a user belonging to the other source of identities:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: client-app-1\nEOF\n</code></pre> <p>Obtain an aaccess token for the <code>client-app-1</code> service account:</p> <pre><code>SA_TOKEN=$(kubectl create token client-app-1)\n</code></pre> <p>Send requests to the API as the service account (missing permission):</p> <pre><code>curl -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' http://localhost:9080/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#grant-access-to-the-api","title":"\u277b Grant access to the API","text":"<p>Create the <code>toystore-reader</code> and <code>toystore-writer</code> roles:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-reader\nrules:\n- nonResourceURLs: [\"/toy*\"]\n  verbs: [\"get\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-writer\nrules:\n- nonResourceURLs: [\"/admin/toy\"]\n  verbs: [\"post\", \"delete\"]\nEOF\n</code></pre> <p>Add permissions to the users and service accounts:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-readers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-reader\nsubjects:\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$ACCESS_TOKEN\")\n- kind: ServiceAccount\n  name: client-app-1\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-writers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-writer\nsubjects:\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$ACCESS_TOKEN\")\nEOF\n</code></pre> \ud83e\udd14 Can I use <code>Roles</code> and <code>RoleBindings</code> instead of <code>ClusterRoles</code> and <code>ClusterRoleBindings</code>?    Yes, you can.    The example above is for non-resource URL Kubernetes roles. For using `Roles` and `RoleBindings` instead of   `ClusterRoles` and `ClusterRoleBindings`, thus more flexible resource-based permissions to protect the API,   see the spec for [Kubernetes SubjectAccessReview authorization](https://github.com/Kuadrant/authorino/blob/v0.5.0/docs/features.md#kubernetes-subjectaccessreview-authorizationkubernetes)   in the Authorino docs."},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-with-permission","title":"Try the API with permission","text":"<p>Send requests to the API as the Keycloak-authenticated user:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://localhost:9080/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' -X POST http://localhost:9080/admin/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Send requests to the API as the service account (missing permission):</p> <pre><code>curl -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' http://localhost:9080/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' -X POST http://localhost:9080/admin/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#create-the-ratelimitpolicy","title":"\u277c Create the <code>RateLimitPolicy</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-rate-limit\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rateLimits:\n    - configurations:\n        - actions:\n            - metadata:\n                descriptor_key: \"userID\"\n                default_value: \"no-user\"\n                metadata_key:\n                  key: \"envoy.filters.http.ext_authz\"\n                  path:\n                    - segment:\n                        key: \"ext_auth_data\"\n                    - segment:\n                        key: \"userID\"\n      limits:\n        - conditions: []\n          maxValue: 5\n          seconds: 10\n          variables:\n            - userID\nEOF\n</code></pre> <p>Note: It may take a couple minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-rate-limited","title":"Try the API rate limited","text":"<p>Send requests as the Keycloak-authenticated user:</p> <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://localhost:9080/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Send requests as the service account:</p> <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' http://localhost:9080/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Each user should be entitled to a maximum of 5 requests to the API every 10 seconds.</p> <p>Note: You may need to refresh the tokens if they are expired.</p>"},{"location":"kuadrant-operator/user-guides/authenticated-rl-with-jwt-and-k8s-authnz/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/","title":"Gateway rl for cluster operators","text":""},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#gateway-rate-limit-for-cluster-operators","title":"Gateway Rate Limit For Cluster Operators","text":"<p>This user guide shows how the kuadrant's control plane applies rate limit policy at Gateway API's Gateway level.</p>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#clone-the-project","title":"Clone the project","text":"<pre><code>git clone https://github.com/Kuadrant/kuadrant-operator\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#setup-environment","title":"Setup environment","text":"<p>This step creates a containerized Kubernetes server locally using Kind, then it installs Istio, Kubernetes Gateway API and kuadrant.</p> <pre><code>make local-setup\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#apply-kuadrant-cr","title":"Apply Kuadrant CR","text":"<pre><code>kubectl -n kuadrant-system apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\nname: kuadrant-sample\nspec: {}\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#deploy-toystore-example-deployment","title":"Deploy toystore example deployment","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#create-httproute-to-configure-routing-to-the-toystore-service","title":"Create HTTPRoute to configure routing to the toystore service","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\n---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\nname: toystore\nlabels:\napp: toystore\nspec:\nparentRefs:\n- name: istio-ingressgateway\nnamespace: istio-system\nhostnames: [\"*.toystore.com\"]\nrules:\n- matches:\n- path:\ntype: PathPrefix\nvalue: \"/toy\"\nmethod: GET\n- path:\ntype: PathPrefix\nvalue: \"/free\"\nmethod: GET\n- path:\ntype: Exact\nvalue: \"/admin/toy\"\nmethod: POST\nbackendRefs:\n- name: toystore\nport: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#check-toystore-httproute-works","title":"Check <code>toystore</code> HTTPRoute works","text":"<p><code>GET /toy</code>: no rate limiting <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Host: api.toystore.com\" http://localhost:9080/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre></p> <p><code>POST /admin/toy</code>: no rate limiting <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Host: api.toystore.com\" -X POST http://localhost:9080/admin/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre></p> <p>Note: This only works out of the box on linux environments. If not on linux, you may need to forward ports</p> <pre><code>kubectl port-forward -n istio-system service/istio-ingressgateway 9080:80\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#rate-limiting-toystore-httproute-traffic","title":"Rate limiting <code>toystore</code> HTTPRoute traffic","text":"<p>RateLimitPolicy applied for the <code>toystore</code> HTTPRoute.</p> Endpoints Rate Limits <code>POST /admin/toy</code> 5 reqs / 10 secs (0.5 rps) <code>GET /toy</code> 8 reqs / 10 secs (0.8 rps) <code>*</code> 30 reqs / 10 secs (3.0 rps) <pre><code>kubectl apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: toystore\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: HTTPRoute\nname: toystore\nrateLimits:\n- rules:\n- paths: [\"/admin/toy\"]\nmethods: [\"POST\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: admin_operation\ndescriptor_value: \"1\"\nlimits:\n- conditions:\n- \"admin_operation == '1'\"\nmaxValue: 5\nseconds: 10\nvariables: []\n- rules:\n- paths: [\"/toy\"]\nmethods: [\"GET\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: get_operation\ndescriptor_value: \"1\"\nlimits:\n- conditions:\n- \"get_operation == '1'\"\nmaxValue: 8\nseconds: 10\nvariables: []\n- configurations:\n- actions:\n- generic_key:\ndescriptor_key: toystore\ndescriptor_value: \"1\"\nlimits:\n- conditions: [\"toystore == '1'\"]\nmaxValue: 30\nseconds: 10\nvariables: []\nEOF\n</code></pre> <p>Validating the rate limit policy.</p> <p><code>GET /toy</code> @ 1 rps (expected to be rate limited @ 8 reqs / 10 secs (0.8 rps)) <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Host: api.toystore.com\" http://localhost:9080/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre></p> <p><code>POST /admin/toy</code> @ 1 rps (expected to be rate limited @ 5 reqs / 10 secs (0.5 rps)) <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Host: api.toystore.com\" -X POST http://localhost:9080/admin/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre></p>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#rate-limiting-gateway-traffic","title":"Rate limiting Gateway traffic","text":"<p>RateLimitPolicy applied for the Gateway.</p> Policy Rate Limits <code>POST /*</code> 2 reqs / 10 secs (0.2 rps) Per remote IP 25 reqs / 10 secs (2.5 rps) <pre><code>kubectl apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: kuadrant-gw\nnamespace: istio-system\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: Gateway\nname: istio-ingressgateway\nrateLimits:\n- rules:\n- methods: [\"POST\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: expensive_op\ndescriptor_value: \"1\"\nlimits:\n- conditions: [\"expensive_op == '1'\"]\nmaxValue: 2\nseconds: 10\nvariables: []\n- configurations:\n- actions:\n- remote_address: {}\nlimits:\n- conditions: []\nmaxValue: 25\nseconds: 10\nvariables: [\"remote_address\"]\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#validating-the-rate-limit-policies-httproute-and-gateway","title":"Validating the rate limit policies (HTTPRoute and Gateway).","text":"<p><code>GET /toy</code> @ 1 rps (expected to be rate limited @ 8 reqs / 10 secs (0.8 rps)) <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Host: api.toystore.com\" http://localhost:9080/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre></p> <p><code>POST /admin/toy</code> @ 1 rps (expected to be rate limited @ 2 reqs / 10 secs (0.2 rps)) <pre><code>while :; do curl --write-out '%{http_code}' --silent --output /dev/null -H \"Host: api.toystore.com\" -X POST http://localhost:9080/admin/toy | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre></p>"},{"location":"kuadrant-operator/user-guides/gateway-rl-for-cluster-operators/#validating-gateway-per-remote-ip-policy","title":"Validating Gateway \"Per Remote IP\" policy","text":"<p>Stop all traffic.</p> <p><code>GET /free</code> @ 3 rps (expected to be rate limited @ 25 reqs / 10 secs (2.5 rps))</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Host: api.toystore.com\" http://localhost:9080/free -: --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Host: api.toystore.com\" http://localhost:9080/free -: --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Host: api.toystore.com\" http://localhost:9080/free | egrep --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/","title":"Simple Rate Limit For API Owners","text":"<p>This user guide shows how to configure rate limiting for one of the subdomains.</p>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#clone-the-project","title":"Clone the project","text":"<pre><code>git clone https://github.com/Kuadrant/kuadrant-operator\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#setup-environment","title":"Setup environment","text":"<p>This step creates a containerized Kubernetes server locally using Kind, then it installs Istio, Kubernetes Gateway API and kuadrant.</p> <pre><code>make local-setup\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#apply-kuadrant-cr","title":"Apply Kuadrant CR","text":"<pre><code>kubectl -n kuadrant-system apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\nname: kuadrant-sample\nspec: {}\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#deploy-toystore-example-deployment","title":"Deploy toystore example deployment","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#create-httproute-to-configure-routing-to-the-toystore-service","title":"Create HTTPRoute to configure routing to the toystore service","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\n---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\nname: toystore\nlabels:\napp: toystore\nspec:\nparentRefs:\n- name: istio-ingressgateway\nnamespace: istio-system\nhostnames: [\"*.toystore.com\"]\nrules:\n- matches:\n- path:\ntype: PathPrefix\nvalue: \"/toy\"\nmethod: GET\nbackendRefs:\n- name: toystore\nport: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#check-toystore-httproute-works","title":"Check <code>toystore</code> HTTPRoute works","text":"<pre><code>curl -v -H 'Host: api.toystore.com' http://localhost:9080/toy\n</code></pre> <p>It should return <code>200 OK</code>.</p> <p>Note: This only works out of the box on linux environments. If not on linux, you may need to forward ports</p> <pre><code>kubectl port-forward -n istio-system service/istio-ingressgateway 9080:80 &amp;\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#create-ratelimitpolicy-for-ratelimiting-only-for-specific-subdomain","title":"Create RateLimitPolicy for ratelimiting only for specific subdomain","text":"<p>RateLimitPolicy applied for the <code>toystore</code> HTTPRoute.</p> Hostname Rate Limits <code>rate-limited.toystore.com</code> 5 reqs / 10 secs (0.5 rps) <code>*.toystore.com</code> not rate limited <pre><code>kubectl apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: toystore\nspec:\ntargetRef:\ngroup: gateway.networking.k8s.io\nkind: HTTPRoute\nname: toystore\nrateLimits:\n- rules:\n- hosts: [\"rate-limited.toystore.com\"]\nconfigurations:\n- actions:\n- generic_key:\ndescriptor_key: \"limited\"\ndescriptor_value: \"1\"\nlimits:\n- conditions:\n- \"limited == '1'\"\nmaxValue: 5\nseconds: 10\nvariables: []\nEOF\n</code></pre>"},{"location":"kuadrant-operator/user-guides/simple-rl-for-api-owners/#validating-the-rate-limit-policy","title":"Validating the rate limit policy","text":"<p>Only 5 requests every 10 secs on <code>rate-limited.toystore.com</code> allowed.</p> <pre><code>curl -v -H 'Host: rate-limited.toystore.com' http://localhost:9080/toy\n</code></pre> <p>Whereas <code>other.toystore.com</code> is not rate limited.</p> <pre><code>curl -v -H 'Host: other.toystore.com' http://localhost:9080/toy\n</code></pre>"},{"location":"authorino/","title":"Documentation","text":""},{"location":"authorino/#getting-started","title":"Getting started","text":""},{"location":"authorino/#terminology","title":"Terminology","text":""},{"location":"authorino/#architecture","title":"Architecture","text":""},{"location":"authorino/#feature-description","title":"Feature description","text":""},{"location":"authorino/#user-guides","title":"User guides","text":""},{"location":"authorino/#developers-guide","title":"Developer\u2019s guide","text":""},{"location":"authorino/architecture/","title":"Architecture","text":"<ul> <li>Overview</li> <li>Topologies</li> <li>Centralized gateway</li> <li>Centralized authorization service</li> <li>Sidecars</li> <li>Cluster-wide vs. Namespaced instances</li> <li>The Authorino <code>AuthConfig</code> Custom Resource Definition (CRD)</li> <li>Resource reconciliation and status update</li> <li>The \"Auth Pipeline\" (aka: enforcing protection in request-time)</li> <li>Host lookup</li> <li>Avoiding host name collision</li> <li>The Authorization JSON</li> <li>Raw HTTP Authorization interface</li> <li>Caching</li> <li>OpenID Connect and User-Managed Access configs</li> <li>JSON Web Keys (JWKs) and JSON Web Ket Sets (JWKS)</li> <li>Revoked access tokens</li> <li>External metadata</li> <li>Compiled Rego policies</li> <li>Repeated requests</li> <li>Sharding</li> <li>RBAC</li> <li>Observability</li> </ul>"},{"location":"authorino/architecture/#overview","title":"Overview","text":"<p>There are a few concepts to understand Authorino's architecture. The main components are: Authorino, Envoy and the Upstream service to be protected. Envoy proxies requests to the the configured virtual host upstream service, first contacting with Authorino to decide on authN/authZ.</p> <p>The topology can vary from centralized proxy and centralized authorization service, to dedicated sidecars, with the nuances in between. Read more about the topologies in the Topologies section below.</p> <p>Authorino is deployed using the Authorino Operator, from an <code>Authorino</code> Kubernetes custom resource. Then, from another kind of custom resource, the <code>AuthConfig</code> CRs, each Authorino instance reads and adds to the index the exact rules of authN/authZ to enforce for each protected host (\"index reconciliation\").</p> <p>Everything that the AuthConfig reconciler can fetch in reconciliation-time is stored in the index. This is the case of static parameters such as signing keys, authentication secrets and authorization policies from external policy registries.</p> <p><code>AuthConfig</code>s can refer to identity providers (IdP) and trusted auth servers whose access tokens will be accepted to authenticate to the protected host. Consumers obtain an authentication token (short-lived access token or long-lived API key) and send those in the requests to the protected service.</p> <p>When Authorino is triggered by Envoy via the gRPC interface, it starts evaluating the Auth Pipeline, i.e. it applies to the request the parameters to verify the identity and to enforce authorization, as found in the index for the requested host (See host lookup for details).</p> <p>Apart from static rules, these parameters can include instructions to contact online with external identity verifiers, external sources of metadata and policy decision points (PDPs).</p> <p>On every request, Authorino's \"working memory\" is called Authorization JSON, a data structure that holds information about the context (the HTTP request) and objects from each phase of the auth pipeline: i.e., identity verification (phase i), ad-hoc metadata fetching (phase ii), authorization policy enforcement (phase iii), dynamic response (phase iv), and callbacks (phase v). The evaluators in each of these phases can both read and write from the Authorization JSON for dynamic steps and decisions of authN/authZ.</p>"},{"location":"authorino/architecture/#topologies","title":"Topologies","text":"<p>Typically, upstream APIs are deployed to the same Kubernetes cluster and namespace where the Envoy proxy and Authorino is running (although not necessarily). Whatever is the case, Envoy must be proxying to the upstream API (see Envoy's HTTP route components and virtual hosts) and pointing to Authorino in the external authorization filter.</p> <p>This can be achieved with different topologies: - Envoy can be a centralized gateway with one dedicated instance of Authorino, proxying to one or more upstream services - Envoy can be deployed as a sidecar of each protected service, but still contacting from a centralized Authorino authorization service - Both Envoy and Authorino deployed as sidecars of the protected service, restricting all communication between them to localhost</p> <p>Each topology above induces different measures for security.</p>"},{"location":"authorino/architecture/#centralized-gateway","title":"Centralized gateway","text":"<p>Recommended in the protected services to validate the origin of the traffic. It must have been proxied by Envoy. See Authorino JSON injection for an extra validation option using a shared secret passed in HTTP header.</p>"},{"location":"authorino/architecture/#centralized-authorization-service","title":"Centralized authorization service","text":"<p>Protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/architecture/#sidecars","title":"Sidecars","text":"<p>Recommended <code>namespaced</code> instances of Authorino with fine-grained label selectors to avoid unnecessary caching of <code>AuthConfig</code>s.</p> <p>Apart from that, protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/architecture/#cluster-wide-vs-namespaced-instances","title":"Cluster-wide vs. Namespaced instances","text":"<p>Auhorino instances can run in either cluster-wide or namespaced mode.</p> <p>Namespace-scoped instances only watch resources (<code>AuthConfig</code>s and <code>Secret</code>s) created in a given namespace. This deployment mode does not require admin privileges over the Kubernetes cluster to deploy the instance of the service (given Authorino's CRDs have been installed beforehand, such as when Authorino is installed using the Authorino Operator).</p> <p>Cluster-wide deployment mode, in contraposition, deploys instances of Authorino that watch resources across the entire cluster, consolidating all resources into a multi-namespace index of auth configs. Admin privileges over the Kubernetes cluster is required to deploy Authorino in cluster-wide mode.</p> <p>Be careful to avoid superposition when combining multiple Authorino instances and instance modes in the same Kubernetes cluster. Apart from caching unnecessary auth config data in the instances depending on your routing settings, the leaders of each instance (set of replicas) may compete for updating the status of the custom resources that are reconciled. See Resource reconciliation and status update for more information.</p> <p>If necessary, use label selectors to narrow down the space of resources watched and reconciled by each Authorino instance. Check out the Sharding section below for details.</p>"},{"location":"authorino/architecture/#the-authorino-authconfig-custom-resource-definition-crd","title":"The Authorino <code>AuthConfig</code> Custom Resource Definition (CRD)","text":"<p>The desired protection for a service is declaratively stated by applying an <code>AuthConfig</code> Custom Resource to the Kubernetes cluster running Authorino.</p> <p>An <code>AuthConfig</code> resource typically looks like the following:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: my-api-protection\nspec:\n# List of one or more hostname[:port] entries, lookup keys to find this config in request-time\n# Authorino will try to prevent hostname collision by rejecting a hostname already taken.\nhosts:\n- my-api.io # north-south traffic\n- my-api.ns.svc.cluster.local # east-west traffic\n# List of one or more trusted sources of identity:\n# - Endpoints of issuers of OpenId Connect ID tokens (JWTs)\n# - Endpoints for OAuth 2.0 token introspection\n# - Attributes for the Kubernetes `TokenReview` API\n# - Label selectors for API keys (stored in Kubernetes `Secret`s)\n# - mTLS trusted certificate issuers\n# - HMAC secrets\nidentity: [\u2026]\n# List of sources of external metadata for the authorization (optional):\n# - Endpoints for HTTP GET or GET-by-POST requests\n# - OIDC UserInfo endpoints (associated with an OIDC token issuer)\n# - User-Managed Access (UMA) resource registries\nmetadata: [\u2026]\n# List of authorization policies to be enforced (optional):\n# - JSON pattern-matching rules (e.g. `context.request.http.path eq '/pets'`)\n# - Open Policy Agent (OPA) inline or external Rego policies\n# - Attributes for the Kubernetes `SubjectAccessReview` API\nauthorization: [\u2026]\n# List of dynamic response elements, to inject post-external authorization data into the request (optional):\n# - JSON objects\n# - Festival Wristbands (signed JWTs issued by Authorino)\n# - Envoy Dynamic Metadata\nresponse: [\u2026]\n# List of callback targets:\n# - Endpoints for HTTP requests\ncallbacks: [\u2026]\n# Custom HTTP status code, message and headers to replace the default `401 Unauthorized` and `403 Forbidden` (optional)\ndenyWith:\nunauthenticated:\ncode: 302\nmessage: Redirecting to login\nheaders:\n- name: Location\nvalue: https://my-app.io/login\nunauthorized: {\u2026}\n</code></pre> <p>Check out the OAS of the <code>AuthConfig</code> CRD for a formal specification of the options for <code>identity</code> verification, external <code>metadata</code> fetching, <code>authorization</code> policies, and dynamic <code>response</code>, as well as any other host protection capability implemented by Authorino.</p> <p>You can also read the specification from the CLI using the <code>kubectl explain</code> command. The Authorino CRD is required to have been installed in Kubernetes cluster. E.g. <code>kubectl explain authconfigs.spec.identity.extendedProperties</code>.</p> <p>A complete description of supported features and corresponding configuration options within an <code>AuthConfig</code> CR can be found in the Features page.</p> <p>More concrete examples of <code>AuthConfig</code>s for specific use-cases can be found in the User guides.</p>"},{"location":"authorino/architecture/#resource-reconciliation-and-status-update","title":"Resource reconciliation and status update","text":"<p>The instances of the Authorino authorization service workload, following the Operator pattern, watch events related to the <code>AuthConfig</code> custom resources, to build and reconcile an in-memory index of configs. Whenever a replica receives traffic for authorization request, it looks up in the index of <code>AuthConfig</code>s and then triggers the \"Auth Pipeline\", i.e. enforces the associated auth spec onto the request.</p> <p>An instance can be a single authorization service workload or a set of replicas. All replicas watch and reconcile the same set of resources that match the <code>--auth-config-label-selector</code> and <code>--secret-label-selector</code> configuration options. (See both Cluster-wide vs. Namespaced instances and Sharding, for details about defining the reconciliation space of Authorino instances.)</p> <p>The above means that all replicas of an Authorino instance should be able to receive traffic for authorization requests.</p> <p>Among the multiple replicas of an instance, Authorino elects one replica to be leader. The leader is responsible for updating the status of reconciled <code>AuthConfig</code>s. If the leader eventually becomes unavailable, the instance will automatically elect another replica take its place as the new leader.</p> <p>The status of an <code>AuthConfig</code> tells whether the resource is \"ready\" (i.e. indexed). It also includes summary information regarding the numbers of identity configs, metadata configs, authorization configs and response configs within the spec, as well as whether Festival Wristband tokens are being issued by the Authorino instance as by spec.</p> <p>Apart from watching events related to <code>AuthConfig</code> custom resources, Authorino also watches events related to Kubernetes <code>Secret</code>s, as part of Authorino's API key authentication feature. <code>Secret</code> resources that store API keys are linked to their corresponding <code>AuthConfig</code>s in the index. Whenever the Authorino instance detects a change in the set of API key <code>Secret</code>s linked to an <code>AuthConfig</code>s, the instance reconciles the index.</p> <p>Authorino only watches events related to <code>Secret</code>s whose <code>metadata.labels</code> match the label selector <code>--secret-label-selector</code> of the Authorino instance. The default values of the label selector for Kubernetes <code>Secret</code>s representing Authorino API keys is <code>authorino.kuadrant.io/managed-by=authorino</code>.</p>"},{"location":"authorino/architecture/#the-auth-pipeline-aka-enforcing-protection-in-request-time","title":"The \"Auth Pipeline\" (aka: enforcing protection in request-time)","text":"<p>In each request to the protected API, Authorino triggers the so-called \"Auth Pipeline\", a set of configured evaluators that are organized in a 5-phase pipeline:</p> <ul> <li>(i) Identity phase: at least one source of identity (i.e., one identity evaluator) must resolve the supplied credential in the request into a valid identity or Authorino will otherwise reject the request as unauthenticated (401 HTTP response status).</li> <li>(ii) Metadata phase: optional fetching of additional data from external sources, to add up to context and identity information, and used in authorization policies, dynamic responses and callback requests (phases iii to v).</li> <li>(iii) Authorization phase: all unskipped policies must evaluate to a positive result (\"authorized\"), or Authorino will otherwise reject the request as unauthorized (403 HTTP response code).</li> <li>(iv) Response phase \u2013 Authorino builds all user-defined response items (dynamic JSON objects and/or Festival Wristband OIDC tokens), which are supplied back to the external authorization client within added HTTP headers or as Envoy Dynamic Metadata</li> <li>(v) Callbacks phase \u2013 Authorino sends callbacks to specified HTTP endpoints.</li> </ul> <p>Each phase is sequential to the other, from (i) to (v), while the evaluators within each phase are triggered concurrently or as prioritized. The Identity phase (i) is the only one required to list at least one evaluator (i.e. one identity source or more); Metadata, Authorization and Response phases can have any number of evaluators (including zero, and even be omitted in this case).</p>"},{"location":"authorino/architecture/#host-lookup","title":"Host lookup","text":"<p>Authorino reads the request host from <code>Attributes.Http.Host</code> of Envoy's <code>CheckRequest</code> type, and uses it as key to lookup in the index of <code>AuthConfig</code>s, matched against <code>spec.hosts</code>.</p> <p>Alternatively to <code>Attributes.Http.Host</code>, a <code>host</code> entry can be supplied in the <code>Attributes.ContextExtensions</code> map of the external authorino request. This will take precedence before the host attribute of the HTTP request.</p> <p>The <code>host</code> context extension is useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup with lookup strongly dictated by the external authorization client (e.g. Envoy), which often knows about routing and the expected <code>AuthConfig</code> to enforce beyond what Authorino can infer strictly based on the host name.</p> <p>Wildcards can also be used in the host names specified in the <code>AuthConfig</code>, resolved by Authorino. E.g. if <code>*.pets.com</code> is in <code>spec.hosts</code>, Authorino will match the concrete host names <code>dogs.pets.com</code>, <code>cats.pets.com</code>, etc. In case, of multiple possible matches, Authorino will try the longest match first (in terms of host name labels) and fall back to closest wildcard upwards in the domain tree (if any).</p> <p>When more than one host name is specified in the <code>AuthConfig</code>, all of them can be used as key, i.e. all of them can be requested in the authorization request and will be mapped to the same config.</p> <p>Example. Host lookup with wildcards.</p> <p></p> <p>The domain tree above induces the following relation: - <code>foo.nip.io</code> \u2192 <code>authconfig-1</code> (matches <code>*.io</code>) - <code>talker-api.nip.io</code> \u2192 <code>authconfig-2</code> (matches <code>talker-api.nip.io</code>) - <code>dogs.pets.com</code> \u2192 <code>authconfig-2</code> (matches <code>*.pets.com</code>) - <code>api.acme.com</code> \u2192 <code>authconfig-3</code> (matches <code>api.acme.com</code>) - <code>www.acme.com</code> \u2192 <code>authconfig-4</code> (matches <code>*.acme.com</code>) - <code>foo.org</code> \u2192 <code>404 Not found</code></p> <p></p> <p>The host can include the port number (i.e. <code>hostname:port</code>) or it can be just the name of the host name. Authorino will first try finding in the index a config associated to <code>hostname:port</code>, as supplied in the authorization request; if the index misses an entry for <code>hostname:port</code>, Authorino will then remove the <code>:port</code> suffix and repeate the lookup using just <code>hostname</code> as key. This provides implicit support for multiple port numbers for a same host without having to list all combinations in the <code>AuthConfig</code>.</p>"},{"location":"authorino/architecture/#avoiding-host-name-collision","title":"Avoiding host name collision","text":"<p>Authorino tries to prevent host name collision between <code>AuthConfig</code>s by rejecting to link in the index any <code>AuthConfig</code> and host name if the host name is already linked to a different <code>AuthConfig</code> in the index. This was intentionally designed to prevent users from surperseding each others' <code>AuthConfig</code>s, partially or fully, by just picking the same host names or overlapping host names as others.</p> <p>When wildcards are involved, a host name that matches a host wildcard already linked in the index to another <code>AuthConfig</code> will be considered taken, and therefore the newest <code>AuthConfig</code> will be rejected to be linked to that host.</p>"},{"location":"authorino/architecture/#the-authorization-json","title":"The Authorization JSON","text":"<p>On every Auth Pipeline, Authorino builds the Authorization JSON, a \"working-memory\" data structure composed of <code>context</code> (information about the request, as supplied by the Envoy proxy to Authorino) and <code>auth</code> (objects resolved in phases (i) to (v) of the pipeline). The evaluators of each phase can read from the Authorization JSON and implement dynamic properties and decisions based on its values.</p> <p>At phase (iii), the authorization evaluators count on an Auhtorization JSON payload that looks like the following:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>The policies evaluated can use any data from the authorization JSON to define authorization rules.</p> <p>After phase (iii), Authorino appends to the authorization JSON the results of this phase as well, and the payload available for phase (iv) becomes:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    },\n    \"authorization\": {\n      // each authorization policy result resolved by the evaluators of phase (iii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>Festival Wristbands and Dynamic JSON responses can include dynamic values (custom claims/properties) fetched from the authorization JSON. These can be returned to the external authorization client in added HTTP headers or as Envoy Well Known Dynamic Metadata. Check out Dynamic response features for details.</p> <p>For information about reading and fetching data from the Authorization JSON (syntax, functions, etc), check out JSON paths.</p>"},{"location":"authorino/architecture/#raw-http-authorization-interface","title":"Raw HTTP Authorization interface","text":"<p>Besides providing the gRPC authorization interface \u2013 that implements the Envoy gRPC authorization server \u2013, Authorino also provides another interface for raw HTTP authorization. This second interface responds to <code>GET</code> and <code>POST</code> HTTP requests sent to <code>:5001/check</code>, and is suitable for other forms of integration, such as: - using Authorino as Kubernetes ValidatingWebhook service (example); - other HTTP proxies and API gateways; - old versions of Envoy incompatible with the latest version of gRPC external authorization protocol (Authorino is based on v3.19.1 of Envoy external authorization API)</p> <p>In the raw HTTP interface, the host used to lookup for an <code>AuthConfig</code> must be supplied in the <code>Host</code> HTTP header of the request. Other attributes of the HTTP request are also passed in the context to evaluate the <code>AuthConfig</code>, including the body of the request.</p>"},{"location":"authorino/architecture/#caching","title":"Caching","text":""},{"location":"authorino/architecture/#openid-connect-and-user-managed-access-configs","title":"OpenID Connect and User-Managed Access configs","text":"<p>OpenID Connect and User-Managed Access configurations, discovered usually at reconciliation-time from well-known discovery endpoints.</p> <p>Cached individual OpenID Connect configurations discovered by Authorino can be configured to be auto-refreshed, by setting the corresponding <code>spec.identity.oidc.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/architecture/#json-web-keys-jwks-and-json-web-ket-sets-jwks","title":"JSON Web Keys (JWKs) and JSON Web Ket Sets (JWKS)","text":"<p>JSON signature verification certificates linked by discovered OpenID Connect configurations, fetched usually at reconciliation-time.</p>"},{"location":"authorino/architecture/#revoked-access-tokens","title":"Revoked access tokens","text":"Not implemented - In analysis (#19) <p>Caching of access tokens identified and or notified as revoked prior to expiration.</p>"},{"location":"authorino/architecture/#external-metadata","title":"External metadata","text":"Not implemented - Planned (#21) <p>Caching of resource data obtained in previous requests.</p>"},{"location":"authorino/architecture/#compiled-rego-policies","title":"Compiled Rego policies","text":"<p>Performed automatically by Authorino at reconciliation-time for the authorization policies based on the built-in OPA module.</p> <p>Precompiled and cached individual Rego policies originally pulled by Authorino from external registries can be configured to be auto-refreshed, by setting the corresponding <code>spec.authorization.opa.externalRegistry.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/architecture/#repeated-requests","title":"Repeated requests","text":"Not implemented - In analysis (#20) <p>For consecutive requests performed, within a given period of time, by a same user that request for a same resource, such that the result of the auth pipeline can be proven that would not change.</p>"},{"location":"authorino/architecture/#sharding","title":"Sharding","text":"<p>By default, Authorino instances will watch <code>AuthConfig</code> CRs in the entire space (namespace or entire cluster; see Cluster-wide vs. Namespaced instances for details). To support combining multiple Authorino instances and instance modes in the same Kubernetes cluster, and yet avoiding superposition between the instances (i.e. multiple instances reconciling the same <code>AuthConfig</code>s), Authorino offers support for data sharding, i.e. to horizontally narrow down the space of reconciliation of an Authorino instance to a subset of that space.</p> <p>The benefits of limiting the space of reconciliation of an Authorino instance include avoiding unnecessary caching and workload in instances that do not receive corresponding traffic (according to your routing settings) and preventing leaders of multiple instances (sets of replicas) to compete on resource status updates (see Resource reconciliation and status update for details).</p> <p>Use-cases for sharding of <code>AuthConfig</code>s: - Horizontal load balancing of traffic of authorization requests - Supporting for managed centralized instances of Authorino to API owners who create and maintain their own <code>AuthConfig</code>s within their own user namespaces.</p> <p>Authorino's custom controllers filter the <code>AuthConfig</code>-related events to be reconciled using Kubernetes label selectors, defined for the Authorino instance via <code>--auth-config-label-selector</code> command-line flag. By default, <code>--auth-config-label-selector</code> is empty, meaning all <code>AuthConfig</code>s in the space are watched; this variable can be set to any value parseable as a valid label selector, causing Authorino to then watch only events of <code>AuthConfig</code>s whose <code>metadata.labels</code> match the selector.</p> <p>The following are all valid examples of <code>AuthConfig</code> label selector filters:</p> <pre><code>--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino,other-label=other-value\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by in (authorino,kuadrant)\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by!=authorino-v0.4\"\n--auth-config-label-selector=\"!disabled\"\n</code></pre>"},{"location":"authorino/architecture/#rbac","title":"RBAC","text":"<p>The table below describes the roles and role bindings defined by the Authorino service:</p> Role Kind Scope(*) Description Permissions <code>authorino-manager-role</code> <code>ClusterRole</code> C/N Role of the Authorino manager service Watch and reconcile <code>AuthConfig</code>s and <code>Secret</code>s <code>authorino-manager-k8s-auth-role</code> <code>ClusterRole</code> C/N Role for the Kubernetes auth features Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s (Kubernetes auth) <code>authorino-leader-election-role</code> <code>Role</code> N Leader election role Create/update the <code>ConfigMap</code> used to coordinate which replica of Authorino is the leader <code>authorino-authconfig-editor-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> editor R/W <code>AuthConfig</code>s; Read <code>AuthConfig/status</code> <code>authorino-authconfig-viewer-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> viewer Read <code>AuthConfig</code>s and <code>AuthConfig/status</code> <code>authorino-proxy-role</code> <code>ClusterRole</code> C/N Kube-rbac-proxy-role (sidecar)'s role Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s to check permissions to the <code>/metrics</code> endpoint <code>authorino-metrics-reader</code> <code>ClusterRole</code> - Metrics reader <code>GET /metrics</code> <p>(*) C - Cluster-wide | N - Authorino namespace | C/N - Cluster-wide or Authorino namespace (depending on the deployment mode).</p>"},{"location":"authorino/architecture/#observability","title":"Observability","text":"<p>Please refer to the Observability user guide for info on Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p>"},{"location":"authorino/code_of_conduct/","title":"Code of conduct","text":""},{"location":"authorino/code_of_conduct/#authorino-code-of-conduct-v10","title":"Authorino Code of Conduct v1.0","text":"<p>This document provides community guidelines for a safe, respectful, productive, and collaborative place for any person who is willing to contribute to Authorino.</p> <ul> <li>Participants will be tolerant of opposing views.</li> <li>Participants must ensure that their language and actions are free of personal attacks and disparaging personal remarks.</li> <li>When interpreting the words and actions of others, participants should always assume good intentions.</li> <li>Behaviour which can be reasonably considered harassment will not be tolerated.</li> </ul> <p>This Code of Conduct is adapted from the The Ruby Community Conduct Guideline</p>"},{"location":"authorino/contributing/","title":"Developer's Guide","text":"<ul> <li>Technology stack for developers</li> <li>Workflow</li> <li>Check the issues</li> <li>Clone the repo and setup the local environment</li> <li>Make your changes</li> <li>Run the tests</li> <li>Try locally<ul> <li>Build, deploy and try Authorino in a local cluster</li> <li>Additional tools (for specific use-cases)</li> <li>Re-build and rollout latest</li> <li>Clean-up</li> </ul> </li> <li>Sign your commits</li> <li>Logging policy</li> <li>Additional resources</li> <li>Reach out</li> </ul>"},{"location":"authorino/contributing/#technology-stack-for-developers","title":"Technology stack for developers","text":"<p>Minimum requirements to contribute to Authorino are: - Golang v1.19+ - Docker</p> <p>Authorino's code was originally bundled using the Operator SDK (v1.9.0).</p> <p>The following tools can be installed as part of the development workflow:</p> <ul> <li>Installed with <code>go install</code> to the <code>$PROJECT_DIR/bin</code> directory:</li> <li>controller-gen: for building custom types and manifests</li> <li>Kustomize: for assembling flavoured manifests and installing/deploying</li> <li>setup-envtest: for running the tests \u2013 extra tools installed to <code>./testbin</code></li> <li>[benchstat]https://cs.opensource.google/go/x/perf): for human-friendly test benchmark reports</li> <li>mockgen: to generate mocks for tests \u2013 e.g. <code>./bin/mockgen -source=pkg/auth/auth.go -destination=pkg/auth/mocks/mock_auth.go</code></li> <li> <p>Kind: for deploying a containerized Kubernetes cluster for integration testing purposes</p> </li> <li> <p>Other recommended tools to have installed:</p> </li> <li>jq</li> <li>yq</li> <li>gnu-sed</li> </ul>"},{"location":"authorino/contributing/#workflow","title":"Workflow","text":""},{"location":"authorino/contributing/#check-the-issues","title":"Check the issues","text":"<p>Start by checking the list of issues in GitHub.</p> <p>In case you want to contribute with an idea for enhancement, a bug fix, or question, please make sure to describe the issue so we can start a conversation together and help you find the best way to get your contribution merged.</p>"},{"location":"authorino/contributing/#clone-the-repo-and-setup-the-local-environment","title":"Clone the repo and setup the local environment","text":"<p>Fork/clone the repo:</p> <pre><code>git clone git@github.com:kuadrant/authorino.git &amp;&amp; cd authorino\n</code></pre> <p>Download the Golang dependencies: <pre><code>make vendor\n</code></pre></p> <p>For additional automation provided, check:</p> <pre><code>make help\n</code></pre>"},{"location":"authorino/contributing/#make-your-changes","title":"Make your changes","text":"<p>Good changes... - follow the Golang conventions - have proper test coverage - address corresponding updates to the docs - help us fix wherever we failed to do the above \ud83d\ude1c</p>"},{"location":"authorino/contributing/#run-the-tests","title":"Run the tests","text":"<p>To run the tests:</p> <pre><code>make test\n</code></pre>"},{"location":"authorino/contributing/#try-locally","title":"Try locally","text":""},{"location":"authorino/contributing/#build-deploy-and-try-authorino-in-a-local-cluster","title":"Build, deploy and try Authorino in a local cluster","text":"<p>The following command will: - Start a local Kubernetes cluster (using Kind) - Install the Authorino Operator and Authorino CRDs - Build an image of Authorino based on the current branch - Push the freshly built image to the cluster's registry - Install cert-manager in the cluster - Generate TLS certificates for the Authorino service - Deploy an instance of Authorino - Deploy the example application Talker API, a simple HTTP API that echoes back whatever it gets in the request - Setup Envoy for proxying to the Talker API and using Authorino for external authorization</p> <pre><code>make local-setup\n</code></pre> <p>You will be prompted to edit the <code>Authorino</code> custom resource.</p> <p>The main workload composed of Authorino instance and user apps (Envoy, Talker API) will be deployed to the <code>default</code> Kubernetes namespace.</p> <p>Once the deployment is ready, you can forward the requests on port 8000 to the Envoy service</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre> Pro tips    1. Change the default workload namespace by supplying the `NAMESPACE` argument to your `make local-setup` and other deployment, apps and local cluster related targets. If the namespace does not exist, it will be created.   2. Switch to TLS disabled by default when deploying locally by supplying `TLS_ENABLED=0` to your `make local-setup` and `make deploy` commands. E.g. `make local-setup TLS_ENABLED=0`.   3. Skip being prompted to edit the `Authorino` CR and default to an Authorino deployment with TLS enabled, debug/development log level/mode, and standard name 'authorino', by supplying `FF=1` to your `make local-setup` and `make deploy` commands. E.g. `make local-setup FF=1`   4. Supply `DEPLOY_IDPS=1` to `make local-setup` and `make user-apps` to deploy Keycloak and Dex to the cluster. `DEPLOY_KEYCLOAK` and `DEPLOY_DEX` are also available. Read more about additional tools for specific use cases in the section below.   5. Saving the ID of the process (PID) of the port-forward command spawned in the background can be useful to later kill and restart the process. E.g. `kubectl port-forward deployment/envoy 8000:8000 &amp;;PID=$!`; then `kill $PID`."},{"location":"authorino/contributing/#additional-tools-for-specific-use-cases","title":"Additional tools (for specific use-cases)","text":"Limitador    To deploy [Limitador](https://github.com/kuadrant/limitador) \u2013 pre-configured in Envoy for rate-limiting the Talker API to 5 hits per minute per `user_id` when available in the cluster workload \u2013, run:    <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre> Keycloak    Authorino examples include a bundle of [Keycloak](https://www.keycloak.org) preloaded with the following realm setup:   - Admin console: http://localhost:8080/auth/admin (admin/p)   - Preloaded realm: **kuadrant**   - Preloaded clients:     - **demo**: to which API consumers delegate access and therefore the one which access tokens are issued to     - **authorino**: used by Authorino to fetch additional user info with `client_credentials` grant type     - **talker-api**: used by Authorino to fetch UMA-protected resource data associated with the Talker API   - Preloaded resources:     - `/hello`     - `/greetings/1` (owned by user jonh)     - `/greetings/2` (owned by user jane)     - `/goodbye`   - Realm roles:     - member (default to all users)     - admin   - Preloaded users:     - john/p (member)     - jane/p (admin)     - peter/p (member, email not verified)    To deploy, run:    <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre>    Forward local requests to the instance of Keycloak running in the cluster:    <pre><code>kubectl port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre> Dex    Authorino examples include a bundle of [Dex](https://dexidp.io) preloaded with the following setup:   - Preloaded clients:     - **demo**: to which API consumers delegate access and therefore the one which access tokens are issued to (Client secret: aaf88e0e-d41d-4325-a068-57c4b0d61d8e)   - Preloaded users:     - marta@localhost/password    To deploy, run:    <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/dex/dex-deploy.yaml\n</code></pre>    Forward local requests to the instance of Dex running in the cluster:    <pre><code>kubectl port-forward deployment/dex 5556:5556 &amp;\n</code></pre> a12n-server    Authorino examples include a bundle of [**a12n-server**](https://github.com/curveball/a12n-server) and corresponding MySQL database, preloaded with the following setup:   - Admin console: http://a12n-server:8531 (admin/123456)   - Preloaded clients:     - **service-account-1**: to obtain access tokens via `client_credentials` OAuth2 grant type, to consume the Talker API (Client secret: DbgXROi3uhWYCxNUq_U1ZXjGfLHOIM8X3C2bJLpeEdE); includes metadata privilege: `{ \"talker-api\": [\"read\"] }` that can be used to write authorization policies     - **talker-api**: to authenticate to the token introspect endpoint (Client secret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g)    To deploy, run:    <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre>    Forward local requests to the instance of a12n-server running in the cluster:    <pre><code>kubectl port-forward deployment/a12n-server 8531:8531 &amp;\n</code></pre>"},{"location":"authorino/contributing/#re-build-and-rollout-latest","title":"Re-build and rollout latest","text":"<p>Re-build and rollout latest Authorino image:</p> <pre><code>make local-rollout\n</code></pre> <p>If you made changes to the CRD between iterations, re-install by running:</p> <pre><code>make install\n</code></pre>"},{"location":"authorino/contributing/#clean-up","title":"Clean-up","text":"<p>The following command deletes the entire Kubernetes cluster started with Kind:</p> <pre><code>make local-cleanup\n</code></pre>"},{"location":"authorino/contributing/#sign-your-commits","title":"Sign your commits","text":"<p>All commits to be accepted to Authorino's code are required to be signed. Refer to this page about signing your commits.</p>"},{"location":"authorino/contributing/#logging-policy","title":"Logging policy","text":"<p>A few guidelines for adding logging messages in your code: 1. Make sure you understand Authorino's Logging architecture and policy regarding log levels, log modes, tracing IDs, etc. 2. Respect controller-runtime's Logging Guidelines. 3. Do not add sensitive data to your <code>info</code> log messages; instead, redact all sensitive data in your log messages or use <code>debug</code> log level by mutating the logger with <code>V(1)</code> before outputting the message.</p>"},{"location":"authorino/contributing/#additional-resources","title":"Additional resources","text":"<p>Here in the repo:</p> <ul> <li>Getting started</li> <li>Terminology</li> <li>Architecture</li> <li>Feature description</li> </ul> <p>Other repos:</p> <ul> <li>Authorino Operator</li> <li>Authorino examples</li> </ul>"},{"location":"authorino/contributing/#reach-out","title":"Reach out","text":"<p>kuadrant.slack.com</p>"},{"location":"authorino/features/","title":"Features","text":"<ul> <li>Overview</li> <li>Common feature: JSON paths (<code>valueFrom.authJSON</code>)</li> <li>Syntax</li> <li>String modifiers</li> <li>Interpolation</li> <li>Identity verification &amp; authentication features (<code>identity</code>)</li> <li>API key (<code>identity.apiKey</code>)</li> <li>Kubernetes TokenReview (<code>identity.kubernetes</code>)</li> <li>OpenID Connect (OIDC) JWT/JOSE verification and validation (<code>identity.oidc</code>)</li> <li>OAuth 2.0 introspection (<code>identity.oauth2</code>)</li> <li>OpenShift OAuth (user-echo endpoint) (<code>identity.openshift</code>)</li> <li>Mutual Transport Layer Security (mTLS) authentication (<code>identity.mtls</code>)</li> <li>Hash Message Authentication Code (HMAC) authentication (<code>identity.hmac</code>)</li> <li>Plain (<code>identity.plain</code>)</li> <li>Anonymous access (<code>identity.anonymous</code>)</li> <li>Festival Wristband authentication</li> <li>Extra: Auth credentials (<code>credentials</code>)</li> <li>Extra: Identity extension (<code>extendedProperties</code>)</li> <li>External auth metadata features (<code>metadata</code>)</li> <li>HTTP GET/GET-by-POST (<code>metadata.http</code>)</li> <li>OIDC UserInfo (<code>metadata.userInfo</code>)</li> <li>User-Managed Access (UMA) resource registry (<code>metadata.uma</code>)</li> <li>Authorization features (<code>authorization</code>)</li> <li>JSON pattern-matching authorization rules (<code>authorization.json</code>)</li> <li>Open Policy Agent (OPA) Rego policies (<code>authorization.opa</code>)</li> <li>Kubernetes SubjectAccessReview (<code>authorization.kubernetes</code>)</li> <li>Authzed/SpiceDB (<code>authorization.authzed</code>)</li> <li>Keycloak Authorization Services (UMA-compliant Authorization API)</li> <li>Dynamic response features (<code>response</code>)</li> <li>JSON injection (<code>response.json</code>)</li> <li>Plain (<code>response.plain</code>)</li> <li>Festival Wristband tokens (<code>response.wristband</code>)</li> <li>Extra: Response wrappers (<code>wrapper</code> and <code>wrapperKey</code>)<ul> <li>Added HTTP headers</li> <li>Envoy Dynamic Metadata</li> </ul> </li> <li>Extra: Custom denial status (<code>denyWith</code>)</li> <li>Callbacks (<code>callbacks</code>)</li> <li>HTTP endpoints (<code>callbacks.http</code>)</li> <li>Common feature: Priorities</li> <li>Common feature: Conditions (<code>when</code>)</li> <li>Common feature: Caching (<code>cache</code>)</li> <li>Common feature: Metrics (<code>metrics</code>)</li> </ul>"},{"location":"authorino/features/#overview","title":"Overview","text":"<p>We call features of Authorino the different things one can do to enforce identity verification &amp; authentication and authorization on requests against protected services. These can be a specific identity verification method based on a supported authentication protocol, or a method to fetch additional auth metadata in request-time, etc.</p> <p>Most features of Authorino relate to the different phases of the Auth Pipeline and therefore are configured in the Authorino <code>AuthConfig</code>. An identity verification feature usually refers to a functionality of Authorino such as the API key-based authentication implemented by Authorino, the validation of JWTs/OIDC ID tokens, and authentication based on Kubernetes TokenReviews. Analogously, OPA, JSON pattern-matching and Kuberentes SubjectAccessReview are examples of authorization features of Authorino.</p> <p>At a deeper level, a feature can also be an additional funcionality within a bigger feature, usually applicable to the whole class the bigger feature belongs to. For instance, the configuration of the location and key selector of auth credentials, available for all identity verification-related features. Other examples would be Identity extension and Response wrappers.</p> <p>A full specification of all features of Authorino that can be configured in an <code>AuthConfig</code> can be found in the official spec of the custom resource definition.</p> <p>You can also learn about Authorino features by using the <code>kubectl explain</code> command in a Kubernetes cluster where the Authorino CRD has been installed. E.g. <code>kubectl explain authconfigs.spec.identity.extendedProperties</code>.</p>"},{"location":"authorino/features/#common-feature-json-paths-valuefromauthjson","title":"Common feature: JSON paths (<code>valueFrom.authJSON</code>)","text":"<p>The first feature of Authorino to learn about is a common functionality, used in the specification of many other features. JSON paths have to do with reading data from the Authorization JSON, to refer to them in configuration of dynamic steps of API protection enforcing.</p> <p>Usage examples of JSON paths are: dynamic URL and request parameters when fetching metadata from external sources, dynamic authorization policy rules, and dynamic authorization responses (injected JSON and Festival Wristband token claims).</p>"},{"location":"authorino/features/#syntax","title":"Syntax","text":"<p>The syntax to fetch data from the Authorization JSON with JSON paths is based on GJSON. Refer to GJSON Path Syntax page for more information.</p>"},{"location":"authorino/features/#string-modifiers","title":"String modifiers","text":"<p>On top of GJSON, Authorino defines a few string modifiers.</p> <p>Examples below provided for the following Authorization JSON:</p> <pre><code>{\n  \"context\": {\n    \"request\": {\n      \"http\": {\n        \"path\": \"/pets/123\",\n        \"headers\": {\n          \"authorization\": \"Basic amFuZTpzZWNyZXQK\" // jane:secret\n          \"baggage\": \"eyJrZXkxIjoidmFsdWUxIn0=\" // {\"key1\":\"value1\"}\n        }\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      \"username\": \"jane\",\n      \"fullname\": \"Jane Smith\",\n      \"email\": \"\\u0006jane\\u0012@petcorp.com\\n\"\n    },\n  },\n}\n</code></pre> <p><code>@strip</code> Strips out any non printable characters such as carrige return. E.g. <code>auth.identity.email.@strip</code> \u2192 <code>\"jane@petcorp.com\"</code>.</p> <p><code>@case:upper|lower</code> Changes the case of a string. E.g. <code>auth.identity.username.@case:upper</code> \u2192 <code>\"JANE\"</code>.</p> <p><code>@replace:{\"old\":string,\"new\":string}</code> Replaces a substring within a string. E.g. <code>auth.identity.username.@replace:{\"old\":\"Smith\",\"new\":\"Doe\"}</code> \u2192 <code>\"Jane Doe\"</code>.</p> <p><code>@extract:{\"sep\":string,\"pos\":int}</code> Splits a string at occurrences of a separator (default: <code>\" \"</code>) and selects the substring at the <code>pos</code>-th position (default: <code>0</code>). E.g. <code>context.request.path.@extract:{\"sep\":\"/\",\"pos\":2}</code> \u2192 <code>123</code>.</p> <p><code>@base64:encode|decode</code> base64-encodes or decodes a string value. E.g. <code>auth.identity.username.decoded.@base64:encode</code> \u2192 <code>\"amFuZQo=\"</code>.</p> <p>In combination with <code>@extract</code>, <code>@base64</code> can be used to extract the username in an HTTP Basic Authentication request. E.g. <code>context.request.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\",\"pos\":1}</code> \u2192 <code>\"jane\"</code>.</p>"},{"location":"authorino/features/#interpolation","title":"Interpolation","text":"<p>JSON paths can be interpolated into strings to build template-like dynamic values. E.g. <code>\"Hello, {auth.identity.name}!\"</code>.</p>"},{"location":"authorino/features/#identity-verification-authentication-features-identity","title":"Identity verification &amp; authentication features (<code>identity</code>)","text":""},{"location":"authorino/features/#api-key-identityapikey","title":"API key (<code>identity.apiKey</code>)","text":"<p>Authorino relies on Kubernetes <code>Secret</code> resources to represent API keys.</p> <p>To define an API key, create a <code>Secret</code> in the cluster containing an <code>api_key</code> entry that holds the value of the API key.</p> <p>API key secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.identity.apiKey.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>API key secrets must be labeled with the labels that match the selectors specified in <code>spec.identity.apiKey.selector</code> in the <code>AuthConfig</code>.</p> <p>Whenever an <code>AuthConfig</code> is indexed, Authorino will also index all matching API key secrets. In order for Authorino to also watch events related to API key secrets individually (e.g. new <code>Secret</code> created, updates, deletion/revocation), <code>Secret</code>s must also include a label that matches Authorino's bootstrap configuration <code>--secret-label-selector</code> (default: <code>authorino.kuadrant.io/managed-by=authorino</code>). This label may or may not be present to <code>spec.identity.apiKey.selector</code> in the <code>AuthConfig</code> without implications for the caching of the API keys when triggered by the reconciliation of the <code>AuthConfig</code>; however, if not present, individual changes related to the API key secret (i.e. without touching the <code>AuthConfig</code>) will be ignored by the reconciler.</p> <p>Example. For the following <code>AuthConfig</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: my-api-protection\nnamespace: authorino-system\nspec:\nhosts:\n- my-api.io\nidentity:\n- name: api-key-users\napiKey:\nselector:\nmatchLabels: # the key-value set used to select the matching `Secret`s; resources including these labels will be acepted as valid API keys to authenticate to this service\ngroup: friends # some custom label\nallNamespaces: true # only works with cluster-wide Authorino instances; otherwise, create the API key secrets in the same namespace of the AuthConfig\n</code></pre> <p>The following Kubernetes <code>Secret</code> represents a valid API key:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: user-1-api-key-1\nnamespace: default\nlabels:\nauthorino.kuadrant.io/managed-by: authorino # so the Authorino controller reconciles events related to this secret\ngroup: friends\nstringData:\napi_key: &lt;some-randomly-generated-api-key-value&gt;\ntype: Opaque\n</code></pre> <p>The resolved identity object, added to the authorization JSON following an API key identity source evaluation, is the Kubernetes <code>Secret</code> resource (as JSON).</p>"},{"location":"authorino/features/#kubernetes-tokenreview-identitykubernetes","title":"Kubernetes TokenReview (<code>identity.kubernetes</code>)","text":"<p>Authorino can verify Kubernetes-valid access tokens (using Kubernetes TokenReview API).</p> <p>These tokens can be either <code>ServiceAccount</code> tokens such as the ones issued by kubelet as part of Kubernetes Service Account Token Volume Projection, or any valid user access tokens issued to users of the Kubernetes server API.</p> <p>The list of <code>audiences</code> of the token must include the requested host and port of the protected API (default), or all audiences specified in the Authorino <code>AuthConfig</code> custom resource. For example:</p> <p>For the following <code>AuthConfig</code> CR, the Kubernetes token must include the audience <code>my-api.io</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: my-api-protection\nspec:\nhosts:\n- my-api.io\nidentity:\n- name: cluster-users\nkubernetes: {}\n</code></pre> <p>Whereas for the following <code>AuthConfig</code> CR, the Kubernetes token audiences must include foo and bar:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: my-api-protection\nspec:\nhosts:\n- my-api.io\nidentity:\n- name: cluster-users\nkubernetes:\naudiences:\n- foo\n- bar\n</code></pre> <p>The resolved identity object added to the authorization JSON following a successful Kubernetes authentication identity evaluation is the <code>status</code> field of TokenReview response (see TokenReviewStatus for reference).</p>"},{"location":"authorino/features/#openid-connect-oidc-jwtjose-verification-and-validation-identityoidc","title":"OpenID Connect (OIDC) JWT/JOSE verification and validation (<code>identity.oidc</code>)","text":"<p>In reconciliation-time, using OpenID Connect Discovery well-known endpoint, Authorino automatically discovers and caches OpenID Connect configurations and associated JSON Web Key Sets (JWKS) for all OpenID Connect issuers declared in an <code>AuthConfig</code>. Then, in request-time, Authorino verifies the JSON Web Signature (JWS) and check the time validity of signed JSON Web Tokens (JWT) supplied on each request.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p></p> <p>The <code>kid</code> claim stated in the JWT header must match one of the keys cached by Authorino during OpenID Connect Discovery, therefore supporting JWK rotation.</p> <p>The decoded payload of the validated JWT is appended to the authorization JSON as the resolved identity.</p> <p>OpenID Connect configurations and linked JSON Web Ket Sets can be configured to be automatically refreshed (pull again from the OpenID Connect Discovery well-known endpoints), by setting the <code>identity.oidc.ttl</code> field (given in seconds, default: <code>0</code> \u2013 i.e. auto-refresh disabled).</p> <p>For an excellent summary of the underlying concepts and standards that relate OpenID Connect and JSON Object Signing and Encryption (JOSE), see this article by Jan Rusnacko. For official specification and RFCs, see OpenID Connect Core, OpenID Connect Discovery, JSON Web Token (JWT) (RFC7519), and JSON Object Signing and Encryption (JOSE).</p>"},{"location":"authorino/features/#oauth-20-introspection-identityoauth2","title":"OAuth 2.0 introspection (<code>identity.oauth2</code>)","text":"<p>For bare OAuth 2.0 implementations, Authorino can perform token introspection on the access tokens supplied in the requests to protected APIs.</p> <p>Authorino does not implement any of OAuth 2.0 grants for the applications to obtain the token. However, it can verify supplied tokens with the OAuth server, including opaque tokens, as long as the server exposes the <code>token_introspect</code> endpoint (RFC 7662).</p> <p>Developers must set the token introspection endpoint in the <code>AuthConfig</code>, as well as a reference to the Kubernetes secret storing the credentials of the OAuth client to be used by Authorino when requesting the introspect.</p> <p></p> <p>The response returned by the OAuth2 server to the token introspection request is the the resolved identity appended to the authorization JSON.</p>"},{"location":"authorino/features/#openshift-oauth-user-echo-endpoint-identityopenshift","title":"OpenShift OAuth (user-echo endpoint) (<code>identity.openshift</code>)","text":"Not implemented - In analysis <p>Online token introspection of OpenShift-valid access tokens based on OpenShift's user-echo endpoint.</p>"},{"location":"authorino/features/#mutual-transport-layer-security-mtls-authentication-identitymtls","title":"Mutual Transport Layer Security (mTLS) authentication (<code>identity.mtls</code>)","text":"<p>Authorino can verify x509 certificates presented by clients for authentication on the request to the protected APIs, at application level.</p> <p>Trusted root Certificate Authorities (CA) are stored in Kubernetes Secrets labeled according to selectors specified in the AuthConfig, watched and indexed by Authorino. Make sure to create proper <code>kubernetes.io/tls</code>-typed Kubernetes Secrets, containing the public certificates of the CA stored in either a <code>tls.crt</code> or <code>ca.crt</code> entry inside the secret.</p> <p>Truested root CA secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.identity.mtls.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>The identitiy object resolved out of a client x509 certificate is equal to the subject field of the certificate, and it serializes as JSON within the Authorization JSON usually as follows:</p> <pre><code>{\n    \"auth\": {\n        \"identity\": {\n            \"CommonName\": \"aisha\",\n            \"Country\": [\"PK\"],\n            \"ExtraNames\": null,\n            \"Locality\": [\"Islamabad\"],\n            \"Names\": [\n                { \"Type\": [2, 5, 4, 3], \"Value\": \"aisha\" },\n                { \"Type\": [2, 5, 4, 6], \"Value\": \"PK\" },\n                { \"Type\": [2, 5, 4, 7], \"Value\": \"Islamabad\" },\n                { \"Type\": [2, 5, 4,10], \"Value\": \"ACME Inc.\" },\n                { \"Type\": [2, 5, 4,11], \"Value\": \"Engineering\" }\n            ],\n            \"Organization\": [\"ACME Inc.\"],\n            \"OrganizationalUnit\": [\"Engineering\"],\n            \"PostalCode\": null,\n            \"Province\": null,\n            \"SerialNumber\": \"\",\n            \"StreetAddress\": null\n        }\n  }\n}\n</code></pre>"},{"location":"authorino/features/#hash-message-authentication-code-hmac-authentication-identityhmac","title":"Hash Message Authentication Code (HMAC) authentication (<code>identity.hmac</code>)","text":"Not implemented - Planned (#9) <p>Authentication based on the validation of a hash code generated from the contextual information of the request to the protected API, concatenated with a secret known by the API consumer.</p>"},{"location":"authorino/features/#plain-identityplain","title":"Plain (<code>identity.plain</code>)","text":"<p>Authorino can read plain identity objects, based on authentication tokens provided and verified beforehand using other means (e.g. Envoy JWT Authentication filter, Kubernetes API server authentication), and injected into the payload to the external authorization service.</p> <p>The plain identity object is retrieved from the Authorization JSON based on a JSON path specified in the <code>AuthConfig</code>.</p> <p>This feature is particularly useful in cases where authentication/identity verification is handled before invoking the authorization service and its resolved value injected in the payload can be trusted. Examples of applications for this feature include: - Authentication handled in Envoy leveraging the Envoy JWT Authentication filter (decoded JWT injected as 'metadata_context') - Use of Authorino as Kubernetes ValidatingWebhook service (Kubernetes 'userInfo' injected in the body of the <code>AdmissionReview</code> request)</p> <p>Example of <code>AuthConfig</code> to retrieve plain identity object from the Authorization JSON.</p> <pre><code>spec:\nidentity:\n- name: plain\nplain:\nauthJSON: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\n</code></pre> <p>If the specified JSON path does not exist in the Authorization JSON or the value is <code>null</code>, the identity verification will fail and, unless other identity config succeeds, Authorino will halt the Auth Pipeline with the usual <code>401 Unauthorized</code>.</p>"},{"location":"authorino/features/#anonymous-access-identityanonymous","title":"Anonymous access (<code>identity.anonymous</code>)","text":"<p>Literally a no-op evaluator for the identity verification phase that returns a static identity object <code>{\"anonymous\":true}</code>.</p> <p>It allows to implement <code>AuthConfigs</code> that bypasses the identity verification phase of Authorino, to such as: - enable anonymous access to protected services (always or combined with Priorities) - postpone authentication in the Auth Pipeline to be resolved as part of an OPA policy</p> <p>Example of <code>AuthConfig</code> spec that falls back to anonymous access when OIDC authentication fails, enforcing read-only access to the protected service in such cases:</p> <pre><code>spec:\nidentity:\n- name: jwt\noidc: { endpoint: ... }\n- name: anonymous\npriority: 1 # expired oidc token, missing creds, etc default to anonymous access\nanonymous: {}\nauthorization:\n- name: read-only-access-if-authn-fails\nwhen:\n- selector: auth.identity.anonymous\noperator: eq\nvalue: \"true\"\njson:\nrules:\n- selector: context.request.http.method\noperator: eq\nvalue: GET\n</code></pre>"},{"location":"authorino/features/#festival-wristband-authentication","title":"Festival Wristband authentication","text":"<p>Authorino-issued Festival Wristband tokens can be validated as any other signed JWT using Authorino's OpenID Connect (OIDC) JWT/JOSE verification and validation.</p> <p>The value of the issuer must be the same issuer specified in the custom resource for the protected API originally issuing wristband. Eventually, this can be the same custom resource where the wristband is configured as a valid source of identity, but not necessarily.</p>"},{"location":"authorino/features/#extra-auth-credentials-credentials","title":"Extra: Auth credentials (<code>credentials</code>)","text":"<p>All the identity verification methods supported by Authorino can be configured regarding the location where access tokens and credentials (i.e. authentication secrets) fly within the request.</p> <p>By default, authentication secrets are expected to be supplied in the <code>Authorization</code> HTTP header, with the <code>Bearer</code> prefix and plain authentication secret, separated by space. The full list of supported options for the location of authentication secrets and selector is specified in the table below:</p> Location (<code>credentials.in</code>) Description Selector (<code>credentials.keySelector</code>) <code>authorization_header</code> <code>Authorization</code> HTTP header Prefix (default: <code>Bearer</code>) <code>custom_header</code> Custom HTTP header Name of the header. Value should have no prefix. <code>query</code> Query string parameter Name of the parameter <code>cookie</code> Cookie header ID of the cookie entry"},{"location":"authorino/features/#extra-identity-extension-extendedproperties","title":"Extra: Identity extension (<code>extendedProperties</code>)","text":"<p>Resolved identity objects can be extended with user-defined JSON properties. Values can be static or fetched from the Authorization JSON.</p> <p>A typical use-case for this feature is token normalization. Say you have more than one identity source listed in the your <code>AuthConfig</code> but each source issues an access token with a different JSON structure \u2013 e.g. two OIDC issuers that use different names for custom JWT claims of similar meaning; when two different identity verification/authentication methods are combined, such as API keys (whose identity objects are the corresponding Kubernetes <code>Secret</code>s) and Kubernetes tokens (whose identity objects are Kubernetes UserInfo data).</p> <p>In such cases, identity extension can be used to normalize the token so it always includes the same set of JSON properties of interest, regardless of the source of identity that issued the original token verified by Authorino. This simplifies the writing of authorization policies and configuration of dynamic responses.</p> <p>In case of extending an existing property of the identity object (replacing), the API allows to control whether to overwrite the value or not. This is particularly useful for normalizing tokens of a same identity source that nonetheless may occasionally differ in structure, such as in the case of JWT claims that sometimes may not be present but can be safely replaced with another (e.g. <code>username</code> or <code>sub</code>).</p>"},{"location":"authorino/features/#external-auth-metadata-features-metadata","title":"External auth metadata features (<code>metadata</code>)","text":""},{"location":"authorino/features/#http-getget-by-post-metadatahttp","title":"HTTP GET/GET-by-POST (<code>metadata.http</code>)","text":"<p>Generic HTTP adapter that sends a request to an external service. It can be used to fetch external metadata for the authorization policies (phase ii of the Authorino Auth Pipeline), or as a web hook.</p> <p>The adapter allows issuing requests either by GET or POST methods; in both cases with URL and parameters defined by the user in the spec. Dynamic values fetched from the Authorization JSON can be used.</p> <p>POST request parameters as well as the encoding of the content can be controlled using the <code>bodyParameters</code> and <code>contentType</code> fields of the config, respectively. The Content-Type of POST requests can be either <code>application/x-www-form-urlencoded</code> (default) or <code>application/json</code>.</p> <p>Authentication of Authorino with the external metadata server can be set either via long-lived shared secret stored in a Kubernetes Secret or via OAuth2 client credentials grant. For long-lived shared secret, set the <code>sharedSecretRef</code> field. For OAuth2 client credentials grant, use the <code>oauth2</code> option.</p> <p>In both cases, the location where the secret (long-lived or OAuth2 access token) travels in the request performed to the external HTTP service can be specified in the <code>credentials</code> field. By default, the authentication secret is supplied in the <code>Authorization</code> header with the <code>Bearer</code> prefix.</p> <p>Custom headers can be set with the <code>headers</code> field. Nevertheless, headers such as <code>Content-Type</code> and <code>Authorization</code> (or eventual custom header used for carrying the authentication secret, set instead via the <code>credentials</code> option) will be superseded by the respective values defined for the fields <code>contentType</code> and <code>sharedSecretRef</code>.</p>"},{"location":"authorino/features/#oidc-userinfo-metadatauserinfo","title":"OIDC UserInfo (<code>metadata.userInfo</code>)","text":"<p>Online fetching of OpenID Connect (OIDC) UserInfo data (phase ii of the Authorino Auth Pipeline), associated with an OIDC identity source configured and resolved in phase (i).</p> <p>Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline.</p> <p>Implementation requires an OpenID Connect issuer (<code>spec.identity.oidc</code>) configured in the same <code>AuthConfig</code>.</p> <p>The response returned by the OIDC server to the UserInfo request is appended (as JSON) to <code>auth.metadata</code> in the authorization JSON.</p>"},{"location":"authorino/features/#user-managed-access-uma-resource-registry-metadatauma","title":"User-Managed Access (UMA) resource registry (<code>metadata.uma</code>)","text":"<p>User-Managed Access (UMA) is an OAuth-based protocol for resource owners to allow other users to access their resources. Since the UMA-compliant server is expected to know about the resources, Authorino includes a client that fetches resource data from the server and adds that as metadata of the authorization payload.</p> <p>This enables the implementation of resource-level Attribute-Based Access Control (ABAC) policies. Attributes of the resource fetched in a UMA flow can be, e.g., the owner of the resource, or any business-level attributes stored in the UMA-compliant server.</p> <p>A UMA-compliant server is an external authorization server (e.g., Keycloak) where the protected resources are registered. It can be as well the upstream API itself, as long as it implements the UMA protocol, with initial authentication by <code>client_credentials</code> grant to exchange for a Protected API Token (PAT).</p> <p></p> <p>It's important to notice that Authorino does NOT manage resources in the UMA-compliant server. As shown in the flow above, Authorino's UMA client is only to fetch data about the requested resources. Authorino exchanges client credentials for a Protected API Token (PAT), then queries for resources whose URI match the path of the HTTP request (as passed to Authorino by the Envoy proxy) and fetches data of each macthing resource.</p> <p>The resources data is added as metadata of the authorization payload and passed as input for the configured authorization policies. All resources returned by the UMA-compliant server in the query by URI are passed along. They are available in the PDPs (authorization payload) as <code>input.auth.metadata.custom-name =&gt; Array</code>. (See The \"Auth Pipeline\" for details.)</p>"},{"location":"authorino/features/#authorization-features-authorization","title":"Authorization features (<code>authorization</code>)","text":""},{"location":"authorino/features/#json-pattern-matching-authorization-rules-authorizationjson","title":"JSON pattern-matching authorization rules (<code>authorization.json</code>)","text":"<p>Grant/deny access based on simple pattern-matching expressions (\"rules\") compared against values selected from the Authorization JSON.</p> <p>Each expression is a tuple composed of: - a <code>selector</code>, to fetch from the Authorization JSON \u2013 see Common feature: JSON paths for details about syntax; - an <code>operator</code> \u2013 <code>eq</code> (equals), <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for arrays; and <code>matches</code>, for regular expressions; - a fixed comparable <code>value</code></p> <p>Rules can mix and combine literal expressions and references to expression sets (\"named patterns\") defined at the upper level of the <code>AuthConfig</code> spec. (See Common feature: Conditions)</p> <pre><code>spec:\nauthorization:\n- name: my-simple-json-pattern-matching-policy\njson:\nrules: # All rules must match for access to be granted\n- selector: auth.identity.email_verified\noperator: eq\nvalue: \"true\"\n- patternRef: admin\npattterns:\nadmin: # a named pattern that can be reused in other sets of rules or conditions\n- selector: auth.identity.roles\noperator: incl\nvalue: admin\n</code></pre>"},{"location":"authorino/features/#open-policy-agent-opa-rego-policies-authorizationopa","title":"Open Policy Agent (OPA) Rego policies (<code>authorization.opa</code>)","text":"<p>You can model authorization policies in Rego language and add them as part of the protection of your APIs.</p> <p>Policies can be either declared in-line in Rego language (<code>inlineRego</code>) or as an HTTP endpoint where Authorino will fetch the source code of the policy in reconciliation-time (<code>externalRegistry</code>).</p> <p>Policies pulled from external registries can be configured to be automatically refreshed (pulled again from the external registry), by setting the <code>authorization.opa.externalRegistry.ttl</code> field (given in seconds, default: <code>0</code> \u2013 i.e. auto-refresh disabled).</p> <p>Authorino's built-in OPA module precompiles the policies during reconciliation of the AuthConfig and caches the precompiled policies for fast evaluation in runtime, where they receive the Authorization JSON as input.</p> <p></p> <p>An optional field <code>allValues: boolean</code> makes the values of all rules declared in the Rego document to be returned in the OPA output after policy evaluation. When disabled (default), only the boolean value <code>allow</code> is returned. Values of internal rules of the Rego document can be referenced in subsequent policies/phases of the Auth Pipeline.</p>"},{"location":"authorino/features/#kubernetes-subjectaccessreview-authorizationkubernetes","title":"Kubernetes SubjectAccessReview (<code>authorization.kubernetes</code>)","text":"<p>Access control enforcement based on rules defined in the Kubernetes authorization system, i.e. <code>Role</code>, <code>ClusterRole</code>, <code>RoleBinding</code> and <code>ClusterRoleBinding</code> resources of Kubernetes RBAC.</p> <p>Authorino issues a SubjectAccessReview (SAR) inquiry that checks with the underlying Kubernetes server whether the user can access a particular resource, resurce kind or generic URL.</p> <p>It supports resource attributes authorization check (parameters defined in the <code>AuthConfig</code>) and non-resource attributes authorization check (HTTP endpoint inferred from the original request). - Resource attributes: adequate for permissions set at namespace level, defined in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb) - Non-resource attributes: adequate for permissions set at cluster scope, defined for protected endpoints of a generic HTTP API (URL path + verb)</p> <p>Example of Kubernetes role for resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: pet-reader\nrules:\n- apiGroups: [\"pets.io\"]\nresources: [\"pets\"]\nverbs: [\"get\"]\n</code></pre> <p>Example of Kubernetes cluster role for non-resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: pet-editor\nrules:\n- nonResourceURLs: [\"/pets/*\"]\nverbs: [\"put\", \"delete\"]\n</code></pre> <p>Kubernetes authorization policy configs look like the following in an Authorino <code>AuthConfig</code>:</p> <pre><code>authorization:\n- name: kubernetes-rbac\nkubernetes:\nuser:\nvalueFrom: # values of the parameter can be fixed (`value`) or fetched from the Auhtorization JSON (`valueFrom.authJSON`)\nauthJSON: auth.identity.metadata.annotations.userid\ngroups: [] # user groups to test for.\n# for resource attributes permission checks; omit it to perform a non-resource attributes SubjectAccessReview with path and method/verb assumed from the original request\n# if included, use the resource attributes, where the values for each parameter can be fixed (`value`) or fetched from the Auhtorization JSON (`valueFrom.authJSON`)\nresourceAttributes:\nnamespace:\nvalue: default\ngroup:\nvalue: pets.io # the api group of the protected resource to be checked for permissions for the user\nresource:\nvalue: pets # the resource kind\nname:\nvalueFrom: { authJSON: context.request.http.path.@extract:{\"sep\":\"/\",\"pos\":2} } # resource name \u2013 e.g., the {id} in `/pets/{id}`\nverb:\nvalueFrom: { authJSON: context.request.http.method.@case:lower } # api operation \u2013 e.g., copying from the context to use the same http method of the request\n</code></pre> <p><code>user</code> and properties of <code>resourceAttributes</code> can be defined from fixed values or patterns of the Authorization JSON.</p> <p>An array of <code>groups</code> (optional) can as well be set. When defined, it will be used in the <code>SubjectAccessReview</code> request.</p>"},{"location":"authorino/features/#authzedspicedb-authorizationauthzed","title":"Authzed/SpiceDB (<code>authorization.authzed</code>)","text":"<p>Check permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> <p>Subject, resource and permission parameters can be set to static values or read from the Authorization JSON.</p> <pre><code>spec:\nauthorization:\n- name: authzed\nauthzed:\nendpoint: spicedb:50051\ninsecure: true # disables TLS\nsharedSecretRef:\nname: spicedb\nkey: token\nsubject:\nkind:\nvalue: blog/user\nname:\nvalueFrom:\nauthJSON: auth.identity.sub\nresource:\nkind:\nvalue: blog/post\nname:\nvalueFrom:\nauthJSON: context.request.http.path.@extract:{\"sep\":\"/\",\"pos\":2} # /posts/{id}\npermission:\nvalueFrom:\nauthJSON: context.request.http.method\n</code></pre>"},{"location":"authorino/features/#keycloak-authorization-services-uma-compliant-authorization-api","title":"Keycloak Authorization Services (UMA-compliant Authorization API)","text":"Not implemented - In analysis <p>Online delegation of authorization to a Keycloak server.</p>"},{"location":"authorino/features/#dynamic-response-features-response","title":"Dynamic response features (<code>response</code>)","text":""},{"location":"authorino/features/#json-injection-responsejson","title":"JSON injection (<code>response.json</code>)","text":"<p>User-defined dynamic JSON objects generated by Authorino in the response phase, from static or dynamic data of the auth pipeline, and passed back to the external authorization client within added HTTP headers or as Envoy Well Known Dynamic Metadata.</p> <p>The following Authorino <code>AuthConfig</code> custom resource is an example that defines 3 dynamic JSON response items, where two items are returned to the client, stringified, in added HTTP headers, and the third is wrapped as Envoy Dynamic Metadata(\"emitted\", in Envoy terminology). Envoy proxy can be configured to \"pipe\" dynamic metadata emitted by one filter into another filter \u2013 for example, from external authorization to rate limit.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nnamespace: my-namespace\nname: my-api-protection\nspec:\nhosts:\n- my-api.io\nidentity:\n- name: edge\napiKey:\nselector:\nmatchLabels:\nauthorino.kuadrant.io/managed-by: authorino\ncredentials:\nin: authorization_header\nkeySelector: APIKEY\nresponse:\n- name: a-json-returned-in-a-header\nwrapper: httpHeader # can be omitted\nwrapperKey: x-my-custom-header # if omitted, name of the header defaults to the name of the config (\"a-json-returned-in-a-header\")\njson:\nproperties:\n- name: prop1\nvalue: value1\n- name: prop2\nvalueFrom:\nauthJSON: some.path.within.auth.json\n- name: another-json-returned-in-a-header\nwrapperKey: x-ext-auth-other-json\njson:\nproperties:\n- name: propX\nvalue: valueX\n- name: a-json-returned-as-envoy-metadata\nwrapper: envoyDynamicMetadata\nwrapperKey: auth-data\njson:\nproperties:\n- name: api-key-ns\nvalueFrom:\nauthJSON: auth.identity.metadata.namespace\n- name: api-key-name\nvalueFrom:\nauthJSON: auth.identity.metadata.name\n</code></pre>"},{"location":"authorino/features/#plain-responseplain","title":"Plain (<code>response.plain</code>)","text":"<p>Simpler, yet more generalized form, for extending the authorization response for header mutation and Envoy Dynamic Metadata, based on plain text values.</p> <p>The value can be static:</p> <pre><code>response:\n- name: x-auth-service\nplain:\nvalue: Authorino\n</code></pre> <p>or fetched dynamically from the Authorization JSON (which includes support for interpolation):</p> <pre><code>- name: x-username\nplain:\nvalueFrom:\nauthJSON: auth.identity.username\n</code></pre>"},{"location":"authorino/features/#festival-wristband-tokens-responsewristband","title":"Festival Wristband tokens (<code>response.wristband</code>)","text":"<p>Festival Wristbands are signed OpenID Connect JSON Web Tokens (JWTs) issued by Authorino at the end of the auth pipeline and passed back to the client, typically in added HTTP response header. It is an opt-in feature that can be used to implement Edge Authentication Architecture (EAA) and enable token normalization. Authorino wristbands include minimal standard JWT claims such as <code>iss</code>, <code>iat</code>, and <code>exp</code>, and optional user-defined custom claims, whose values can be static or dynamically fetched from the authorization JSON.</p> <p>The Authorino <code>AuthConfig</code> custom resource below sets an API protection that issues a wristband after a successful authentication via API key. Apart from standard JWT claims, the wristband contains 2 custom claims: a static value <code>aud=internal</code> and a dynamic value <code>born</code> that fetches from the authorization JSON the date/time of creation of the secret that represents the API key used to authenticate.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nnamespace: my-namespace\nname: my-api-protection\nspec:\nhosts:\n- my-api.io\nidentity:\n- name: edge\napiKey:\nselector:\nmatchLabels:\nauthorino.kuadrant.io/managed-by: authorino\ncredentials:\nin: authorization_header\nkeySelector: APIKEY\nresponse:\n- name: my-wristband\nwristband:\nissuer: https://authorino-oidc.default.svc:8083/my-namespace/my-api-protection/my-wristband\ncustomClaims:\n- name: aud\nvalue: internal\n- name: born\nvalueFrom:\nauthJSON: auth.identity.metadata.creationTimestamp\ntokenDuration: 300\nsigningKeyRefs:\n- name: my-signing-key\nalgorithm: ES256\n- name: my-old-signing-key\nalgorithm: RS256\nwrapper: httpHeader # can be omitted\nwrapperKey: x-ext-auth-wristband # whatever http header name desired - defaults to the name of  the response config (\"my-wristband\")\n</code></pre> <p>The signing key names listed in <code>signingKeyRefs</code> must match the names of Kubernetes <code>Secret</code> resources created in the same namespace, where each secret contains a <code>key.pem</code> entry that holds the value of the private key that will be used to sign the wristbands issued, formatted as PEM. The first key in this list will be used to sign the wristbands, while the others are kept to support key rotation.</p> <p>For each protected API configured for the Festival Wristband issuing, Authorino exposes the following OpenID Connect Discovery well-known endpoints (available for requests within the cluster): - OpenID Connect configuration:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-configuration - JSON Web Key Set (JWKS) well-known endpoint:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-connect/certs</p>"},{"location":"authorino/features/#extra-response-wrappers-wrapper-and-wrapperkey","title":"Extra: Response wrappers (<code>wrapper</code> and <code>wrapperKey</code>)","text":""},{"location":"authorino/features/#added-http-headers","title":"Added HTTP headers","text":"<p>By default, Authorino dynamic responses (injected JSON and Festival Wristband tokens) are passed back to Envoy, stringified, as injected HTTP headers. This can be made explicit by setting the <code>wrapper</code> property of the response config to <code>httpHeader</code>.</p> <p>The property <code>wrapperKey</code> controls the name of the HTTP header, with default to the name of dynamic response config when omitted.</p>"},{"location":"authorino/features/#envoy-dynamic-metadata","title":"Envoy Dynamic Metadata","text":"<p>Authorino dynamic responses (injected JSON and Festival Wristband tokens) can be passed back to Envoy in the form of Envoy Dynamic Metadata. To do so, set the <code>wrapper</code> property of the response config to <code>envoyDynamicMetadata</code>.</p> <p>A response config with <code>wrapper=envoyDynamicMetadata</code> and <code>wrapperKey=auth-data</code> in the <code>AuthConfig</code> can be configured in the Envoy route or virtual host setting to be passed to rate limiting filter as below. The metadata content is expected to be a dynamic JSON injected by Authorino containing <code>{ \"auth-data\": { \"api-key-ns\": string, \"api-key-name\": string } }</code>. (See the response config <code>a-json-returned-as-envoy-metadata</code> in the example for the JSON injection feature above)</p> <pre><code># Envoy config snippet to inject `user_namespace` and `username` rate limit descriptors from metadata returned by Authorino\nrate_limits:\n- actions:\n- metadata:\nmetadata_key:\nkey: \"envoy.filters.http.ext_authz\"\npath:\n- key: auth-data\n- key: api-key-ns\ndescriptor_key: user_namespace\n- metadata:\nmetadata_key:\nkey: \"envoy.filters.http.ext_authz\"\npath:\n- key: auth-data\n- key: api-key-name\ndescriptor_key: username\n</code></pre>"},{"location":"authorino/features/#extra-custom-denial-status-denywith","title":"Extra: Custom denial status (<code>denyWith</code>)","text":"<p>By default, Authorino will inform Envoy to respond with <code>401 Unauthorized</code> or <code>403 Forbidden</code> respectively when the identity verification (phase i of the Auth Pipeline) or authorization (phase ii) fail. These can be customized by specifying <code>spec.denyWith</code> in the <code>AuthConfig</code>.</p>"},{"location":"authorino/features/#callbacks-callbacks","title":"Callbacks (<code>callbacks</code>)","text":""},{"location":"authorino/features/#http-endpoints-callbackshttp","title":"HTTP endpoints (<code>callbacks.http</code>)","text":"<p>Sends requests to specified HTTP endpoints at the end of the auth pipeline.</p> <p>The scheme of the <code>http</code> field is the same as of <code>metadata.http</code>.</p> <p>Example:</p> <pre><code>spec:\nidentity: [\u2026]\nauthorization: [\u2026]\ncallbacks:\n- name: log\nhttp:\nendpoint: http://logsys\nmethod: POST\nbody:\nvalueFrom:\nauthJSON: |\n\\{\"requestId\":context.request.http.id,\"username\":\"{auth.identity.username}\",\"authorizationResult\":{auth.authorization}\\}\n- name: important-forbidden\nwhen:\n- selector: auth.authorization.important-policy\noperator: eq\nvalue: \"false\"\nhttp:\nendpoint: \"http://monitoring/important?forbidden-user={auth.identity.username}\"\n</code></pre>"},{"location":"authorino/features/#common-feature-priorities","title":"Common feature: Priorities","text":"<p>Priorities allow to set sequence of execution for blocks of concurrent evaluators within phases of the Auth Pipeline.</p> <p>Evaluators of same priority execute concurrently to each other \"in a block\". After syncing that block (i.e. after all evaluators of the block have returned), the next block of evaluator configs of consecutive priority is triggered.</p> <p>Use cases for priorities are: 1. Saving expensive tasks to be triggered when there's a high chance of returning immediately after finishing executing a less expensive one \u2013 e.g.     - an identity config that calls an external IdP to verify a token that is rarely used, compared to verifying JWTs preferred by most users of the service;     - an authorization policy that performs some quick checks first, such as verifying allowed paths, and only if it passes, moves to the evaluation of a more expensive policy. 2. Establishing dependencies between evaluators - e.g.     - an external metadata request that needs to wait until a previous metadata responds first (in order to use data from the response)</p> <p>Priorities can be set using the <code>priority</code> property available in all evaluator configs of all phases of the Auth Pipeline (identity, metadata, authorization and response). The lower the number, the highest the priority. By default, all evaluators have priority 0 (i.e. highest priority).</p> <p>Consider the following example to understand how priorities work:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: talker-api-protection\nspec:\nhosts:\n- talker-api\nidentity:\n- name: tier-1\npriority: 0\napiKey:\nselector:\nmatchLabels:\ntier: \"1\"\n- name: tier-2\npriority: 1\napiKey:\nselector:\nmatchLabels:\ntier: \"2\"\n- name: tier-3\npriority: 1\napiKey:\nselector:\nmatchLabels:\ntier: \"3\"\nmetadata:\n- name: first\nhttp:\nendpoint: http://talker-api:3000\nmethod: GET\n- name: second\npriority: 1\nhttp:\nendpoint: http://talker-api:3000/first_uuid={auth.metadata.first.uuid}\nmethod: GET\nauthorization:\n- name: allowed-endpoints\nwhen:\n- selector: context.request.http.path\noperator: neq\nvalue: /hi\n- selector: context.request.http.path\noperator: neq\nvalue: /hello\n- selector: context.request.http.path\noperator: neq\nvalue: /aloha\n- selector: context.request.http.path\noperator: neq\nvalue: /ciao\njson:\nrules:\n- selector: deny\noperator: eq\nvalue: \"true\"\n- name: more-expensive-policy # no point in evaluating this one if it's not an allowed endpoint\npriority: 1\nopa:\ninlineRego: |\nallow { true }\nresponse:\n- name: x-auth-data\njson:\nproperties:\n- name: tier\nvalueFrom:\nauthJSON: auth.identity.metadata.labels.tier\n- name: first-uuid\nvalueFrom:\nauthJSON: auth.metadata.first.uuid\n- name: second-uuid\nvalueFrom:\nauthJSON: auth.metadata.second.uuid\n- name: second-path\nvalueFrom:\nauthJSON: auth.metadata.second.path\n</code></pre> <p>For the <code>AuthConfig</code> above,</p> <ul> <li> <p>Identity configs <code>tier-2</code> and <code>tier-3</code> (priority 1) will only trigger (concurrently) in case <code>tier-1</code> (priority 0) fails to validate the authentication token first. (This behavior happens without perjudice of context canceling between concurrent evaluators \u2013 i.e. evaluators that are triggered concurrently to another, such as <code>tier-2</code> and <code>tier-3</code>, continue to cancel the context of each other if any of them succeeds validating the token first.)</p> </li> <li> <p>Metadata source <code>second</code> (priority 1) uses the response of the request issued by metadata source <code>first</code> (priority 0), so it will wait for <code>first</code> to finish by triggering only in the second block.</p> </li> <li> <p>Authorization policy <code>allowed-endpoints</code> (piority 0) is considered to be a lot less expensive than <code>more-expensive-policy</code> (priority 1) and has a high chance of denying access to the protected service (if the path is not one of the allowed endpoints). By setting different priorities to these policies we ensure the more expensive policy if triggered in sequence of the less expensive one, instead of concurrently.</p> </li> </ul>"},{"location":"authorino/features/#common-feature-conditions-when","title":"Common feature: Conditions (<code>when</code>)","text":"<p>Conditions, named <code>when</code> in the AUthCOnfig API, are sets of expressions (JSON patterns) that, whenever included, must evaluate to true against the Authorization JSON, so the scope where the expressions are defined is enforced. If any of the expressions in the set of conditions for a given scope does not match, Authorino will skip that scope in the Auth Pipeline.</p> <p>The scope for a set of <code>when</code> conditions can be the entire <code>AuthConfig</code> (\"top-level conditions\") or a particular evaluator of any phase of the auth pipeline.</p> <p>Each expression is a tuple composed of: - a <code>selector</code>, to fetch from the Authorization JSON \u2013 see Common feature: JSON paths for details about syntax; - an <code>operator</code> \u2013 <code>eq</code> (equals), <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for arrays; and <code>matches</code>, for regular expressions; - a fixed comparable <code>value</code></p> <p>Literal expressions and references to expression sets (<code>patterns</code>, defined at the upper level of the <code>AuthConfig</code> spec) can be listed, mixed and combined in <code>when</code> conditions sets.</p> <p>Conditions can be used, e.g.,:</p> <p>i) to skip an entire <code>AuthConfig</code> based on the context:</p> <pre><code>spec:\nwhen: # no authn/authz required on requests to /status\n- selector: context.request.http.path\noperator: neq\nvalue: /status\n</code></pre> <p>ii) to skip parts of an <code>AuthConfig</code> (i.e. a specific evaluator):</p> <pre><code>spec:\nmetadata:\n- name: metadata-source\nhttp:\nendpoint: https://my-metadata-source.io\nwhen: # only fetch the external metadata if the context is HTTP method different than OPTIONS\n- selector: context.request.http.method\noperator: neq\nvalue: OPTIONS\n</code></pre> <p>iii) to enforce a particular evaluator only in certain contexts (really the same as the above, though to a different use case):</p> <pre><code>spec:\nidentity:\n- name: authn-meth-1\napiKey: {...} # this authn method only valid for POST requests to /foo[/*]\nwhen:\n- selector: context.request.http.path\noperator: matches\nvalue: ^/foo(/.*)?$\n- selector: context.request.http.method\noperator: eq\nvalue: POST\n- name: authn-meth-2\noidc: {...}\n</code></pre> <p>iv) to avoid repetition while defining patterns for conditions:</p> <pre><code>spec:\npatterns:\na-pet: # a named pattern that can be reused in sets of conditions\n- selector: context.request.http.path\noperator: matches\nvalue: ^/pets/\\d+(/.*)$\nmetadata:\n- name: pets-info\nwhen:\n- patternRef: a-pet\nhttp:\nendpoint: https://pets-info.io?petId={context.request.http.path.@extract:{\"sep\":\"/\",\"pos\":2}}\nauthorization:\n- name: pets-owners-only\nwhen:\n- patternRef: a-pet\nopa:\ninlineRego: |\nallow { input.metadata[\"pets-info\"].ownerid == input.auth.identity.userid }\n</code></pre> <p>v) mixing and combining literal expressions and refs:</p> <pre><code>spec:\npatterns:\nfoo:\n- selector: context.request.http.path\noperator: eq\nvalue: /foo\nwhen: # unauthenticated access to /foo always granted\n- patternRef: foo\n- selector: context.request.http.headers.authorization\noperator: eq\nvalue: \"\"\nauthorization:\n- name: my-policy-1\nwhen: # authenticated access to /foo controlled by policy\n- patternRef: foo\njson: {...}\n</code></pre> <p>vi) to avoid evaluating unnecessary identity checks when the user can indicate the preferred authentication method (again the pattern of skipping based upon the context):</p> <pre><code>spec:\nidentity:\n- name: jwt\nwhen:\n- selector: selector: context.request.http.headers.authorization\noperator: matches\nvalue: JWT .+\noidc: {...}\n- name: api-key\nwhen:\n- selector: context.request.http.headers.authorization\noperator: matches\nvalue: APIKEY .+\napiKey: {...}\n</code></pre>"},{"location":"authorino/features/#common-feature-caching-cache","title":"Common feature: Caching (<code>cache</code>)","text":"<p>Objects resolved at runtime in an Auth Pipeline can be cached \"in-memory\", and avoided being evaluated again at a subsequent request, until it expires. A lookup cache key and a TTL can be set individually for any evaluator config in an AuthConfig.</p> <p>Each cache config induces a completely independent cache table (or \"cache namespace\"). Consequently, different evaluator configs can use the same cache key and there will be no colision between entries from different evaluators.</p> <p>E.g.:</p> <pre><code>spec:\nhosts:\n- my-api.io\nidentity: [...]\nmetadata:\n- name: external-metadata\nhttp:\nendpoint: http://my-external-source?search={context.request.http.path}\ncache:\nkey:\nvalueFrom: { authJSON: context.request.http.path }\nttl: 300\nauthorization:\n- name: complex-policy\nopa:\nexternalRegistry:\nendpoint: http://my-policy-registry\ncache:\nkey:\nvalueFrom:\nauthJSON: \"{auth.identity.group}-{context.request.http.method}-{context.request.http.path}\"\nttl: 60\n</code></pre> <p>The example above sets caching for the 'external-metadata' metadata config and for the 'complex-policy' authorization policy. In the case of 'external-metadata', the cache key is the path of the original HTTP request being authorized by Authorino (fetched dynamically from the Authorization JSON); i.e., after obtaining a metadata object from the external source for a given contextual HTTP path one first time, whenever that same HTTP path repeats in a subsequent request, Authorino will use the cached object instead of sending a request again to the external source of metadata. After 5 minutes (300 seconds), the cache entry will expire and Authorino will fetch again from the source if requested.</p> <p>As for the 'complex-policy' authorization policy, the cache key is a string composed the 'group' the identity belongs to, the methodd of the HTTP request and the path of the HTTP request. Whenever these repeat, Authorino will use the result of the policy that was evaluated and cached priorly. Cache entries in this namespace expire after 60 seconds.</p> <p>Notes on evaluator caching</p> <p>Capacity - By default, each cache namespace is limited to 1 mb. Entries will be evicted following First-In-First-Out (FIFO) policy to release space. The individual capacity of cache namespaces is set at the level of the Authorino instance (via <code>--evaluator-cache-size</code> command-line flag or <code>spec.evaluatorCacheSize</code> field of the <code>Authorino</code> CR).</p> <p>Usage - Avoid caching objects whose evaluation is considered to be relatively cheap. Examples of operations associated to Authorino auth features that are usually NOT worth caching: validation of JSON Web Tokens (JWT), Kubernetes TokenReviews and SubjectAccessReviews, API key validation, simple JSON pattern-matching authorization rules, simple OPA policies. Examples of operations where caching may be desired: OAuth2 token introspection, fetching of metadata from external sources (via HTTP request), complex OPA policies.</p>"},{"location":"authorino/features/#common-feature-metrics-metrics","title":"Common feature: Metrics (<code>metrics</code>)","text":"<p>By default, Authorino will only export metrics down to the level of the AuthConfig. Deeper metrics at the level of each evaluator within an AuthConfig can be activated by setting the common field <code>metrics: true</code> of the evaluator config.</p> <p>E.g.:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: my-authconfig\nnamespame: my-ns\nspec:\nmetadata:\n- name: my-external-metadata\nhttp:\nendpoint: http://my-external-source?search={context.request.http.path}\nmetrics: true\n</code></pre> <p>The above will enable the metrics <code>auth_server_evaluator_duration_seconds</code> (histogram) and <code>auth_server_evaluator_total</code> (counter) with labels <code>namespace=\"my-ns\"</code>, <code>authconfig=\"my-authconfig\"</code>, <code>evaluator_type=\"METADATA_GENERIC_HTTP\"</code> and <code>evaluator_name=\"my-external-metadata\"</code>.</p> <p>The same pattern works for other types of evaluators. Find below the list of all types and corresponding label constant used in the metric:</p> Evaluator type Metric's <code>evaluator_type</code> label <code>identity.apiKey</code> IDENTITY_APIKEY <code>identity.kubernetes</code> IDENTITY_KUBERNETES <code>identity.oidc</code> IDENTITY_OIDC <code>identity.oauth2</code> IDENTITY_OAUTH2 <code>identity.mtls</code> IDENTITY_MTLS <code>identity.hmac</code> IDENTITY_HMAC <code>identity.plain</code> IDENTITY_PLAIN <code>identity.anonymous</code> IDENTITY_NOOP <code>metadata.http</code> METADATA_GENERIC_HTTP <code>metadata.userInfo</code> METADATA_USERINFO <code>metadata.uma</code> METADATA_UMA <code>authorization.json</code> AUTHORIZATION_JSON <code>authorization.opa</code> AUTHORIZATION_OPA <code>authorization.kubernetes</code> AUTHORIZATION_KUBERNETES <code>response.json</code> RESPONSE_JSON <code>response.wristband</code> RESPONSE_WRISTBAND <p>Metrics at the level of the evaluators can also be enforced to an entire Authorino instance, by setting the <code>--deep-metrics-enabled</code> command-line flag. In this case, regardless of the value of the field <code>spec.(identity|metadata|authorization|response).metrics</code> in the AuthConfigs, individual metrics for all evaluators of all AuthConfigs will be exported.</p> <p>For more information about metrics exported by Authorino, see Observability.</p>"},{"location":"authorino/getting-started/","title":"Getting started","text":"<p>This page covers requirements and instructions to deploy Authorino on a Kubernetes cluster, as well as the steps to declare, apply and try out a protection layer of authentication and authorization over your service, clean-up and complete uninstall.</p> <p>If you prefer learning with an example, check out our Hello World.</p> <ul> <li>Requirements</li> <li>Installation</li> <li>Protect a service</li> <li>Clean-up</li> <li>Next steps</li> </ul>"},{"location":"authorino/getting-started/#requirements","title":"Requirements","text":""},{"location":"authorino/getting-started/#platform-requirements","title":"Platform requirements","text":"<p>These are the plarform requirements to use Authorino:</p> <ul> <li>Kubernetes server (recommended v1.20 or later), with permission to create Kubernetes Custom Resource Definitions (CRDs) (for bootstrapping Authorino and Authorino Operator)</li> </ul> Alternative: K8s distros and platforms      Alternatively to upstream Kubernetes, you should be able use any other Kubernetes distribution or Kubernetes Management Platform (KMP) with support for Kubernetes Custom Resources Definitions (CRD) and custom controllers, such as Red Hat OpenShift, IBM Cloud Kubernetes Service (IKS), Google Kubernetes Engine (GKE), Amazon Elastic Kubernetes Service (EKS) and Azure Kubernetes Service (AKS).    <ul> <li>Envoy proxy (recommended v1.19 or later), to wire up Upstream services (i.e. the services to be protected with Authorino) and external authorization filter (Authorino) for integrations based on the reverse-proxy architecture - example</li> </ul> Alternative: Non-reverse-proxy integration      Technically, any client that implements Envoy's external authorization gRPC protocol should be compatible with Authorino. For integrations based on the reverse-proxy architecture nevertheless, we strongly recommended that you leverage Envoy along side Authorino."},{"location":"authorino/getting-started/#feature-specific-requirements","title":"Feature-specific requirements","text":"<p>A few examples are:</p> <ul> <li> <p>For OpenID Connect, make sure you have access to an identity provider (IdP) and an authority that can issue ID tokens (JWTs). Check out Keycloak which can solve both and connect to external identity sources and user federation like LDAP.</p> </li> <li> <p>For Kubernetes authentication tokens, platform support for the TokenReview and SubjectAccessReview APIs of Kubernetes shall be required. In case you want to be able to requests access tokens for clients running outside the custer, you may also want to check out the requisites for using Kubernetes TokenRequest API (GA in v1.20).</p> </li> <li> <p>For User-Managed Access (UMA) resource data, you will need a UMA-compliant server running as well. This can be an implementation of the UMA protocol by each upstream API itself or (more tipically) an external server that knows about the resources. Again, Keycloak can be a good fit here as well. Just keep in mind that, whatever resource server you choose, changing-state actions commanded in the upstream APIs or other parties will have to be reflected in the resource server. Authorino will not do that for you.</p> </li> </ul> <p>Check out the Feature specification page for more feature-specific requirements.</p>"},{"location":"authorino/getting-started/#installation","title":"Installation","text":""},{"location":"authorino/getting-started/#step-install-the-authorino-operator","title":"Step: Install the Authorino Operator","text":"<p>The simplest way to install the Authorino Operator is by applying the manifest bundle:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <p>The above will install the latest build of the Authorino Operator and latest version of the manifests (CRDs and RBAC), which by default points as well to the latest build of Authorino, both based on the <code>main</code> branches of each component. To install a stable released version of the Operator and therefore also defaults to its latest compatible stable release of Authorino, replace <code>main</code> with another tag of a proper release of the Operator, e.g. 'v0.2.0'.</p> <p>Alternatively, you can deploy the Authorino Operator using the Operator Lifecycle Manager bundles. For instructions, check out Installing via OLM.</p>"},{"location":"authorino/getting-started/#step-request-an-authorino-instance","title":"Step: Request an Authorino instance","text":"<p>Choose either cluster-wide or namespaced deployment mode and whether you want TLS termination enabled for the Authorino endpoints (gRPC authorization, raw HTTP authorization, and OIDC Festival Wristband Discovery listeners), and follow the corresponding instructions below.</p> <p>The instructions here are for centralized gateway or centralized authorization service architecture. Check out the Topologies section of the docs for alternatively running Authorino in a sidecar container.</p> Cluster-wide (with TLS)    Create the namespace:   <pre><code>kubectl create namespace authorino\n</code></pre>    Deploy [cert-manager](https://github.com/jetstack/cert-manager) (skip if you already have certificates and certificate keys created and stored in Kubernetes `Secret`s in the namespace or cert-manager is installed and running in the cluster):   <pre><code>kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.4.0/cert-manager.yaml\n</code></pre>    Create the TLS certificates (skip if you already have certificates and certificate keys created and stored in Kubernetes `Secret`s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre>    Deploy Authorino:   <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre> Cluster-wide (without TLS) <pre><code>kubectl create namespace authorino\nkubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> Namespaced (with TLS)    Create the namespace:   <pre><code>kubectl create namespace myapp\n</code></pre>    Deploy [cert-manager](https://github.com/jetstack/cert-manager) (skip if you already have certificates and certificate keys created and stored in Kubernetes `Secret`s in the namespace or cert-manager is installed and running in the cluster):   <pre><code>kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.4.0/cert-manager.yaml\n</code></pre>    Create the TLS certificates (skip if you already have certificates and certificate keys created and stored in Kubernetes `Secret`s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/myapp/g\" | kubectl -n myapp apply -f -\n</code></pre>    Deploy Authorino:   <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre> Namespaced (without TLS) <pre><code>kubectl create namespace myapp\nkubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/getting-started/#protect-a-service","title":"Protect a service","text":"<p>The most typical integration to protect services with Authorino is by putting the service (upstream) behind a reverse-proxy or API gateway, enabled with an authorization filter that ensures all requests to the service are first checked with the authorization server (Authorino).</p> <p>To do that, make sure you have your upstream service deployed and running, usually in the same Kubernetes server where you installed Authorino. Then, setup an Envoy proxy and create an Authorino <code>AuthConfig</code> for your service.</p> <p>Authorino exposes 2 interfaces to serve the authorization requests: - a gRPC interface that implements Envoy's External Authorization protocol; - a raw HTTP authorization interface, suitable for using Authorino with Kubernetes ValidatingWebhook, for Envoy external authorization via HTTP, and other integrations (e.g. other proxies).</p> <p>To use Authorino as a simple satellite (sidecar) Policy Decision Point (PDP), applications can integrate directly via any of these interfaces. By integrating via a proxy or API gateway, the combination makes Authorino to perform as an external Policy Enforcement Point (PEP) completely decoupled from the application.</p>"},{"location":"authorino/getting-started/#life-cycle","title":"Life cycle","text":""},{"location":"authorino/getting-started/#step-setup-envoy","title":"Step: Setup Envoy","text":"<p>To configure Envoy for proxying requests targeting the upstream service and authorizing with Authorino, setup an Envoy configuration that enables Envoy's external authorization HTTP filter. Store the configuration in a <code>ConfigMap</code>.</p> <p>These are the important bits in the Envoy configuration to activate Authorino:</p> <pre><code>static_resources:\nlisteners:\n- address: {\u2026} # TCP socket address and port of the proxy\nfilter_chains:\n- filters:\n- name: envoy.http_connection_manager\ntyped_config:\n\"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\nroute_config: {\u2026} # routing configs - virtual host domain and endpoint matching patterns and corresponding upstream services to redirect the traffic\nhttp_filters:\n- name: envoy.filters.http.ext_authz # the external authorization filter\ntyped_config:\n\"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\ntransport_api_version: V3\nfailure_mode_allow: false # ensures only authenticated and authorized traffic goes through\ngrpc_service:\nenvoy_grpc:\ncluster_name: authorino\ntimeout: 1s\nclusters:\n- name: authorino\nconnect_timeout: 0.25s\ntype: strict_dns\nlb_policy: round_robin\nhttp2_protocol_options: {}\nload_assignment:\ncluster_name: authorino\nendpoints:\n- lb_endpoints:\n- endpoint:\naddress:\nsocket_address:\naddress: authorino-authorino-authorization # name of the Authorino service deployed \u2013 it can be the fully qualified name with `.&lt;namespace&gt;.svc.cluster.local` suffix (e.g. `authorino-authorino-authorization.myapp.svc.cluster.local`)\nport_value: 50051\ntransport_socket: # in case TLS termination is enabled in Authorino; omit it otherwise\nname: envoy.transport_sockets.tls\ntyped_config:\n\"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\ncommon_tls_context:\nvalidation_context:\ntrusted_ca:\nfilename: /etc/ssl/certs/authorino-ca-cert.crt\n</code></pre> <p>For a complete Envoy <code>ConfigMap</code> containing an upstream API protected with Authorino, with TLS enabled and option for rate limiting with Limitador, plus a webapp served with under the same domain of the protected API, check out this example.</p> <p>After creating the <code>ConfigMap</code> with the Envoy configuration, create an Envoy <code>Deployment</code> and <code>Service</code>. E.g.:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: envoy\n  labels:\n    app: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n        - name: envoy\n          image: envoyproxy/envoy:v1.19-latest\n          command: [\"/usr/local/bin/envoy\"]\n          args:\n            - --config-path /usr/local/etc/envoy/envoy.yaml\n            - --service-cluster front-proxy\n            - --log-level info\n            - --component-log-level filter:trace,http:debug,router:debug\n          ports:\n            - name: web\n              containerPort: 8000 # matches the adddress of the listener in the envoy config\n          volumeMounts:\n            - name: config\n              mountPath: /usr/local/etc/envoy\n              readOnly: true\n            - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n              subPath: ca.crt\n              mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n              readOnly: true\n      volumes:\n        - name: config\n          configMap:\n            name: envoy\n            items:\n              - key: envoy.yaml\n                path: envoy.yaml\n        - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n          secret:\n            defaultMode: 420\n            secretName: authorino-ca-cert\n  replicas: 1\nEOF\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n    - name: web\n      port: 8000\n      protocol: TCP\nEOF\n</code></pre>"},{"location":"authorino/getting-started/#step-apply-an-authconfig","title":"Step: Apply an <code>AuthConfig</code>","text":"<p>Check out the docs for a full description of Authorino's <code>AuthConfig</code> Custom Resource Definition (CRD) and its features.</p> <p>For examples based on specific use-cases, check out the User guides.</p> <p>For authentication based on OpenID Connect (OIDC) JSON Web Tokens (JWT), plus one simple JWT claim authorization check, a typical <code>AuthConfig</code> custom resource looks like the following:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: my-api-protection\nspec:\nhosts: # any hosts that resolve to the envoy service and envoy routing config where the external authorization filter is enabled\n- my-api.io # north-south traffic through a Kubernetes `Ingress` or OpenShift `Route`\n- my-api.myapp.svc.cluster.local # east-west traffic (between applications within the cluster)\nidentity:\n- name: idp-users\noidc:\nendpoint: https://my-idp.com/auth/realm\nauthorization:\n- name: check-claim\njson:\nrules:\n- selector: auth.identity.group\noperator: eq\nvalue: allowed-users\nEOF\n</code></pre> <p>After applying the <code>AuthConfig</code>, consumers of the protected service should be able to start sending requests.</p>"},{"location":"authorino/getting-started/#clean-up","title":"Clean-up","text":""},{"location":"authorino/getting-started/#remove-protection","title":"Remove protection","text":"<p>Delete the <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp delete authconfig/my-api-protection\n</code></pre> <p>Decommission the Authorino instance:</p> <pre><code>kubectl -n myapp delete authorino/authorino\n</code></pre>"},{"location":"authorino/getting-started/#uninstall","title":"Uninstall","text":"<p>To completely remove Authorino CRDs, run from the Authorino Operator directory:</p> <pre><code>make uninstall\n</code></pre>"},{"location":"authorino/getting-started/#next-steps","title":"Next steps","text":"<ol> <li>Read the docs. The Architecture page and the Features page are good starting points to learn more about how Authorino works and its functionalities.</li> <li>Check out the User guides for several examples of <code>AuthConfig</code>s based on specific use-cases</li> </ol>"},{"location":"authorino/terminology/","title":"Terminology","text":"<p>Here we define some terms that are used in the project, with the goal of avoiding confusion and facilitating more accurate conversations related to <code>Authorino</code>.</p> <p>If you see terms used that are not here (or are used in place of terms here) please consider contributing a definition to this doc with a PR, or modifying the use elsewhere to align with these terms.</p>"},{"location":"authorino/terminology/#terms","title":"Terms","text":"<p>Access token Type of temporary password (security token), tied to an authenticated identity, issued by an auth server as of request from either the identity subject itself or a registered auth client known by the auth server, and that delegates to a party powers to operate on behalf of that identity before a resource server; it can be formatted  as an opaque data string or as an encoded JSON Web Token (JWT).</p> <p>Application Programming Interface (API) Interface that defines interactions between multiple software applications; (in HTTP communication) set of endpoints and specification to expose resources hosted by a resource server, to be consumed by client applications; the access facade of a resource server.</p> <p>Attribute-based Access Control (ABAC) Authorization model that grants/denies access to resources based on evaluation of authorization policies which combine attributes together (from claims, from the request, from the resource, etc).</p> <p>Auth Usually employed as a short for authentication and authorization together (AuthN/AuthZ).</p> <p>Auth client Application client (software) that uses an auth server, either in the process of authenticating and/or authorizing identity subjects (including self) who want to consume resources from a resources server or auth server.</p> <p>Auth server Server where auth clients, users, roles, scopes, resources, policies and permissions can be stored and managed.</p> <p>Authentication (AuthN) Process of verifying that a given credential belongs to a claimed-to-be identity; usually resulting in the issuing of an access token.</p> <p>Authorization (AuthZ) Process of granting (or denying) access over a resource to a party based on the set of authorization rules, policies and/or permissions enforced.</p> <p>Authorization header HTTP request header frequently used to carry credentials to authenticate a user in an HTTP communication, like in requests sent to an API; alternatives usually include credentials carried in another (custom) HTTP header, query string parameter or HTTP cookie.</p> <p>Capability Usually employed to refer to a management feature of a Kubernetes-native system, based on the definition and use of Kubernetes Custom Resources (CRDs and CRs), that enables that system to one of the following \u201ccapability levels\u201d: Basic Install, Seamless Upgrades, Full Lifecycle, Deep Insights, Auto Pilot.</p> <p>Claim Attribute packed in a security token which represents a claim that one who bears the token is making about an entity, usually an identity subject.</p> <p>Client ID Unique identifier of an auth client within an auth server domain (or auth server realm).</p> <p>Client secret Password presented by auth clients together with their Client IDs while authenticating with an auth server, either when requesting access tokens to be issued or when consuming services from the auth servers in general.</p> <p>Delegation Process of granting a party (usually an auth client) with powers to act, often with limited scope, on behalf of an identity, to access resources from a resource server. See also OAuth2.</p> <p>Hash-based Message Authentication Code (HMAC) Specific type of message authentication code (MAC) that involves a cryptographic hash function and a shared secret cryptographic key; it can be used to verify the authenticity of a message and therefore as an authentication method.</p> <p>Identity Set of properties that qualifies a subject as a strong identifiable entity (usually a user), who can be authenticated by an auth server. See also Claims.</p> <p>Identity and Access Management (IAM) system Auth system that implements and/or connects with sources of identity (IdP) and offers interfaces for managing access (authorization policies and permissions). See also Auth server.</p> <p>Identity Provider (IdP) Source of identity; it can be a feature of an auth server or external source connected to an auth server.</p> <p>ID token Special type of access token; an encoded JSON Web Token (JWT) that packs claims about an identity.</p> <p>JSON Web Token (JWT) JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.</p> <p>JSON Web Signature (JWS) Standard for signing arbitrary data, especially JSON Web Tokens (JWT).</p> <p>JSON Web Key Set (JWKS) Set of keys containing the public keys used to verify any JSON Web Token (JWT).</p> <p>Keycloak Open source auth server to allow single sign-on with identity and access management.</p> <p>Lightweight Directory Access Protocol (LDAP) Open standard for distributed directory information services for sharing of information about users, systems, networks, services and applications.</p> <p>Mutual Transport Layer Security (mTLS) Protocol for the mutual authentication of client-server communication, i.e., the client authenticates the server and the server authenticates the client, based on the acceptance of the X.509 certificates of each party.</p> <p>OAuth 2.0 (OAuth2) Industry-standard protocol for delegation.</p> <p>OpenID Connect (OIDC) Simple identity verification (authentication) layer built on top of the OAuth2 protocol.</p> <p>Open Policy Agent (OPA) Authorization policy agent that enables the usage of declarative authorization policies written in Rego language.</p> <p>Opaque token Security token devoid of explicit meaning (e.g. random string); it requires the usage of lookup mechanism to be translated into a meaningful set claims representing an identity.</p> <p>Permission Association between a protected resource the authorization policies that must be evaluated whether access should be granted; e.g. <code>&lt;user|group|role&gt;</code> CAN DO <code>&lt;action&gt;</code> ON RESOURCE <code>&lt;X&gt;</code>.</p> <p>Policy Rule or condition (authorization policy) that must be satisfied to grant access to a resource; strongly related to the different access control mechanisms (ACMs) and strategies one can use to protect resources, e.g. attribute-based access control (ABAC), role-based access control (RBAC), context-based access control, user-based access control (UBAC).</p> <p>Policy Administration Point (PAP) Set of UIs and APIs to manage resources servers, resources, scopes, policies and permissions; it is where the auth system is configured.</p> <p>Policy Decision Point (PDP) Where the authorization requests are sent, with permissions being requested, and authorization policies are evaluated accordingly.</p> <p>Policy Enforcement Point (PEP) Where the authorization is effectively enforced, usually at the resource server or at a proxy, based on a response provided by the Policy Decision Point (PDP).</p> <p>Policy storage Where policies are stored and from where they can be fetched, perhaps to be cached.</p> <p>Red Hat SSO Auth server; downstream product created from the Keycloak Open Source project.</p> <p>Refresh token Special type of security token, often provided together with an access token in an OAuth2 flow, used to renew the duration of an access token before it expires; it requires client authentication.</p> <p>Request Party Token (RPT) JSON Web Token (JWT) digitally signed using JSON Web Signature (JWS), issued by the Keycloak auth server.</p> <p>Resource One or more endpoints of a system, API or server, that can be protected.</p> <p>Resource-level Access Control (RLAC) Authorization model that takes into consideration attributes of each specific request resource to grant/deny access to those resources (e.g. the resource's owner).</p> <p>Resource server Server that hosts protected resources.</p> <p>Role Aspect of a user\u2019s identity assigned to the user to indicate the level of access they should have to the system; essentially, roles represent collections of permissions</p> <p>Role-based Access Control (RBAC) Authorization model that grants/denies access to resources based on the roles of authenticated users (rather than on complex attributes/policy rules).</p> <p>Scope Mechanism that defines the specific operations that applications can be allowed to do or information that they can request on an identity\u2019s behalf; often presented as a parameter when access is requested as a way to communicate what access is needed, and used by auth server to respond what actual access is granted.</p> <p>Single Page Application (SPA) Web application or website that interacts with the user by dynamically rewriting the current web page with new data from the web server.</p> <p>Single Sign-on (SSO) Authentication scheme that allows a user to log in with a single ID and password to any of several related, yet independent, software systems.</p> <p>Upstream (In the context of authentication/authorization) API whose endpoints must be protected by the auth system; the unprotected service in front of which a protection layer is added (by connecting with a Policy Decision Point).</p> <p>User-based Access Control (UBAC) Authorization model that grants/denies access to resources based on claims of the identity (attributes of the user).</p> <p>User-Managed Access (UMA) OAuth2-based access management protocol, used for users of an auth server to control the authorization process, i.e. directly granting/denying access to user-owned resources to other requesting parties.</p>"},{"location":"authorino/user-guides/","title":"User guides","text":"<ul> <li> <p>Hello World The basics of protecting an API with Authorino.</p> </li> <li> <p>Authentication with Kubernetes tokens (TokenReview API) Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> </li> <li> <p>Authentication with API keys Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> </li> <li> <p>Authentication with X.509 certificates and mTLS Verify client X.509 certificates against trusted root CAs.</p> </li> <li> <p>OpenID Connect Discovery and authentication with JWTs Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> </li> <li> <p>OAuth 2.0 token introspection (RFC 7662) Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> </li> <li> <p>Passing credentials (<code>Authorization</code> header, cookie headers and others) Customize where credentials are supplied in the request by each trusted source of identity.</p> </li> <li> <p>HTTP \"Basic\" Authentication (RFC 7235) Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> </li> <li> <p>Anonymous access Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> </li> <li> <p>Token normalization Normalize identity claims from trusted sources and reduce complexity in your policies.</p> </li> <li> <p>Edge Authentication Architecture (EAA) Exchange satellite (outer-layer) authentication tokens for \"Festival Wristbands\" accepted ubiquitously at the inside of your network. Normalize from multiple and varied sources of identity and authentication methods in the edge of your architecture; filter privacy data, limit the scope of permissions, and simplify authorization rules to your internal micro-services.</p> </li> <li> <p>Fetching auth metadata from external sources Get online data from remote HTTP services to enhance authorization rules.</p> </li> <li> <p>OpenID Connect UserInfo Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> </li> <li> <p>Resource-level authorization with User-Managed Access (UMA) resource registry Fetch resource attributes relevant for authorization from a User-Managed Access (UMA) resource registry such as Keycloak resource server clients.</p> </li> <li> <p>Simple pattern-matching authorization policies Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> </li> <li> <p>OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> </li> <li> <p>Open Policy Agent (OPA) Rego policies Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> </li> <li> <p>Kubernetes RBAC for service authorization (SubjectAccessReview API) Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> </li> <li> <p>Authorization with Keycloak Authorization Services Use Authorino as an adapter for Keycloak Authorization Services without importing any library or rebuilding your application code.</p> </li> <li> <p>Integration with Authzed/SpiceDB Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> </li> <li> <p>Injecting data in the request Inject HTTP headers with serialized JSON content.</p> </li> <li> <p>Authenticated rate limiting (with Envoy Dynamic Metadata) Provide Envoy with dynamic metadata from the external authorization process to be injected and used by consecutive filters, such as by a rate limiting service.</p> </li> <li> <p>Redirecting to a login page Customize response status code and headers on failed requests. E.g. redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>; mask resources on access denied behind a <code>404 Not Found</code> response instead of <code>403 Forbidden</code>.</p> </li> <li> <p>Mixing Envoy built-in filter for auth and Authorino Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> </li> <li> <p>Host override via context extension Induce the lookup of an AuthConfig by supplying extended host context, for use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> </li> <li> <p>Using Authorino as ValidatingWebhook service Use Authorino as a generic Kubernetes ValidatingWebhook service where the rules to validate a request to the Kubernetes API are written in an AuthConfig.</p> </li> <li> <p>Reducing the operational space: sharding, noise and multi-tenancy Have multiple instances of Authorino running in the same space (Kubernetes namespace or cluster-scoped), yet watching particular sets of resources.</p> </li> <li> <p>Caching Cache auth objects resolved at runtime for any configuration bit of an AuthConfig, for easy access in subsequent requests whenever an arbitrary cache key repeats, until the cache entry expires.</p> </li> <li> <p>Observability Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p> </li> </ul>"},{"location":"authorino/user-guides/anonymous-access/","title":"User guide: Anonymous access","text":"<p>Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> </ul>     For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/anonymous-access/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/anonymous-access/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/anonymous-access/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/anonymous-access/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/anonymous-access/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/anonymous-access/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: public\n    anonymous: {}\nEOF\n</code></pre> <p>The example above enables anonymous access (i.e. removes authentication), without adding any extra layer of protection to the API. This is virtually equivalent to setting a top-level condition to the <code>AuthConfig</code> that always skips the configuration, or to switching authentication/authorization off completely in the route to the API.</p> <p>For more sophisticated use cases of anonymous access with Authorino, consider combining this feature with other identity sources in the <code>AuthConfig</code> while playing with the priorities of each source, as well as combination with <code>when</code> conditions, and/or adding authorization policies that either cover authentication or address anonymous access with proper rules (e.g. enforcing read-only access).</p> <p>Check out the docs for the Anonymous access feature for an example of an <code>AuthConfig</code> that falls back to anonymous access when a priority OIDC/JWT-based authentication fails, and enforces a read-only policy in such cases.</p>"},{"location":"authorino/user-guides/anonymous-access/#6-consume-the-api","title":"6. Consume the API","text":"<pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/anonymous-access/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/","title":"User guide: Authentication with API keys","text":"<p>Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> </ul>     In Authorino, API keys are stored as Kubernetes `Secret`s. Each resource must contain an `api_key` entry with the value of the API key, and labeled to match the selectors specified in `spec.identity.apiKey.selector` of the `AuthConfig`.    API key `Secret`s must also include labels that match the `secretLabelSelector` field of the Authorino instance. See [Resource reconciliation and status update](../architecture.md#resource-reconciliation-and-status-update) for details.    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/api-key-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/api-key-authentication/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: friends\n    apiKey:\n      selector:\n        matchLabels:\n          group: friends\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\nEOF\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#6-create-an-api-key","title":"6. Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#7-consume-the-api","title":"7. Consume the API","text":"<p>With a valid API key:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid API key:</p> <pre><code>curl -H 'Authorization: APIKEY invalid' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"friends\"\n# x-ext-auth-reason: the API Key provided is invalid\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#8-delete-an-api-key-revoke-access-to-the-api","title":"8. Delete an API key (revoke access to the API)","text":"<pre><code>kubectl delete secret/api-key-1\n</code></pre>"},{"location":"authorino/user-guides/api-key-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/","title":"User guide: Authenticated rate limiting (with Envoy Dynamic Metadata)","text":"<p>Provide Envoy with dynamic metadata about the external authorization process to be injected into the rate limiting filter.</p> Authorino features in this guide: <ul> <li>Dynamic response \u2192 Response wrappers \u2192 Envoy Dynamic Metadata</li> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul>     Dynamic JSON objects built out of static values and values fetched from the [Authorization JSON](./../architecture.md#the-authorization-json) can be wrapped to be returned to the reverse-proxy as Envoy Well Known Dynamic Metadata content. Envoy can use those to inject data returned by the external authorization service into the other filters, such as the rate limiting filter.    Check out as well the user guides about [Injecting data in the request](./injecting-data.md) and [Authentication with API keys](./api-key-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#4-deploy-limitador","title":"4. Deploy Limitador","text":"<p>Limitador is a lightweight rate limiting service that can be used with Envoy.</p> <p>On this bundle, we will deploy Limitador pre-configured to limit requests to the <code>talker-api</code> domain up to 5 requests per interval of 60 seconds per <code>user_id</code>. Envoy will be configured to recognize the presence of Limitador and activate it on requests to the Talker API.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#5-setup-envoy","title":"5. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#6-create-the-authconfig","title":"6. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: friends\n    apiKey:\n      selector:\n        matchLabels:\n          group: friends\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\n  response:\n  - name: rate-limit\n    wrapper: envoyDynamicMetadata\n    wrapperKey: ext_auth_data # how this bit of dynamic metadata from the ext authz service is named in the Envoy config\n    json:\n      properties:\n      - name: username\n        valueFrom:\n          authJSON: auth.identity.metadata.annotations.auth-data\\/username\nEOF\n</code></pre> <p>An annotation <code>auth-data/username</code> will be read from the Kubernetes <code>Secret</code>s storing valid API keys and passed as dynamic metadata <code>{ \"ext_auth_data\": { \"username\": \u00abannotations.auth-data/username\u00bb } }</code>.</p> <p>Check out the docs for information about the common feature JSON paths for reading from the Authorization JSON.</p>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#7-create-a-couple-of-api-keys","title":"7. Create a couple of API keys","text":"<p>For user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: john\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: jane\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#8-consume-the-api","title":"8. Consume the API","text":"<p>As John:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Repeat the request a few more times within the 60-second time window, until the response status is <code>429 Too Many Requests</code>.</p> <p>While the API is still limited to John, send requests as Jane:</p> <pre><code>curl -H 'Authorization: APIKEY 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/authzed/","title":"User guide: Integration with Authzed/SpiceDB","text":"<p>Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> Authorino features in this guide: <ul> <li>Authorization \u2192 Authzed/SpiceDB</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p></p>"},{"location":"authorino/user-guides/authzed/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/authzed/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/authzed/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/authzed/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/authzed/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/authzed/#5-create-the-permission-data-base","title":"5. Create the permission data base","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace spicedb\n</code></pre> <p>Create the SpiceDB instance:</p> <pre><code>kubectl -n spicedb apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nspec:\n  selector:\n    matchLabels:\n      app: spicedb\n  template:\n    metadata:\n      labels:\n        app: spicedb\n    spec:\n      containers:\n      - name: spicedb\n        image: authzed/spicedb\n        args:\n        - serve\n        - \"--grpc-preshared-key\"\n        - secret\n        - \"--http-enabled\"\n        ports:\n        - containerPort: 50051\n        - containerPort: 8443\n  replicas: 1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: spicedb\nspec:\n  selector:\n    app: spicedb\n  ports:\n    - name: grpc\n      port: 50051\n      protocol: TCP\n    - name: http\n      port: 8443\n      protocol: TCP\nEOF\n</code></pre> <p>Forward local request to the SpiceDB service:</p> <pre><code>kubectl -n spicedb port-forward service/spicedb 8443:8443 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Create the permission schema:</p> <pre><code>curl -X POST http://localhost:8443/v1/schema/write \\\n-H 'Authorization: Bearer secret' \\\n-H 'Content-Type: application/json' \\\n-d @- &lt;&lt; EOF\n{\n  \"schema\": \"definition blog/user {}\\ndefinition blog/post {\\n\\trelation reader: blog/user\\n\\trelation writer: blog/user\\n\\n\\tpermission read = reader + writer\\n\\tpermission write = writer\\n}\"\n}\nEOF\n</code></pre> <p>Create the relationships:</p> <ul> <li><code>blog/user:emilia</code> \u2192 <code>writer</code> of <code>blog/post:1</code></li> <li><code>blog/user:beatrice</code> \u2192 <code>reader</code> of <code>blog/post:1</code></li> </ul> <pre><code>curl -X POST http://localhost:8443/v1/relationships/write \\\n-H 'Authorization: Bearer secret' \\\n-H 'Content-Type: application/json' \\\n-d @- &lt;&lt; EOF\n{\n  \"updates\": [\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"writer\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"emilia\"\n          }\n        }\n      }\n    },\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"reader\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"beatrice\"\n          }\n        }\n      }\n    }\n  ]\n}\nEOF\n</code></pre>"},{"location":"authorino/user-guides/authzed/#6-create-the-authconfig","title":"6. Create the <code>AuthConfig</code>","text":"<p>Store the shared token for Authorino to authenticate with the SpiceDB instance in a Service:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nstringData:\n  grpc-preshared-key: secret\nEOF\n</code></pre> <p>Create the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: blog-users\n    apiKey:\n      selector:\n        matchLabels:\n          app: talker-api\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\n  authorization:\n  - name: authzed\n    authzed:\n      endpoint: spicedb.spicedb.svc.cluster.local:50051\n      insecure: true\n      sharedSecretRef:\n        name: spicedb\n        key: grpc-preshared-key\n      subject:\n        kind:\n          value: blog/user\n        name:\n          valueFrom:\n            authJSON: auth.identity.metadata.annotations.username\n      resource:\n        kind:\n          value: blog/post\n        name:\n          valueFrom:\n            authJSON: context.request.http.path.@extract:{\"sep\":\"/\",\"pos\":2}\n      permission:\n        valueFrom:\n          authJSON: context.request.http.method.@replace:{\"old\":\"GET\",\"new\":\"read\"}.@replace:{\"old\":\"POST\",\"new\":\"write\"}\nEOF\n</code></pre>"},{"location":"authorino/user-guides/authzed/#7-create-the-api-keys","title":"7. Create the API keys","text":"<p>For Emilia (writer):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-writer\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: emilia\nstringData:\n  api_key: IAMEMILIA\nEOF\n</code></pre> <p>For Beatrice (reader):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-reader\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: beatrice\nstringData:\n  api_key: IAMBEATRICE\nEOF\n</code></pre>"},{"location":"authorino/user-guides/authzed/#8-consume-the-api","title":"8. Consume the API","text":"<p>As Emilia, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n-X GET \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Emilia, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n-X POST \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n-X GET \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n-X POST \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: PERMISSIONSHIP_NO_PERMISSION;token=GhUKEzE2NzU3MDE3MjAwMDAwMDAwMDA=\n</code></pre>"},{"location":"authorino/user-guides/authzed/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace spicedb\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/caching/","title":"User guide: Caching","text":"<p>Cache auth objects resolved at runtime for any configuration bit of an AuthConfig (i.e. any evaluator), of any phase (identity, metadata, authorization and dynamic response), for easy access in subsequent requests, whenever an arbitrary (user-defined) cache key repeats, until the cache entry expires.</p> <p>This is particularly useful for configuration bits whose evaluation is significantly more expensive than accessing the cache. E.g.:</p> <ul> <li>Caching of metadata fetched from external sources in general</li> <li>Caching of previously validated identity access tokens (e.g. for OAuth2 opaque tokens that involve consuming the token introspection endpoint of an external auth server)</li> <li>Caching of complex Rego policies that involve sending requests to external services</li> </ul> <p>Cases where one will NOT want to enable caching, due to relatively cheap compared to accessing and managing the cache: - Validation of OIDC/JWT access tokens - OPA/Rego policies that do not involve external requests - JSON pattern-matching authorization - Dynamic JSON responses - Anonymous access</p> Authorino features in this guide: <ul> <li>Common feature \u2192 Caching</li> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 JSON injection</li> </ul>     For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/caching/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/caching/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/caching/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/caching/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/caching/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/caching/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: anonymous\n    anonymous: {}\n  metadata:\n  - name: cached-metadata\n    http:\n      endpoint: http://talker-api.default.svc.cluster.local:3000/metadata/{context.request.http.path}\n      method: GET\n    cache:\n      key:\n        valueFrom: { authJSON: context.request.http.path }\n      ttl: 60\n  authorization:\n  - name: cached-authz\n    opa:\n      inlineRego: |\n        now = time.now_ns()\n        allow = true\n      allValues: true\n    cache:\n      key:\n        valueFrom: { authJSON: context.request.http.path }\n      ttl: 60\n  response:\n  - name: x-authz-data\n    json:\n      properties:\n      - name: cached-metadata\n        valueFrom: { authJSON: auth.metadata.cached-metadata.uuid }\n      - name: cached-authz\n        valueFrom: { authJSON: auth.authorization.cached-authz.now }\nEOF\n</code></pre> <p>The example above enables caching for the external source of metadata, which in this case, for convinience, is the same upstream API protected by Authorino (i.e. the Talker API), though consumed directly by Authorino, without passing through the proxy. This API generates a <code>uuid</code> random hash that it injects in the JSON response. This value is different in every request processed by ythe API.</p> <p>The example also enables caching of returned OPA virtual documents. <code>cached-authz</code> is a trivial Rego policy that always grants access, but generates a timestamp, which Authorino will cache.</p> <p>In both cases, the path of the HTTP request is used as cache key. I.e., whenever the path repeats, Authorino reuse the values stored previously in each cache table (<code>cached-metadata</code> and <code>cached-authz</code>), respectively saving a request to the external source of metadata and the evaluation of the OPA policy. Cache entries will expire in both cases after 60 seconds they were stored in the cache.</p> <p>The cached values will be visible in the response returned by the Talker API in <code>x-authz-data</code> header injected by Authorino. Thiis way, we can tell when an existing value in the cache was used and when a new one was generated and stored.</p>"},{"location":"authorino/user-guides/caching/#6-consume-the-api","title":"6. Consume the API","text":"<ol> <li>To <code>/hello</code></li> </ol> <pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To a different path</li> </ol> <pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/goodbye\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343097860450300\\\",\\\"cached-metadata\\\":\\\"37fce386-1ee8-40a7-aed1-bf8a208f283c\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again before the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",  &lt;=== same cache-id as before\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again after the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343135702743800\\\",\\\"cached-metadata\\\":\\\"e708a3a6-5caf-4028-ab5c-573ad9be7188\\\"}\",  &lt;=== different cache-id\n# [\u2026]\n</code></pre>"},{"location":"authorino/user-guides/caching/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/","title":"User guide: Redirecting to a login page","text":"<p>Customize response status code and headers on failed requests to redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>.</p> Authorino features in this guide: <ul> <li>Dynamic response \u2192 Custom denial status</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> </ul>     Authorino's default response status codes, messages and headers for unauthenticated (`401`) and unauthorized (`403`) requests can be customized with static values and values fetched from the [Authorization JSON](./../architecture.md#the-authorization-json).    Check out as well the user guides about [HTTP \"Basic\" Authentication (RFC 7235)](./user-guides/http-basic-authentication.md) and [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#2-deploy-the-matrix-quotes-web-application","title":"2. Deploy the Matrix Quotes web application","text":"<p>The Matrix Quotes is a static web application that contains quotes from the film The Matrix.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Matrix Quotes webapp behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/envoy-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>matrix-quotes-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n  - matrix-quotes-authorino.127.0.0.1.nip.io\n  identity:\n  - name: browser-users\n    apiKey:\n      selector:\n        matchLabels:\n          group: users\n    credentials:\n      in: cookie\n      keySelector: TOKEN\n  - name: http-basic-auth\n    apiKey:\n      selector:\n        matchLabels:\n          group: users\n    credentials:\n      in: authorization_header\n      keySelector: Basic\n  denyWith:\n    unauthenticated:\n      code: 302\n      headers:\n      - name: Location\n        valueFrom:\n          authJSON: http://matrix-quotes-authorino.127.0.0.1.nip.io:8000/login.html?redirect_to={context.request.http.path}\nEOF\n</code></pre> <p>Check out the docs for information about the common feature JSON paths for reading from the Authorization JSON.</p>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#6-create-an-api-key","title":"6. Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: user-credential-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpw # john:p\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#7-consume-the-application","title":"7. Consume the application","text":"<p>On a web browser, navigate to http://matrix-quotes-authorino.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page.</p> <p>Log in using John's credentials: - Username: john - Password: p</p> <p>Click again on the cards and check that now you are able to access the inner pages.</p> <p>You can also consume a protected endpoint of the application using HTTP Basic Authentication:</p> <pre><code>curl -u john:p http://matrix-quotes-authorino.127.0.0.1.nip.io:8000/neo.html\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#8-optional-modify-the-authconfig-to-authenticate-with-oidc","title":"8. (Optional) Modify the <code>AuthConfig</code> to authenticate with OIDC","text":""},{"location":"authorino/user-guides/deny-with-redirect-to-login/#setup-a-keycloak-server","title":"Setup a Keycloak server","text":"<p>Deploy a Keycloak server preloaded with a realm named <code>kuadrant</code>:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Resolve local Keycloak domain so it can be accessed from the local host and inside the cluster with the name: (This will be needed to redirect to Keycloak's login page and at the same time validate issued tokens.)</p> <pre><code>echo '127.0.0.1 keycloak' &gt;&gt; /etc/hosts\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre> <p>Create a client:</p> <pre><code>curl -H \"Authorization: Bearer $(curl http://keycloak:8080/auth/realms/master/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=admin-cli' -d 'username=admin' -d 'password=p' | jq -r .access_token)\" \\\n-H 'Content-type: application/json' \\\n-d '{ \"name\": \"matrix-quotes\", \"clientId\": \"matrix-quotes\", \"publicClient\": true, \"redirectUris\": [\"http://matrix-quotes-authorino.127.0.0.1.nip.io:8000/auth*\"], \"enabled\": true }' \\\nhttp://keycloak:8080/auth/admin/realms/kuadrant/clients\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#reconfigure-the-matrix-quotes-app-to-use-keycloaks-login-page","title":"Reconfigure the Matrix Quotes app to use Keycloak's login page","text":"<pre><code>kubectl set env deployment/matrix-quotes KEYCLOAK_REALM=http://keycloak:8080/auth/realms/kuadrant CLIENT_ID=matrix-quotes\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#apply-the-changes-to-the-authconfig","title":"Apply the changes to the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n  - matrix-quotes-authorino.127.0.0.1.nip.io\n  identity:\n  - name: idp-users\n    oidc:\n      endpoint: http://keycloak:8080/auth/realms/kuadrant\n    credentials:\n      in: cookie\n      keySelector: TOKEN\n  denyWith:\n    unauthenticated:\n      code: 302\n      headers:\n      - name: Location\n        valueFrom:\n          authJSON: http://keycloak:8080/auth/realms/kuadrant/protocol/openid-connect/auth?client_id=matrix-quotes&amp;redirect_uri=http://matrix-quotes-authorino.127.0.0.1.nip.io:8000/auth?redirect_to={context.request.http.path}&amp;scope=openid&amp;response_type=code\nEOF\n</code></pre>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#consume-the-application-again","title":"Consume the application again","text":"<p>Refresh the browser window or navigate again to http://matrix-quotes-authorino.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page this time served by the Keycloak server.</p> <p>Log in as Jane (a user of the Keycloak realm): - Username: jane - Password: p</p> <p>Click again on the cards and check that now you are able to access the inner pages.</p>"},{"location":"authorino/user-guides/deny-with-redirect-to-login/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/user-credential-1\nkubectl delete authconfig/matrix-quotes-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/","title":"User guide: Edge Authentication Architecture (EAA)","text":"<p>Edge Authentication Architecture (EAA) is a pattern where more than extracting authentication logics and specifics from the application codebase to a proper authN/authZ layer, this is pushed to the edge of your cloud network, without violating the Zero Trust principle nevertheless.</p> <p>The very definition of \"edge\" is subject to discussion, but the underlying idea is that clients (e.g. API clients, IoT devices, etc) authenticate with a layer that, before moving traffic to inside the network: - understands the complexity of all the different methods of authentication supported; - sometimes some token normalization is involved; - eventually enforces some preliminary authorization policies; and - possibly filters data bits that are sensitive to privacy concerns (e.g. to comply with local legislation such as GRPD, CCPA, etc)</p> <p>As a minimum, EAA allows to simplify authentication between applications and micro-services inside the network, as well as to reduce authorization to domain-specific rules and policies, rather than having to deal all the complexity to support all types of clients in every node.</p> Authorino features in this guide: <ul> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> <ul>     Festival Wristbands are OpenID Connect ID tokens (signed JWTs) issued by Authorino by the end of the Auth Pipeline, for authorized requests. It can be configured to include claims based on static values and values fetched from the [Authorization JSON](./../architecture.md#the-authorization-json).    Check out as well the user guides about [Token normalization](./token-normalization.md), [Authentication with API keys](./api-key-authentication.md) and [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> <li>jwt, to inspect JWTs (optional)</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#2-create-the-namespaces","title":"2. Create the namespaces","text":"<p>For simplicity, this examples will set up edge and internal nodes in different namespaces of the same Kubernetes cluster. Those will share a same single cluster-wide Authorino instance. In real-life scenarios, it does not have to be like that.</p> <pre><code>kubectl create namespace authorino\nkubectl create namespace edge\nkubectl create namespace internal\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>cluster-wide</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#5-setup-the-edge","title":"5. Setup the Edge","text":""},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy","title":"Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl -n edge apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-edge-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>edge-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 9000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl -n edge port-forward deployment/envoy 9000:9000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig","title":"Create the <code>AuthConfig</code>","text":"<p>Create a required secret, used by Authorino to sign the Festival Wristband tokens:</p> <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: edge-auth\nspec:\n  hosts:\n  - edge-authorino.127.0.0.1.nip.io\n  identity:\n  - name: api-clients\n    apiKey:\n      selector:\n        matchLabels:\n          authorino.kuadrant.io/managed-by: authorino\n      allNamespaces: true\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\n    extendedProperties:\n    - name: username\n      valueFrom:\n        authJSON: auth.identity.metadata.annotations.authorino\\.kuadrant\\.io/username\n  - name: idp-users\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n    extendedProperties:\n    - name: username\n      valueFrom:\n        authJSON: auth.identity.preferred_username\n  response:\n  - name: wristband\n    wrapper: envoyDynamicMetadata\n    wristband:\n      issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\n      customClaims:\n      - name: username\n        valueFrom:\n          authJSON: auth.identity.username\n      tokenDuration: 300\n      signingKeyRefs:\n        - name: wristband-signing-key\n          algorithm: ES256\nEOF\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#6-setup-the-internal-workload","title":"6. Setup the internal workload","text":""},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#deploy-the-talker-api","title":"Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy_1","title":"Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-node-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl -n internal port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig_1","title":"Create the <code>AuthConfig</code>","text":"<pre><code>kubectl -n internal apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: edge-authenticated\n    oidc:\n      endpoint: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\nEOF\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#7-create-an-api-key","title":"7. Create an API key","text":"<pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n  annotations:\n    authorino.kuadrant.io/username: alice\n    authorino.kuadrant.io/email: alice@host\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#8-consume-the-api","title":"8. Consume the API","text":""},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#using-the-api-key-to-authenticate","title":"Using the API key to authenticate","text":"<p>Authenticate at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://edge-authorino.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Try to consume the API with authentication token that is only accepted in the edge:</p> <pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"edge-authenticated\"\n# x-ext-auth-reason: credential not found\n</code></pre> <p>(Optional) Inspect the wristband token and verify that it only contains restricted info to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $WRISTBAND_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# {\n#   \"exp\": 1638452051,\n#   \"iat\": 1638451751,\n#   \"iss\": \"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\",\n#   \"sub\": \"02cb51ea0e1c9f3c0960197a2518c8eb4f47e1b9222a968ffc8d4c8e783e4d19\",\n#   \"username\": \"alice\"\n# }\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#authenticating-with-the-keycloak-server","title":"Authenticating with the Keycloak server","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl -n edge run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>(Optional) Inspect the access token issue by Keycloak and verify and how it contains more details about the identity than required to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $ACCESS_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# { [...]\n#   \"email\": \"jane@kuadrant.io\",\n#   \"email_verified\": true,\n#   \"exp\": 1638452220,\n#   \"family_name\": \"Smith\",\n#   \"given_name\": \"Jane\",\n#   \"iat\": 1638451920,\n#   \"iss\": \"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\",\n#   \"jti\": \"699f6e49-dea4-4f29-ae2a-929a3a18c94b\",\n#   \"name\": \"Jane Smith\",\n#   \"preferred_username\": \"jane\",\n#   \"realm_access\": {\n#     \"roles\": [\n#       \"offline_access\",\n#       \"member\",\n#       \"admin\",\n#       \"uma_authorization\"\n#     ]\n#   },\n# [...]\n</code></pre> <p>As Jane, obtain a limited wristband token at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://edge-authorino.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/edge-authentication-architecture-festival-wristbands/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace edge\nkubectl delete namespace internal\nkubectl delete namespace authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino and Authorino Operator manifests, run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/","title":"User guide: Mixing Envoy built-in filter for auth and Authorino","text":"<p>Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> <p>In this user guide, we will set up Envoy and Authorino to protect a service called the Talker API service, with JWT authentication handled in Envoy and a more complex authorization policy enforced in Authorino.</p> <p>The policy defines a geo-fence by which only requests originated in Great Britain (country code: GB) will be accepted, unless the user is bound to a role called 'admin' in the auth server, in which case no geofence is enforced.</p> <p>All requests to the Talker API will be authenticated in Envoy. However, requests to <code>/global</code> will not trigger the external authorization.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> <li>Dynamic response \u2192 Custom denial status</li> </ul>     For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The command below creates the Envoy configuration and deploys the Envoy proxy wire up the Talker API and external authorization with Authorino.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      clusters:\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n      - name: keycloak\n        connect_timeout: 0.25s\n        type: logical_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: keycloak\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: keycloak.keycloak.svc.cluster.local\n                    port_value: 8080\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n      listeners:\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8000\n        filter_chains:\n        - filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { path_separated_prefix: /global }\n                    route: { cluster: talker-api }\n                    typed_per_filter_config:\n                      envoy.filters.http.ext_authz:\n                        \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n                        disabled: true\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.jwt_authn\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication\n                  providers:\n                    keycloak:\n                      issuer: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n                      remote_jwks:\n                        http_uri:\n                          uri: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/certs\n                          cluster: keycloak\n                          timeout: 5s\n                        cache_duration:\n                          seconds: 300\n                      payload_in_metadata: verified_jwt\n                  rules:\n                  - match: { prefix: / }\n                    requires: { provider_name: keycloak }\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  metadata_context_namespaces:\n                  - envoy.filters.http.jwt_authn\n                  grpc_service:\n                    envoy_grpc:\n                      cluster_name: authorino\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n              use_remote_address: true\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: authorino\n    svc: envoy\n  name: envoy\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: authorino\n      svc: envoy\n  template:\n    metadata:\n      labels:\n        app: authorino\n        svc: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.22-latest\n        name: envoy\n        ports:\n        - containerPort: 8000\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\nspec:\n  ports:\n  - name: web\n    port: 8000\n    protocol: TCP\n  selector:\n    app: authorino\n    svc: envoy\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api-authorino.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port:\n              number: 8000\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>For convinience, an <code>Ingress</code> resource is defined with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#5-deploy-the-ip-location-service","title":"5. Deploy the IP Location service","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/ip-location/ip-location-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#6-create-the-authconfig","title":"6. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: jwt\n    plain:\n      authJSON: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\n  metadata:\n  - name: geoinfo\n    http:\n      endpoint: http://ip-location.default.svc.cluster.local:3000/{context.request.http.headers.x-forwarded-for.@extract:{\"sep\":\",\"}}\n      method: GET\n      headers:\n      - name: Accept\n        value: application/json\n    cache:\n      key:\n        valueFrom: { authJSON: \"context.request.http.headers.x-forwarded-for.@extract:{\\\"sep\\\":\\\",\\\"}\" }\n  authorization:\n  - name: geofence\n    when:\n    - selector: auth.identity.realm_access.roles\n      operator: excl\n      value: admin\n    json:\n      rules:\n      - selector: auth.metadata.geoinfo.country_iso_code\n        operator: eq\n        value: \"GB\"\n  denyWith:\n    unauthorized:\n      message:\n        valueFrom: { authJSON: \"The requested resource is not available in {auth.metadata.geoinfo.country_name}\" }\nEOF\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#7-obtain-a-token-and-consume-the-api","title":"7. Obtain a token and consume the API","text":""},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, a non-admin (member) user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 79.123.45.67' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 109.69.200.56' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: The requested resource is not available in Italy\n</code></pre> <p>As John, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 109.69.200.56' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane, an admin user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 79.123.45.67' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 109.69.200.56' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 109.69.200.56' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/envoy-jwt-authn-and-authorino/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete ingress/ingress-wildcard-host\nkubectl delete service/envoy\nkubectl delete deployment/envoy\nkubectl delete configmap/envoy\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/external-metadata/","title":"User guide: Fetching auth metadata from external sources","text":"<p>Get online data from remote HTTP services to enhance authorization rules.</p> Authorino features in this guide: <ul> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul>     You can configure Authorino to fetch additional metadata from external sources in request-time, by sending either GET or POST request to an HTTP service. The service is expected to return a JSON content which is appended to the [Authorization JSON](./../architecture.md#the-authorization-json), thus becoming available for usage in other configs of the Auth Pipeline, such as in authorization policies or custom responses.    URL, parameters and headers of the request to the external source of metadata can be configured, including with dynamic values. Authentication between Authorino and the service can be set as part of these configuration options, or based on shared authentication token stored in a Kubernetes `Secret`.    Check out as well the user guides about [Authentication with API keys](./api-key-authentication.md) and [Open Policy Agent (OPA) Rego policies](./opa-authorization.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/external-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/external-metadata/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/external-metadata/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/external-metadata/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/external-metadata/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/external-metadata/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>In this example, we will implement a geofence policy for the API, using OPA and metadata fetching from an external service that returns geolocalization JSON data for a given IP address. The policy establishes that only <code>GET</code> requests are allowed and the path of the request should be in the form <code>/{country-code}/*</code>, where <code>{country-code}</code> is the 2-character code of the country where the client is identified as in.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: friends\n    apiKey:\n      selector:\n        matchLabels:\n          group: friends\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\n  metadata:\n    - name: geo\n      http:\n        endpoint: http://ip-api.com/json/{context.request.http.headers.x-forwarded-for.@extract:{\"sep\":\",\"}}?fields=countryCode\n        method: GET\n        headers:\n        - name: Accept\n          value: application/json\n  authorization:\n  - name: geofence\n    opa:\n      inlineRego: |\n        import input.context.request.http\n        allow {\n          http.method = \"GET\"\n          split(http.path, \"/\") = [_, requested_country, _]\n          lower(requested_country) == lower(object.get(input.auth.metadata.geo, \"countryCode\", \"\"))\n        }\nEOF\n</code></pre> <p>Check out the docs for information about the common feature JSON paths for reading from the Authorization JSON, including the description of the <code>@extract</code> string modifier.</p>"},{"location":"authorino/user-guides/external-metadata/#6-create-an-api-key","title":"6. Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/external-metadata/#7-consume-the-api","title":"7. Consume the API","text":"<p>From an IP address assigned to the United Kingdom of Great Britain and Northern Ireland (country code GB):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 79.123.45.67' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 79.123.45.67' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>From an IP address assigned to Italy (country code IT):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 109.112.34.56' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 109.112.34.56' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/external-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/hello-world/","title":"User guide: Hello World","text":""},{"location":"authorino/user-guides/hello-world/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#1-create-the-namespace","title":"1. Create the namespace","text":"<pre><code>kubectl create namespace hello-world\n# namespace/hello-world created\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n# deployment.apps/talker-api created\n# service/talker-api created\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#3-setup-envoy","title":"3. Setup Envoy","text":"<pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/envoy-deploy.yaml\n# configmap/envoy created\n# deployment.apps/envoy created\n# service/envoy created\n</code></pre> <p>Forward requests on port 8000 to the Envoy pod running inside the cluster:</p> <pre><code>kubectl -n hello-world port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#4-consume-the-api-unprotected","title":"4. Consume the API (unprotected)","text":"<pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#5-protect-the-api","title":"5. Protect the API","text":""},{"location":"authorino/user-guides/hello-world/#install-the-authorino-operator","title":"Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#deploy-authorino","title":"Deploy Authorino","text":"<pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authorino.yaml\n# authorino.operator.authorino.kuadrant.io/authorino created\n</code></pre> <p>The command above will deploy Authorino as a separate service (in contrast to as a sidecar of the Talker API and other architectures). For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/hello-world/#6-consume-the-api-behind-envoy-and-authorino","title":"6. Consume the API behind Envoy and Authorino","text":"<pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 404 Not Found\n# x-ext-auth-reason: Service not found\n</code></pre> <p>Authorino does not know about the <code>talker-api-authorino.127.0.0.1.nip.io</code> host, hence the <code>404 Not Found</code>. Teach it by applying an <code>AuthConfig</code>.</p>"},{"location":"authorino/user-guides/hello-world/#7-apply-an-authconfig","title":"7. Apply an <code>AuthConfig</code>","text":"<pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authconfig.yaml\n# authconfig.authorino.kuadrant.io/talker-api-protection created\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#8-consume-the-api-without-credentials","title":"8. Consume the API without credentials","text":"<pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-clients\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/user-guides/hello-world/#grant-access-to-the-api-with-a-tailor-made-security-scheme","title":"Grant access to the API with a tailor-made security scheme","text":"<p>Check out other user guides for several AuthN/AuthZ use-cases and instructions to implement them using Authorino. A few examples are:</p> <ul> <li>Authentication with API keys</li> <li>Authentication with JWTs and OpenID Connect Discovery</li> <li>Authentication with Kubernetes tokens (TokenReview API)</li> <li>Authorization with Open Policy Agent (OPA) Rego policies</li> <li>Authorization with simple JSON pattern-matching rules (e.g. JWT claims)</li> <li>Authorization with Kubernetes RBAC (SubjectAccessReview API)</li> <li>Fetching auth metadata from external sources</li> <li>Token normalization</li> </ul>"},{"location":"authorino/user-guides/hello-world/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the namespaces created in step 1 and 5:</p> <pre><code>kubectl delete namespace hello-world\nkubectl delete namespace authorino-operator\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/host-override/","title":"Host override via context extension","text":"<p>By default, Authorino uses the host information of the HTTP request (<code>Attributes.Http.Host</code>) to lookup for an indexed AuthConfig to be enforced. The host info be overridden by supplying a <code>host</code> entry as a (per-route) context entension (<code>Attributes.ContextExtensions</code>), which takes precedence whenever present.</p> <p>Overriding the host attribute of the HTTP request can be useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> <ul> <li>Example of host override for path prefix-based lookup</li> <li>Example of host override for wildcard subdomain lookup</li> </ul> <p>For further details about Authorino lookup of AuthConfig, check out Host lookup.</p>"},{"location":"authorino/user-guides/host-override/#example-of-host-override-for-path-prefix-based-lookup","title":"Example of host override for path prefix-based lookup","text":"<p>In this use case, 2 different APIs (i.e. Dogs API and Cats API) are served under the same base domain, and differentiated by the path prefix: - <code>pets.com/dogs</code> \u2192  Dogs API - <code>pets.com/cats</code> \u2192  Cats API</p> <p>Edit the Envoy config to extend the external authorization settings at the level of the routes, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n- name: pets-api\ndomains: ['pets.com']\nroutes:\n- match:\nprefix: /dogs\nroute:\ncluster: dogs-api\ntyped_per_filter_config:\nenvoy.filters.http.ext_authz:\n\\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\ncheck_settings:\ncontext_extensions:\nhost: dogs.pets.com\n- match:\nprefix: /cats\nroute:\ncluster: cats-api\ntyped_per_filter_config:\nenvoy.filters.http.ext_authz:\n\\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\ncheck_settings:\ncontext_extensions:\nhost: cats.pets.com\n</code></pre> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: dogs-api-protection\nspec:\nhosts:\n- dogs.pets.com\nidentity: [...]\n</code></pre> <p>Create the AuthConfig for the Cats API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: cats-api-protection\nspec:\nhosts:\n- cats.pets.com\nidentity: [...]\n</code></pre> <p>Notice that the host subdomains <code>dogs.pets.com</code> and <code>cats.pets.com</code> are not really requested by the API consumers. Rather, users send requests to <code>pets.com/dogs</code> and <code>pets.com/cats</code>. When routing those requests, Envoy makes sure to inject the corresponding context extensions that will induce the right lookup in Authorino.</p>"},{"location":"authorino/user-guides/host-override/#example-of-host-override-for-wildcard-subdomain-lookup","title":"Example of host override for wildcard subdomain lookup","text":"<p>In this use case, a single Pets API serves requests for any subdomain that matches <code>*.pets.com</code>, e.g.: - <code>dogs.pets.com</code> \u2192  Pets API - <code>cats.pets.com</code> \u2192  Pets API</p> <p>Edit the Envoy config to extend the external authorization settings at the level of the virtual host, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n- name: pets-api\ndomains: ['*.pets.com']\ntyped_per_filter_config:\nenvoy.filters.http.ext_authz:\n\\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\ncheck_settings:\ncontext_extensions:\nhost: pets.com\nroutes:\n- match:\nprefix: /\nroute:\ncluster: pets-api\n</code></pre> <p>The <code>host</code> context extension used above is any key that matches one of the hosts listed in the targeted AuthConfig.</p> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\nname: pets-api-protection\nspec:\nhosts:\n- pets.com\nidentity: [...]\n</code></pre> <p>Notice that requests to <code>dogs.pets.com</code> and to <code>cats.pets.com</code> are all routed by Envoy to the same API, with same external authorization configuration. in all the cases, Authorino will lookup for the indexed AuthConfig associated with <code>pets.com</code>. The same is valid for a request sent, e.g., to <code>birds.pets.com</code>.</p>"},{"location":"authorino/user-guides/http-basic-authentication/","title":"User guide: HTTP \"Basic\" Authentication (RFC 7235)","text":"<p>Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> </ul>     HTTP \"Basic\" Authentication ([RFC 7235](https://datatracker.ietf.org/doc/html/rfc7235)) is not recommended if you can afford other more secure methods such as OpenID Connect. To support legacy nonetheless it is sometimes necessary to implement it.    In Authorino, HTTP \"Basic\" Authentication can be modeled leveraging the API key authentication feature (stored as Kubernetes `Secret`s with an `api_key` entry and labeled to match selectors specified in `spec.identity.apiKey.selector` of the `AuthConfig`).    Check out as well the user guide about [Authentication with API keys](./api-key-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/http-basic-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/http-basic-authentication/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/http-basic-authentication/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/http-basic-authentication/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/http-basic-authentication/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/http-basic-authentication/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: http-basic-auth\n    apiKey:\n      selector:\n        matchLabels:\n          group: users\n    credentials:\n      in: authorization_header\n      keySelector: Basic\n  authorization:\n  - name: acl\n    when:\n    - selector: context.request.http.path\n      operator: eq\n      value: /bye\n    json:\n      rules:\n      - selector: context.request.http.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\"}\n        operator: eq\n        value: john\nEOF\n</code></pre> <p>The config specifies an Access Control List (ACL), by which only the user <code>john</code> is authorized to consume the <code>/bye</code> endpoint of the API.</p> <p>Check out the docs for information about the common feature JSON paths for reading from the Authorization JSON, including the description of the string modifiers <code>@extract</code> and <code>@case</code> used above. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/user-guides/http-basic-authentication/#6-create-user-credentials","title":"6. Create user credentials","text":"<p>To create credentials for HTTP \"Basic\" Authentication, store each <code>username:password</code>, base64-encoded, in the <code>api_key</code> value of the Kubernetes <code>Secret</code> resources. E.g.:</p> <pre><code>printf \"john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" | base64\n# am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA==\n</code></pre> <p>Create credentials for user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA== # john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Create credentials for user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: amFuZTpkTnNScnNhcHkwbk5Dd210NTM3ZkhGcHl4MGNCc0xFcA== # jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/http-basic-authentication/#7-consume-the-api","title":"7. Consume the API","text":"<p>As John (authorized in the ACL):</p> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api-authorino.127.0.0.1.nip.io:8000/bye\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane (NOT authorized in the ACL):</p> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api-authorino.127.0.0.1.nip.io:8000/bye -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>With an invalid user/password:</p> <pre><code>curl -u unknown:invalid http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"http-basic-auth\"\n</code></pre>"},{"location":"authorino/user-guides/http-basic-authentication/#8-revoke-access-to-the-api","title":"8. Revoke access to the API","text":"<pre><code>kubectl delete secret/basic-auth-1\n</code></pre>"},{"location":"authorino/user-guides/http-basic-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/basic-auth-1\nkubectl delete secret/basic-auth-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/injecting-data/","title":"User guide: Injecting data in the request","text":"<p>Inject HTTP headers with serialized JSON content.</p> Authorino features in this guide: <ul> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul>     Inject serialized custom JSON objects as HTTP request headers. Values can be static or fetched from the [Authorization JSON](./../architecture.md#the-authorization-json).    Check out as well the user guide about [Authentication with API keys](./api-key-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/injecting-data/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/injecting-data/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/injecting-data/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/injecting-data/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/injecting-data/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/injecting-data/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>The following defines a JSON object to be injected as an added HTTP header into the request, named after the response config <code>x-ext-auth-data</code>. The object includes 3 properties: 1. a static value <code>authorized: true</code>; 2. a dynamic value <code>request-time</code>, from Envoy-supplied contextual data present in the Authorization JSON; and 3. a greeting message <code>geeting-message</code> that interpolates a dynamic value read from an annotation of the Kubernetes <code>Secret</code> resource that represents the API key used to authenticate into a static string.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: friends\n    apiKey:\n      selector:\n        matchLabels:\n          group: friends\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\n  response:\n  - name: x-ext-auth-data\n    json:\n      properties:\n      - name: authorized\n        value: true\n      - name: request-time\n        valueFrom:\n          authJSON: context.request.time.seconds\n      - name: geeting-message\n        valueFrom:\n          authJSON: Hello, {auth.identity.metadata.annotations.auth-data\\/name}!\nEOF\n</code></pre> <p>Check out the docs for information about the common feature JSON paths for reading from the Authorization JSON.</p>"},{"location":"authorino/user-guides/injecting-data/#6-create-an-api-key","title":"6. Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/name: Rita\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/injecting-data/#7-consume-the-api","title":"7. Consume the API","text":"<pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# {\n#   \"method\": \"GET\",\n#   \"path\": \"/hello\",\n#   \"query_string\": null,\n#   \"body\": \"\",\n#   \"headers\": {\n#     \u2026\n#     \"X-Ext-Auth-Data\": \"{\\\"authorized\\\":true,\\\"geeting-message\\\":\\\"Hello, Rita!\\\",\\\"request-time\\\":1637954644}\",\n#   },\n#   \u2026\n# }\n</code></pre>"},{"location":"authorino/user-guides/injecting-data/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/","title":"User guide: Simple pattern-matching authorization policies","text":"<p>Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> Authorino features in this guide: <ul> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> </ul>     Authorino provides a built-in authorization module to check simple pattern-matching rules against the [Authorization JSON](./../architecture.md#the-authorization-json). This is an alternative to [OPA](./../features.md#open-policy-agent-opa-rego-policies-authorizationopa) when all you want is to check for some simple rules, without complex logics, such as match the value of a JWT claim.    Check out as well the user guide about [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>The <code>email-verified-only</code> authorization policy ensures that users consuming the API from a given network (IP range 192.168.1/24) must have their emails verified.</p> <p>The <code>email_verified</code> claim is a property of the identity added to the JWT by the OpenID Connect issuer.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak-kuadrant-realm\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  authorization:\n  - name: email-verified-only\n    when:\n    - selector: \"context.request.http.headers.x-forwarded-for.@extract:{\\\"sep\\\": \\\",\\\"}\"\n      operator: matches\n      value: 192\\\\.168\\\\.1\\\\.\\\\d+\n    json:\n      rules:\n      - selector: auth.identity.email_verified\n        operator: eq\n        value: \"true\"\nEOF\n</code></pre> <p>Check out the docs for information about semantics and operators supported by the JSON pattern-matching authorization feature, as well the common feature JSON paths for reading from the Authorization JSON, including the description of the string modifier <code>@extract</code> used above. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context..</p>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#6-obtain-an-access-token-and-consume-the-api","title":"6. Obtain an access token and consume the API","text":""},{"location":"authorino/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-jane-email-verified","title":"Obtain an access token and consume the API as Jane (email verified)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 123.45.6.78' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 192.168.1.10' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-peter-email-not-verified","title":"Obtain an access token and consume the API as Peter (email NOT verified)","text":"<p>Obtain an access token with the Keycloak server for Peter:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>As Peter, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 123.45.6.78' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Peter, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n-H 'X-Forwarded-For: 192.168.1.10' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/user-guides/json-pattern-matching-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/keycloak-authorization-services/","title":"User guide: Authorization with Keycloak Authorization Services","text":"<p>Keycloak provides a powerful set of tools (REST endpoints and administrative UIs), also known as Keycloak Authorization Services, to manage and enforce authorization, workflows for multiple access control mechanisms, including discritionary user access control and user-managed permissions.</p> <p>This user guide is an example of how to use Authorino as an adapter to Keycloak Authorization Services while still relying on the reverse-proxy integration pattern, thus not involving importing an authorization library nor rebuilding the application's code.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul>     For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/keycloak-authorization-services/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Keycloak server</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre>"},{"location":"authorino/user-guides/keycloak-authorization-services/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/keycloak-authorization-services/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/keycloak-authorization-services/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/keycloak-authorization-services/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/keycloak-authorization-services/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>In this example, Authorino will accept access tokens (JWTs) issued by the Keycloak server. These JWTs can be either normal Keycloak ID tokens or Requesting Party Tokens (RPT).</p> <p>RPTs include claims about the permissions of the user regarding protected resources and scopes associated with a Keycloak authorization client that the user can access.</p> <p>When the supplied access token is an RPT, Authorino will just validate whether the user's granted permissions present in the token include the requested resource ID (translated from the path) and scope (inferred from the HTTP method). If the token does not contain a <code>permissions</code> claim (i.e. it is not an RPT), Authorino will negotiate a User-Managed Access (UMA) ticket on behalf of the user and try to obtain an RPT on that UMA ticket.</p> <p>In cases of asynchronous user-managed permission control, the first request to the API using a normal Keycloak ID token is denied by Authorino. The user that owns the resource acknowledges the access request in the Keycloak UI. If access is granted, the new permissions will be reflected in subsequent RPTs obtained by Authorino on behalf of the requesting party.</p> <p>Whenever an RPT with proper permissions is obtained by Authorino, the RPT is supplied back to the API consumer, so it can be used in subsequent requests thus skipping new negotiations of UMA tickets.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak-kuadrant-realm\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  authorization:\n  - name: uma\n    opa:\n      inlineRego: |\n        pat := http.send({\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token\",\"method\": \"post\",\"headers\":{\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":\"grant_type=client_credentials\"}).body.access_token\n        resource_id := http.send({\"url\":concat(\"\",[\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/authz/protection/resource_set?uri=\",input.context.request.http.path]),\"method\":\"get\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat])}}).body[0]\n        scope := lower(input.context.request.http.method)\n        access_token := trim_prefix(input.context.request.http.headers.authorization, \"Bearer \")\n        default rpt = \"\"\n        rpt = access_token { object.get(input.auth.identity, \"authorization\", {}).permissions }\n        else = rpt_str {\n          ticket := http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/authz/protection/permission\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat]),\"Content-Type\":\"application/json\"},\"raw_body\":concat(\"\",[\"[{\\\"resource_id\\\":\\\"\",resource_id,\"\\\",\\\"resource_scopes\\\":[\\\"\",scope,\"\\\"]}]\"])}).body.ticket\n          rpt_str := object.get(http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",access_token]),\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":concat(\"\",[\"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket&amp;ticket=\",ticket,\"&amp;submit_request=true\"])}).body, \"access_token\", \"\")\n        }\n        allow {\n          permissions := object.get(io.jwt.decode(rpt)[1], \"authorization\", { \"permissions\": [] }).permissions\n          permissions[i]\n          permissions[i].rsid = resource_id\n          permissions[i].scopes[_] = scope\n        }\n      allValues: true\n  response:\n  - name: x-keycloak\n    when:\n    - selector: auth.identity.authorization.permissions\n      operator: eq\n      value: \"\"\n    json:\n      properties:\n      - name: rpt\n        valueFrom: { authJSON: auth.authorization.uma.rpt }\nEOF\n</code></pre>"},{"location":"authorino/user-guides/keycloak-authorization-services/#6-obtain-an-access-token-with-the-keycloak-server","title":"6. Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for user Jane:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/user-guides/keycloak-authorization-services/#7-consume-the-api","title":"7. Consume the API","text":"<p>As Jane, try to send a <code>GET</code> request to the protected resource <code>/greetings/1</code>, owned by user John.</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, log in to http://localhost:8080/auth/realms/kuadrant/account in the web browser (username: <code>john</code> / password: <code>p</code>), and grant access to the resource <code>greeting-1</code> for Jane. A pending permission request by Jane shall exist in the list of John's Resources.</p> <p>As Jane, try to consume the protected resource <code>/greetings/1</code> again:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n#\n# {\u2026\n#   \"headers\": {\u2026\n#     \"X-Keycloak\": \"{\\\"rpt\\\":\\\"&lt;RPT&gt;\", \u2026\n</code></pre> <p>Copy the RPT from the response and repeat the request now using the RPT to authenticate:</p> <pre><code>curl -H \"Authorization: Bearer &lt;RPT&gt;\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/keycloak-authorization-services/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/","title":"User guide: Kubernetes RBAC for service authorization (SubjectAccessReview API)","text":"<p>Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> Authorino features in this guide: <ul> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul>     Authorino can delegate authorization decision to the Kubernetes authorization system, allowing permissions to be stored and managed using the Kubernetes Role-Based Access Control (RBAC) for example. The feature is based on the `SubjectAccessReview` API and can be used for `resourceAttributes` (parameters defined in the `AuthConfig`) or `nonResourceAttributes` (inferring HTTP path and verb from the original request).    Check out as well the user guide about [Authentication with Kubernetes tokens (TokenReview API)](./kubernetes-tokenreview.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Kubernetes user with permission to create <code>TokenRequest</code>s (to consume the API from ouside the cluster)</li> <li>yq (to parse your <code>~/.kube/config</code> file to extract user authentication data)</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>The <code>AuthConfig</code> below sets all Kubernetes service accounts as trusted users of the API, and relies on the Kubernetes RBAC to enforce authorization using Kubernetes SubjectAccessReview API for non-resource endpoints:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  identity:\n  - name: service-accounts\n    kubernetes:\n      audiences: [\"https://kubernetes.default.svc.cluster.local\"]\n  authorization:\n  - name: k8s-rbac\n    kubernetes:\n      user:\n        valueFrom: { authJSON: auth.identity.user.username }\nEOF\n</code></pre> <p>Check out the spec for the Authorino Kubernetes SubjectAccessReview authorization feature, for resource attributes permission checks where SubjectAccessReviews issued by Authorino are modeled in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb).</p>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#6-create-roles-associated-with-endpoints-of-the-api","title":"6. Create roles associated with endpoints of the API","text":"<p>Because the <code>k8s-rbac</code> policy defined in the <code>AuthConfig</code> in the previous step is for non-resource access review requests, the corresponding roles and role bindings have to be defined at cluster scope.</p> <p>Create a <code>talker-api-greeter</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /hello</code> and <code>POST /hi</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-greeter\nrules:\n- nonResourceURLs: [\"/hello\"]\n  verbs: [\"post\"]\n- nonResourceURLs: [\"/hi\"]\n  verbs: [\"post\"]\nEOF\n</code></pre> <p>Create a <code>talker-api-speaker</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /say/*</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-speaker\nrules:\n- nonResourceURLs: [\"/say/*\"]\n  verbs: [\"post\"]\nEOF\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#7-create-the-serviceaccounts-and-permissions-to-consume-the-api","title":"7. Create the <code>ServiceAccount</code>s and permissions to consume the API","text":"<p>Create service accounts <code>api-consumer-1</code> and <code>api-consumer-2</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-2\nEOF\n</code></pre> <p>Bind both service accounts to the <code>talker-api-greeter</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-greeter-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-greeter\nsubjects:\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\n- kind: ServiceAccount\n  name: api-consumer-2\n  namespace: default\nEOF\n</code></pre> <p>Bind service account <code>api-consumer-1</code> to the <code>talker-api-speaker</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-speaker-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-speaker\nsubjects:\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\nEOF\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#8-consume-the-api","title":"8. Consume the API","text":"<p>Run a pod that consumes one of the greeting endpoints of the API from inside the cluster, as service account <code>api-consumer-1</code>, bound to the <code>talker-api-greeter</code> and <code>talker-api-speaker</code> cluster roles in the Kubernetes RBAC:</p> <pre><code>kubectl run greeter --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/hi\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-1</code>:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-2</code>, bound only to the <code>talker-api-greeter</code> cluster role in the Kubernetes RBAC:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-2\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 403\n</code></pre> Extra: consume the API as service account <code>api-consumer-2</code> from outside the cluster     Obtain a short-lived access token for service account `api-consumer-2`, bound to the `talker-api-greeter` cluster role in the Kubernetes RBAC, using the Kubernetes TokenRequest API:    <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-2/token -f - | jq -r .status.token)\n</code></pre>    Consume the API as `api-consumer-2` from outside the cluster:    <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api-authorino.127.0.0.1.nip.io:8000/say/something -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-subjectaccessreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete serviceaccount/api-consumer-1\nkubectl delete serviceaccount/api-consumer-2\nkubectl delete clusterrolebinding/talker-api-greeter-rolebinding\nkubectl delete clusterrolebinding/talker-api-speaker-rolebinding\nkubectl delete clusterrole/talker-api-greeter\nkubectl delete clusterrole/talker-api-speaker\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/","title":"User guide: Authentication with Kubernetes tokens (TokenReview API)","text":"<p>Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul>     Authorino can verify Kubernetes-valid access tokens (using Kubernetes [TokenReview](https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1) API).    These tokens can be either `ServiceAccount` tokens or any valid user access tokens issued to users of the Kubernetes server API.    The `audiences` claim of the token must include the requested host and port of the protected API (default), or all audiences specified in `spec.identity.kubernetes.audiences` of the `AuthConfig`.    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Kubernetes user with permission to create <code>TokenRequest</code>s (to consume the API from ouside the cluster)</li> <li>yq (to parse your <code>~/.kube/config</code> file to extract user authentication data)</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  identity:\n  - name: authorized-service-accounts\n    kubernetes:\n      audiences:\n      - talker-api\nEOF\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#6-create-a-serviceaccount","title":"6. Create a <code>ServiceAccount</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#7-consume-the-api-from-outside-the-cluster","title":"7. Consume the API from outside the cluster","text":"<p>Obtain a short-lived access token for the <code>api-consumer-1</code> <code>ServiceAccount</code>:</p> <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"audiences\": [\"talker-api\"], \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-1/token -f - | jq -r .status.token)\n</code></pre> <p>Consume the API with a valid Kubernetes token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Consume the API with the Kubernetes token expired (10 minutes):</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"authorized-service-accounts\"\n# x-ext-auth-reason: Not authenticated\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#8-consume-the-api-from-inside-the-cluster","title":"8. Consume the API from inside the cluster","text":"<p>Deploy an application that consumes an endpoint of the Talker API, in a loop, every 10 seconds. The application uses a short-lived service account token mounted inside the container using Kubernetes Service Account Token Volume Projection to authenticate.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: api-consumer\nspec:\n  containers:\n  - name: api-consumer\n    image: quay.io/kuadrant/authorino-examples:api-consumer\n    command: [\"./run\"]\n    args:\n      - --endpoint=http://envoy.default.svc.cluster.local:8000/hello\n      - --token-path=/var/run/secrets/tokens/api-token\n      - --interval=10\n    volumeMounts:\n    - mountPath: /var/run/secrets/tokens\n      name: talker-api-access-token\n  serviceAccountName: api-consumer-1\n  volumes:\n  - name: talker-api-access-token\n    projected:\n      sources:\n      - serviceAccountToken:\n          path: api-token\n          expirationSeconds: 7200\n          audience: talker-api\nEOF\n</code></pre> <p>Check the logs of <code>api-consumer</code>:</p> <pre><code>kubectl logs -f api-consumer\n# Sending...\n# 200\n# 200\n# 200\n# 200\n# ...\n</code></pre>"},{"location":"authorino/user-guides/kubernetes-tokenreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl pod/api-consumer\nkubectl serviceaccount/api-consumer-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/","title":"User guide: Authentication with X.509 certificates and Mutual Transport Layer Security (mTLS)","text":"<p>Verify client X.509 certificates against trusted root CAs stored in Kubernetes <code>Secret</code>s to authenticate access to APIs protected with Authorino.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 mTLS</li> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> </ul>     Authorino can verify x509 certificates presented by clients for authentication on the request to the protected APIs, at application level.    Trusted root Certificate Authorities (CA) are stored as Kubernetes `kubernetes.io/tls` Secrets labeled according to selectors specified in the AuthConfig, watched and cached by Authorino.    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/mtls-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>cert-manager</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Install cert-manager in the cluster:</p> <pre><code>kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.4.0/cert-manager.yaml\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#2-deploy-authorino","title":"2. Deploy Authorino","text":"<p>Create the TLS certificates for the Authorino service:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/default/g\" | kubectl apply -f -\n</code></pre> <p>Deploy an Authorino service:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination enabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/mtls-authentication/#3-deploy-the-talker-api","title":"3. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#4-create-a-ca","title":"4. Create a CA","text":"<p>Create a CA certificate to issue the client certificates that will be used to authenticate to consume the Talker API:</p> <pre><code>openssl req -x509 -sha256 -days 365 -nodes -newkey rsa:2048 -subj \"/CN=talker-api-ca\" -keyout /tmp/ca.key -out /tmp/ca.crt\n</code></pre> <p>Store the CA cert in a Kubernetes <code>Secret</code>, labeled to be discovered by Authorino:</p> <pre><code>kubectl create secret tls talker-api-ca --cert=/tmp/ca.crt --key=/tmp/ca.key\nkubectl label secret talker-api-ca authorino.kuadrant.io/managed-by=authorino app=talker-api\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#5-setup-envoy","title":"5. Setup Envoy","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      listeners:\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8000\n        filter_chains:\n        - transport_socket:\n            name: envoy.transport_sockets.tls\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\n              common_tls_context:\n                tls_certificates:\n                - certificate_chain: {filename: \"/etc/ssl/certs/talker-api/tls.crt\"}\n                  private_key: {filename: \"/etc/ssl/certs/talker-api/tls.key\"}\n                validation_context:\n                  trusted_ca:\n                    filename: /etc/ssl/certs/talker-api/tls.crt\n          filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  include_peer_certificate: true\n                  grpc_service:\n                    envoy_grpc: { cluster_name: authorino }\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config: {}\n              use_remote_address: true\n      clusters:\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n        transport_socket:\n          name: envoy.transport_sockets.tls\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n            common_tls_context:\n              validation_context:\n                trusted_ca:\n                  filename: /etc/ssl/certs/authorino-ca-cert.crt\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.19-latest\n        name: envoy\n        ports:\n        - containerPort: 8000\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n        - mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n          name: authorino-ca-cert\n          readOnly: true\n          subPath: ca.crt\n        - mountPath: /etc/ssl/certs/talker-api\n          name: talker-api-ca\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n      - name: authorino-ca-cert\n        secret:\n          defaultMode: 420\n          secretName: authorino-ca-cert\n      - name: talker-api-ca\n        secret:\n          defaultMode: 420\n          secretName: talker-api-ca\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n  - name: web\n    port: 8000\n    protocol: TCP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api-authorino.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port: { number: 8000 }\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>The bundle includes an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#6-create-the-authconfig","title":"6. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: mtls\n    mtls:\n      selector:\n        matchLabels:\n          app: talker-api\n  authorization:\n  - name: acme\n    json:\n      rules:\n      - selector: auth.identity.Organization\n        operator: incl\n        value: ACME Inc.\nEOF\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#7-consume-the-api","title":"7. Consume the API","text":"<p>With a TLS certificate signed by the trusted CA:</p> <pre><code>openssl genrsa -out /tmp/aisha.key 2048\nopenssl req -new -key /tmp/aisha.key -out /tmp/aisha.csr -subj \"/CN=aisha/C=PK/L=Islamabad/O=ACME Inc./OU=Engineering\"\nopenssl x509 -req -in /tmp/aisha.csr -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -out /tmp/aisha.crt -days 1 -sha256\n\ncurl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api-authorino.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>With a TLS certificate signed by the trusted CA, though missing an authorized Organization:</p> <pre><code>openssl genrsa -out /tmp/john.key 2048\nopenssl req -new -key /tmp/john.key -out /tmp/john.csr -subj \"/CN=john/C=UK/L=London\"\nopenssl x509 -req -in /tmp/john.csr -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -out /tmp/john.crt -days 1 -sha256\n\ncurl -k --cert /tmp/john.crt --key /tmp/john.key https://talker-api-authorino.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#8-try-the-authconfig-via-raw-http-authorization-interface","title":"8. Try the AuthConfig via raw HTTP authorization interface","text":"<p>Expose Authorino's raw HTTP authorization to the local host:</p> <pre><code>kubectl port-forward service/authorino-authorino-authorization 5001:5001 &amp;\n</code></pre> <p>With a TLS certificate signed by the trusted CA:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key -H 'Content-Type: application/json' -d '{}' https://talker-api-authorino.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 200\n</code></pre> <p>With a TLS certificate signed by a unknown authority:</p> <pre><code>openssl req -x509 -sha256 -days 365 -nodes -newkey rsa:2048 -subj \"/CN=untrusted\" -keyout /tmp/untrusted-ca.key -out /tmp/untrusted-ca.crt\nopenssl genrsa -out /tmp/niko.key 2048\nopenssl req -new -key /tmp/niko.key -out /tmp/niko.csr -subj \"/CN=niko/C=JP/L=Osaka\"\nopenssl x509 -req -in /tmp/niko.csr -CA /tmp/untrusted-ca.crt -CAkey /tmp/untrusted-ca.key -CAcreateserial -out /tmp/niko.crt -days 1 -sha256\n\ncurl -k --cert /tmp/niko.crt --key /tmp/niko.key -H 'Content-Type: application/json' -d '{}' https://talker-api-authorino.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 401\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#9-revoke-an-entire-chain-of-certificates","title":"9. Revoke an entire chain of certificates","text":"<pre><code>kubectl delete secret/talker-api-ca\n</code></pre> <p>Even if the deleted root certificate is still cached and accepted at the gateway, Authorino will revoke access at application level immediately.</p> <p>Try with a previously accepted certificate:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api-authorino.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/user-guides/mtls-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete ingress/service\nkubectl delete configmap/service\nkubectl delete configmap/deployment\nkubectl delete configmap/envoy\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <p>To uninstall the cert-manager, run:</p> <pre><code>kubectl delete -f kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.4.0/cert-manager.yaml\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/","title":"User guide: OAuth 2.0 token introspection (RFC 7662)","text":"<p>Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 OAuth 2.0 introspection</li> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> </ul>     Authorino can perform OAuth 2.0 token introspection ([RFC 7662](https://tools.ietf.org/html/rfc7662)) on the access tokens supplied in the requests to protected APIs. This is particularly useful when using opaque tokens, for remote checking the token validity and resolving the identity object.    _Important!_ Authorino does **not** implement [OAuth2 grants](https://datatracker.ietf.org/doc/html/rfc6749#section-4) nor [OIDC authentication flows](https://openid.net/specs/openid-connect-core-1_0.html#Authentication). As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.    Check out as well the user guides about [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md) and [Simple pattern-matching authorization policies](./user-guides/json-pattern-matching-authorization.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/oauth2-token-introspection/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>OAuth 2.0 server that implements the token introspection endpoint (RFC 7662) (e.g. Keycloak or a12n-server)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre> <p>Deploy a a12n-server server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace a12n-server\nkubectl -n a12n-server apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of a12n-server running in the cluster:</p> <pre><code>kubectl -n a12n-server port-forward deployment/a12n-server 8531:8531 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/oauth2-token-introspection/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>Create a couple required secret, used by Authorino to authenticate with Keycloak and a12n-server during the introspection request:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-keycloak\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\nEOF\n</code></pre> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-a12n-server\nstringData:\n  clientID: talker-api\n  clientSecret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak\n    oauth2:\n      tokenIntrospectionUrl: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token/introspect\n      tokenTypeHint: requesting_party_token\n      credentialsRef:\n        name: oauth2-token-introspection-credentials-keycloak\n  - name: a12n-server\n    oauth2:\n      tokenIntrospectionUrl: http://a12n-server.a12n-server.svc.cluster.local:8531/introspect\n      credentialsRef:\n        name: oauth2-token-introspection-credentials-a12n-server\n  authorization:\n  - name: can-read\n    when:\n    - selector: auth.identity.privileges\n      operator: neq\n      value: \"\"\n    json:\n      rules:\n      - selector: auth.identity.privileges.talker-api\n        operator: incl\n        value: read\nEOF\n</code></pre> <p>On every request, Authorino will try to verify the token remotely with the Keycloak server and the a12n-server server.</p> <p>For authorization, whenever the introspected token data includes a <code>privileges</code> property (returned by a12n-server), Authorino will enforce only consumers whose <code>privileges.talker-api</code> includes the <code>\"read\"</code> permission are granted access.</p> <p>Check out the docs for information about the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/user-guides/oauth2-token-introspection/#6-obtain-an-access-token-and-consume-the-api","title":"6. Obtain an access token and consume the API","text":""},{"location":"authorino/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-keycloak-and-consume-the-api","title":"Obtain an access token with Keycloak and consume the API","text":"<p>Obtain an access token with the Keycloak server for user Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As user Jane, consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-a12n-server-and-consume-the-api","title":"Obtain an access token with a12n-server and consume the API","text":"<p>Obtain an access token with the a12n-server server for service account <code>service-account-1</code>:</p> <pre><code>ACCESS_TOKEN=$(curl -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/token\" | jq -r .access_token)\n</code></pre> <p>You can as well obtain an access token from within the cluster, in case your a12n-server is not reachable from the outside:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://a12n-server.a12n-server.svc.cluster.local:8531/token -s -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s | jq -r .access_token)\n</code></pre> <p>Verify the issued token is an opaque access token in this case:</p> <pre><code>echo $ACCESS_TOKEN\n</code></pre> <p>As <code>service-account-1</code>, consumer the API with a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>curl -d \"token=$ACCESS_TOKEN\" -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/revoke\" -i\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/#consume-the-api-with-a-missing-or-invalid-access-token","title":"Consume the API with a missing or invalid access token","text":"<pre><code>curl -H \"Authorization: Bearer invalid\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/user-guides/oauth2-token-introspection/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/oauth2-token-introspection-credentials-keycloak\nkubectl delete secret/oauth2-token-introspection-credentials-a12n-server\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\nkubectl delete namespace a12-server\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/observability/","title":"Observability","text":""},{"location":"authorino/user-guides/observability/#metrics","title":"Metrics","text":"<p>Authorino exports metrics at 2 endpoints:</p> /metrics Metrics of the controller-runtime about reconciliation (caching) of AuthConfigs and API key Secrets /server-metrics Metrics of the external authorization gRPC and OIDC/Festival Writband validation built-in HTTP servers <p>The Authorino Operator creates a Kubernetes <code>Service</code> named <code>&lt;authorino-cr-name&gt;-controller-metrics</code> that exposes the endpoints on port 8080. The Authorino instance allows to modify the port number of the metrics endpoints, by setting the <code>--metrics-addr</code> command-line flag (default: <code>:8080</code>).</p> <p>Main metrics exported by endpoint1:</p> Endpoint: <code>/metrics</code> Metric name Description\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Labels Type controller_runtime_reconcile_total Total number of reconciliations per controller <code>controller=authconfig|secret</code>, <code>result=success|error|requeue</code> counter controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller <code>controller=authconfig|secret</code> counter controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller <code>controller=authconfig|secret</code> histogram controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller <code>controller=authconfig|secret</code> gauge workqueue_adds_total Total number of adds handled by workqueue <code>name=authconfig|secret</code> counter workqueue_depth Current depth of workqueue <code>name=authconfig|secret</code> gauge workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested <code>name=authconfig|secret</code> histogram workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running. <code>name=authconfig|secret</code> gauge workqueue_retries_total Total number of retries handled by workqueue <code>name=authconfig|secret</code> counter workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. <code>name=authconfig|secret</code> gauge workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes. <code>name=authconfig|secret</code> histogram rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host. <code>code=200|404</code>, <code>method=GET|PUT|POST</code> counter Endpoint: <code>/server-metrics</code> Metric name Description Labels Type auth_server_evaluator_total2 Total number of evaluations of individual authconfig rule performed by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_cancelled2 Number of evaluations of individual authconfig rule cancelled by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_ignored2 Number of evaluations of individual authconfig rule ignored by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_denied2 Number of denials from individual authconfig rule evaluated by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_duration_seconds2 Response latency of individual authconfig rule evaluated by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> histogram auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code> counter auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code>, <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED</code> counter auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code> counter auth_server_response_status Response status of authconfigs sent by the auth server. <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED|NOT_FOUND</code> counter grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure. <code>grpc_code=OK|Aborted|Canceled|DeadlineExceeded|Internal|ResourceExhausted|Unknown</code>, <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_handling_seconds Response latency (seconds) of gRPC that had been application-level handled by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> histogram grpc_server_msg_received_total Total number of RPC stream messages received on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_started_total Total number of RPCs started on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter http_server_handled_total Total number of calls completed on the raw HTTP authorization server, regardless of success or failure. <code>http_code</code> counter http_server_handling_seconds Response latency (seconds) of raw HTTP authorization request that had been application-level handled by the server. histogram oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server. <code>namespace</code>, <code>authconfig</code>, <code>wristband</code>, <code>path=oidc-config|jwks</code> counter oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server. <code>status=200|404</code> counter <p>1 Both endpoints export metrics about the Go runtime, such as number of goroutines (go_goroutines) and threads (go_threads), usage of CPU, memory and GC stats.</p> <p>2 Opt-in metrics: <code>auth_server_evaluator_*</code> metrics require <code>authconfig.spec.(identity|metadata|authorization|response).metrics: true</code> (default: <code>false</code>). This can be enforced for the entire instance (all AuthConfigs and evaluators), by setting the <code>--deep-metrics-enabled</code> command-line flag in the Authorino deployment.</p> Example of metrics exported at the <code>/metrics</code> endpoint <pre><code># HELP controller_runtime_active_workers Number of currently used workers per controller\n# TYPE controller_runtime_active_workers gauge\ncontroller_runtime_active_workers{controller=\"authconfig\"} 0\ncontroller_runtime_active_workers{controller=\"secret\"} 0\n# HELP controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller\n# TYPE controller_runtime_max_concurrent_reconciles gauge\ncontroller_runtime_max_concurrent_reconciles{controller=\"authconfig\"} 1\ncontroller_runtime_max_concurrent_reconciles{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller\n# TYPE controller_runtime_reconcile_errors_total counter\ncontroller_runtime_reconcile_errors_total{controller=\"authconfig\"} 12\ncontroller_runtime_reconcile_errors_total{controller=\"secret\"} 0\n# HELP controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller\n# TYPE controller_runtime_reconcile_time_seconds histogram\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.01\"} 11\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.025\"} 17\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.05\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.15\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.35\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.45\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.6\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.7\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.8\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.9\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.75\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"5\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"6\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"7\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"8\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"9\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"10\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"15\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"20\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"25\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"30\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"40\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"50\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"60\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"+Inf\"} 19\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"authconfig\"} 5.171108321999999\ncontroller_runtime_reconcile_time_seconds_count{controller=\"authconfig\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.01\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.025\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.05\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.35\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.45\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.75\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"10\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"20\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"30\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"40\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"50\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"60\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"+Inf\"} 1\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"secret\"} 0.000138025\ncontroller_runtime_reconcile_time_seconds_count{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_total Total number of reconciliations per controller\n# TYPE controller_runtime_reconcile_total counter\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"error\"} 12\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"success\"} 7\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"error\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"success\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 13\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 13\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000140699\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000313162\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003671076\ngo_gc_duration_seconds_count 13\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6357\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 45065\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 128306\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 128327\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.5021512e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 128327\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.5021512e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 128327\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3885\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 33418\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 96417\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 96425\ngo_gc_heap_frees_by_size_bytes_total_sum 9.880944e+06\ngo_gc_heap_frees_by_size_bytes_total_count 96425\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.880944e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 96425\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.356624e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31902\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 11750\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 26\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 26\ngo_gc_pauses_seconds_total_sum 0.003151488\ngo_gc_pauses_seconds_total_count 26\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 80\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 589824\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.140568e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 4.005888e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.0602e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 17104\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 113968\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.140568e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.5021512e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 108175\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.140568e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.595712e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.200768e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31902\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 4.005888e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461572121033354e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 140077\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 113968\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.356624e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 80\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 244\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 244\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 2336\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 2336\ngo_sched_latencies_seconds_sum 0.18509832400000004\ngo_sched_latencies_seconds_count 2336\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.84\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.3728896e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host.\n# TYPE rest_client_requests_total counter\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"GET\"} 114\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"PUT\"} 4\n# HELP workqueue_adds_total Total number of adds handled by workqueue\n# TYPE workqueue_adds_total counter\nworkqueue_adds_total{name=\"authconfig\"} 19\nworkqueue_adds_total{name=\"secret\"} 1\n# HELP workqueue_depth Current depth of workqueue\n# TYPE workqueue_depth gauge\nworkqueue_depth{name=\"authconfig\"} 0\nworkqueue_depth{name=\"secret\"} 0\n# HELP workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running.\n# TYPE workqueue_longest_running_processor_seconds gauge\nworkqueue_longest_running_processor_seconds{name=\"authconfig\"} 0\nworkqueue_longest_running_processor_seconds{name=\"secret\"} 0\n# HELP workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested\n# TYPE workqueue_queue_duration_seconds histogram\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 8\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_queue_duration_seconds_sum{name=\"authconfig\"} 4.969016371\nworkqueue_queue_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_queue_duration_seconds_sum{name=\"secret\"} 4.67e-06\nworkqueue_queue_duration_seconds_count{name=\"secret\"} 1\n# HELP workqueue_retries_total Total number of retries handled by workqueue\n# TYPE workqueue_retries_total counter\nworkqueue_retries_total{name=\"authconfig\"} 12\nworkqueue_retries_total{name=\"secret\"} 0\n# HELP workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.\n# TYPE workqueue_unfinished_work_seconds gauge\nworkqueue_unfinished_work_seconds{name=\"authconfig\"} 0\nworkqueue_unfinished_work_seconds{name=\"secret\"} 0\n# HELP workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes.\n# TYPE workqueue_work_duration_seconds histogram\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 11\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_work_duration_seconds_sum{name=\"authconfig\"} 5.171738079000001\nworkqueue_work_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_work_duration_seconds_sum{name=\"secret\"} 0.000150956\nworkqueue_work_duration_seconds_count{name=\"secret\"} 1\n</code></pre> Example of metrics exported at the <code>/server-metrics</code> endpoint <pre><code># HELP auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds).\n# TYPE auth_server_authconfig_duration_seconds histogram\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.051000000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.101\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.15100000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.201\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.251\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.301\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.351\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.40099999999999997\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.45099999999999996\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.501\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.551\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6010000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6510000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7010000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7510000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8010000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8510000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9010000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9510000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"+Inf\"} 1\nauth_server_authconfig_duration_seconds_sum{authconfig=\"edge-auth\",namespace=\"authorino\"} 0.001701795\nauth_server_authconfig_duration_seconds_count{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.051000000000000004\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.101\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.15100000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.201\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.251\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.301\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.351\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.40099999999999997\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.45099999999999996\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.501\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.551\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6010000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6510000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7010000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7510000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8010000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8510000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9010000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9510000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"+Inf\"} 5\nauth_server_authconfig_duration_seconds_sum{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 0.26967658299999997\nauth_server_authconfig_duration_seconds_count{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_response_status counter\nauth_server_authconfig_response_status{authconfig=\"edge-auth\",namespace=\"authorino\",status=\"OK\"} 1\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"OK\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"PERMISSION_DENIED\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"UNAUTHENTICATED\"} 1\n# HELP auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_total counter\nauth_server_authconfig_total{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_total{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_evaluator_duration_seconds Response latency of individual authconfig rule evaluated by the auth server (in seconds).\n# TYPE auth_server_evaluator_duration_seconds histogram\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.051000000000000004\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.101\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.15100000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.201\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.251\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.301\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.351\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.40099999999999997\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.45099999999999996\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.501\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.551\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6010000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6510000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7010000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7510000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8010000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8510000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9010000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9510000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"+Inf\"} 4\nauth_server_evaluator_duration_seconds_sum{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 0.25800055\nauth_server_evaluator_duration_seconds_count{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_evaluator_total Total number of evaluations of individual authconfig rule performed by the auth server.\n# TYPE auth_server_evaluator_total counter\nauth_server_evaluator_total{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_response_status Response status of authconfigs sent by the auth server.\n# TYPE auth_server_response_status counter\nauth_server_response_status{status=\"NOT_FOUND\"} 1\nauth_server_response_status{status=\"OK\"} 3\nauth_server_response_status{status=\"PERMISSION_DENIED\"} 2\nauth_server_response_status{status=\"UNAUTHENTICATED\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 11\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 11\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000158594\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000324091\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003546711\ngo_gc_duration_seconds_count 11\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6261\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 42477\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 122133\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 122154\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.455944e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 122154\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.455944e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 122154\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3789\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 31067\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 91013\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 91021\ngo_gc_heap_frees_by_size_bytes_total_sum 9.399936e+06\ngo_gc_heap_frees_by_size_bytes_total_count 91021\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.399936e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 91021\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.601744e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31133\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 9866\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 22\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 22\ngo_gc_pauses_seconds_total_sum 0.0030393599999999996\ngo_gc_pauses_seconds_total_count 22\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 79\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 630784\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.159504e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 3.858432e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.14776e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 16696\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 114376\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.159504e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.455944e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 100887\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.159504e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.489216e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.307264e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31133\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 3.858432e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461569717723043e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 132020\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 114376\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.601744e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 79\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 225\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 225\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 1916\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 1916\ngo_sched_latencies_seconds_sum 0.18081453600000003\ngo_sched_latencies_seconds_count 1916\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure.\n# TYPE grpc_server_handled_total counter\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_handling_seconds Histogram of response latency (seconds) of gRPC that had been application-level handled by the server.\n# TYPE grpc_server_handling_seconds histogram\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.005\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.01\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.025\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.05\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.1\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.25\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"1\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"2.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"10\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"+Inf\"} 7\ngrpc_server_handling_seconds_sum{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0.277605516\ngrpc_server_handling_seconds_count{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\n# HELP grpc_server_msg_received_total Total number of RPC stream messages received on the server.\n# TYPE grpc_server_msg_received_total counter\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_received_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server.\n# TYPE grpc_server_msg_sent_total counter\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_sent_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_started_total Total number of RPCs started on the server.\n# TYPE grpc_server_started_total counter\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_started_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server.\n# TYPE oidc_server_requests_total counter\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-configuration\",wristband=\"wristband\"} 1\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-connect/certs\",wristband=\"wristband\"} 1\n# HELP oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server.\n# TYPE oidc_server_response_status counter\noidc_server_response_status{status=\"200\"} 2\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.42\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.370432e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP promhttp_metric_handler_requests_in_flight Current number of scrapes being served.\n# TYPE promhttp_metric_handler_requests_in_flight gauge\npromhttp_metric_handler_requests_in_flight 1\n# HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.\n# TYPE promhttp_metric_handler_requests_total counter\npromhttp_metric_handler_requests_total{code=\"200\"} 1\npromhttp_metric_handler_requests_total{code=\"500\"} 0\npromhttp_metric_handler_requests_total{code=\"503\"} 0\n</code></pre>"},{"location":"authorino/user-guides/observability/#readiness-check","title":"Readiness check","text":"<p>Authorino exposes two main endpoints for health and readiness check of the AuthConfig controller: - <code>/healthz</code>: Health probe (ping) \u2013 reports \"ok\" if the controller is healthy. - <code>/readyz</code>: Readiness probe \u2013 reports \"ok\" if the controller is ready to reconcile AuthConfig-related events.</p> <p>In general, the endpoints return either <code>200</code> (\"ok\", i.e. all checks have passed) or <code>500</code> (when one or more checks failed).</p> <p>The default binding network address is <code>:8081</code>, which can be changed by setting the command-line flag <code>--health-probe-addr</code>.</p> <p>The following additional subpath is available and its corresponding check can be aggregated into the response from the main readiness probe: - <code>/readyz/authconfigs</code>: Aggregated readiness status of the AuthConfigs \u2013 reports \"ok\" if all AuthConfigs watched by the reconciler have been marked as ready.</p> Important!The AuthConfig readiness check within the scope of the aggregated readiness probe endpoint is deactivated by default \u2013 i.e. this check is an opt-in check. Sending a request to the <code>/readyz</code> endpoint without explicitly opting-in for the AuthConfigs check, by using the <code>include</code> parameter, will result in a response message that disregards the actual status of the watched watched AuthConfigs, possibly an \"ok\" message. To read the aggregated status of the watched AuthConfigs, either use the specific endpoint <code>/readyz/authconfigs</code> or opt-in for the check in the aggregated endpoint by sending a request to <code>/readyz?include=authconfigs</code> <p>Apart from <code>include</code> to add the aggregated status of the AuthConfigs, the following additional query string parameters are available: - <code>verbose=true|false</code> - provides more verbose response messages; - <code>exclude=(check name)</code> \u2013 to exclude a particular readiness check (for future usage).</p>"},{"location":"authorino/user-guides/observability/#logging","title":"Logging","text":"<p>Authorino provides structured log messages (\"production\") or more log messages output to stdout in a more user-friendly format (\"development\" mode) and different level of logging.</p>"},{"location":"authorino/user-guides/observability/#log-levels-and-log-modes","title":"Log levels and log modes","text":"<p>Authorino outputs 3 levels of log messages: (from lowest to highest level) 1. <code>debug</code> 2. <code>info</code> (default) 3. <code>error</code></p> <p><code>info</code> logging is restricted to high-level information of the gRPC and HTTP authorization services, limiting messages to incomming request and respective outgoing response logs, with reduced details about the corresponding objects (request payload and authorization result), and without any further detailed logs of the steps in between, except for errors.</p> <p>Only <code>debug</code> logging will include processing details of each Auth Pipeline, such as intermediary requests to validate identities with external auth servers, requests to external sources of auth metadata or authorization policies.</p> <p>To configure the desired log level, set the <code>spec.logLevel</code> field of the <code>Authorino</code> custom resource (or <code>--log-level</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>info</code>.</p> <p>Apart from log level, Authorino can output messages to the logs in 2 different formats: - <code>production</code> (default): each line is a parseable JSON object with properties <code>{\"level\":string, \"ts\":int, \"msg\":string, \"logger\":string, extra values...}</code> - <code>development</code>: more human-readable outputs, extra stack traces and logging info, plus extra values output as JSON, in the format: <code>&lt;timestamp-iso-8601&gt;\\t&lt;log-level&gt;\\t&lt;logger&gt;\\t&lt;message&gt;\\t{extra-values-as-json}</code></p> <p>To configure the desired log mode, set the <code>spec.logMode</code> field of the <code>Authorino</code> custom resource (or <code>--log-mode</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>production</code>.</p> <p>Example of <code>Authorino</code> custom resource with log level <code>debug</code> and log mode <code>production</code>:</p> <pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\nname: authorino\nspec:\nlogLevel: debug\nlogMode: production\nlistener:\ntls:\nenabled: false\noidcServer:\ntls:\nenabled: false\n</code></pre>"},{"location":"authorino/user-guides/observability/#sensitive-data-output-to-the-logs","title":"Sensitive data output to the logs","text":"<p>Authorino will never output HTTP headers and query string parameters to <code>info</code> log messages, as such values usually include sensitive data (e.g. access tokens, API keys and Authorino Festival Wristbands). However, <code>debug</code> log messages may include such sensitive information and those are not redacted.</p> <p>Therefore, DO NOT USE <code>debug</code> LOG LEVEL IN PRODUCTION! Instead use either <code>info</code> or <code>error</code>.</p>"},{"location":"authorino/user-guides/observability/#log-messages-printed-by-authorino","title":"Log messages printed by Authorino","text":"<p>Some log messages printed by Authorino and corresponding extra values included:</p> logger level message extra values <code>authorino</code> <code>info</code> \"setting instance base logger\" <code>min level=info\\|debug</code>, <code>mode=production\\|development</code> <code>authorino</code> <code>info</code> \"booting up authorino\" <code>version</code> <code>authorino</code> <code>debug</code> \"setting up with options\" <code>auth-config-label-selector</code>, <code>deep-metrics-enabled</code>, <code>enable-leader-election</code>, <code>evaluator-cache-size</code>, <code>ext-auth-grpc-port</code>, <code>ext-auth-http-port</code>, <code>health-probe-addr</code>, <code>log-level</code>, <code>log-mode</code>, <code>max-http-request-body-size</code>, <code>metrics-addr</code>, <code>oidc-http-port</code>, <code>oidc-tls-cert</code>, <code>oidc-tls-cert-key</code>, <code>secret-label-selector</code>, <code>timeout</code>, <code>tls-cert</code>, <code>tls-cert-key</code>, <code>watch-namespace</code> <code>authorino</code> <code>info</code> \"attempting to acquire leader lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io...\\n\" <code>authorino</code> <code>info</code> \"successfully acquired lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io\\n\" <code>authorino</code> <code>info</code> \"disabling grpc auth service\" <code>authorino</code> <code>info</code> \"starting grpc auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the grpc auth service\" <code>authorino</code> <code>error</code> \"failed to load tls cert for the grpc auth\" <code>authorino</code> <code>error</code> \"failed to start grpc auth service\" <code>authorino</code> <code>info</code> \"disabling http auth service\" <code>authorino</code> <code>info</code> \"starting http auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http auth service\" <code>authorino</code> <code>error</code> \"failed to start http auth service\" <code>authorino</code> <code>info</code> \"disabling http oidc service\" <code>authorino</code> <code>info</code> \"starting http oidc service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http oidc service\" <code>authorino</code> <code>error</code> \"failed to start http oidc service\" <code>authorino</code> <code>info</code> \"starting manager\" <code>authorino</code> <code>error</code> \"unable to start manager\" <code>authorino</code> <code>error</code> \"unable to create controller\" <code>controller=authconfig\\|secret\\|authconfigstatusupdate</code> <code>authorino</code> <code>error</code> \"problem running manager\" <code>authorino</code> <code>info</code> \"starting status update manager\" <code>authorino</code> <code>error</code> \"unable to start status update manager\" <code>authorino</code> <code>error</code> \"problem running status update manager\" <code>authorino.controller-runtime.metrics</code> <code>info</code> \"metrics server is starting to listen\" <code>addr</code> <code>authorino.controller-runtime.manager</code> <code>info</code> \"starting metrics server\" <code>path</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=ConfigMap, apiVersion=v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=Lease, apiVersion=coordination.k8s.io/v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"resource reconciled\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"host already taken\" <code>authconfig</code>, <code>host</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status did not change\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status changed\" <code>authconfig</code>, <code>authconfig/status</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>error</code> \"failed to update the resource\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>info</code> \"resource status updated\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"resource reconciled\" <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"could not reconcile authconfigs using api key autauthorino.hentication\" <code>authorino.service.oidc</code> <code>info</code> \"request received\" <code>request id</code>, <code>url</code>, <code>realm</code>, <code>config</code>, <code>path</code> <code>authorino.service.oidc</code> <code>info</code> \"response sent\" <code>request id</code> <code>authorino.service.oidc</code> <code>error</code> \"failed to serve oidc request\" <code>authorino.service.auth</code> <code>info</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>info</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>error</code> \"failed to create dynamic metadata\" <code>request id</code>, <code>object</code> <code>authorino.service.auth.authpipeline</code> <code>debug</code> \"skipping config\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"identity validated\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"cannot validate identity\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>error</code> \"failed to extend identity object\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>error</code> \"failed to discovery openid connect configuration\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"auto-refresh of openid connect configuration disabled\" <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"openid connect configuration updated\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oauth2</code> <code>debug</code> \"sending token introspection request\" <code>request id</code>, <code>url</code>, <code>data</code> <code>authorino.service.auth.authpipeline.identity.kubernetesauth</code> <code>debug</code> \"calling kubernetes token review api\" <code>request id</code>, <code>tokenreview</code> <code>authorino.service.auth.authpipeline.identity.apikey</code> <code>error</code> \"Something went wrong fetching the authorized credentials\" <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"fetched auth metadata\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"cannot fetch metadata\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.metadata.http</code> <code>debug</code> \"sending request\" <code>request id</code>, <code>method</code>, <code>url</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.userinfo</code> <code>debug</code> \"fetching user info\" <code>request id</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"requesting pat\" <code>request id</code>, <code>url</code>, <code>data</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"querying resources by uri\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"getting resource data\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"evaluating for input\" <code>request id</code>, <code>input</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access granted\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access denied\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"invalid response from policy evaluation\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to precompile policy\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to download policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to refresh policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"external policy unchanged\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"auto-refresh  of external policy disabled\" <code>policy</code>, <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>info</code> \"policy updated from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.kubernetesauthz</code> <code>debug</code> \"calling kubernetes subject access review api\" <code>request id</code>, <code>subjectaccessreview</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"dynamic response built\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"cannot build dynamic response\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.http</code> <code>debug</code> \"bad request\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"not found\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"request body too large\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"service unavailable\" <code>request id</code>"},{"location":"authorino/user-guides/observability/#examples","title":"Examples","text":"<p>The examples below are all with <code>--log-level=debug</code> and <code>--log-mode=production</code>.</p> Booting up the service <pre><code>{\"level\":\"info\",\"ts\":1669220526.929678,\"logger\":\"authorino\",\"msg\":\"setting instance base logger\",\"min level\":\"debug\",\"mode\":\"production\"}\n{\"level\":\"info\",\"ts\":1669220526.929718,\"logger\":\"authorino\",\"msg\":\"booting up authorino\",\"version\":\"7688cfa32317a49f0461414e741c980e9c05dba3\"}\n{\"level\":\"debug\",\"ts\":1669220526.9297278,\"logger\":\"authorino\",\"msg\":\"setting up with options\",\"auth-config-label-selector\":\"\",\"deep-metrics-enabled\":\"false\",\"enable-leader-election\":\"false\",\"evaluator-cache-size\":\"1\",\"ext-auth-grpc-port\":\"50051\",\"ext-auth-http-port\":\"5001\",\"health-probe-addr\":\":8081\",\"log-level\":\"debug\",\"log-mode\":\"production\",\"max-http-request-body-size\":\"8192\",\"metrics-addr\":\":8080\",\"oidc-http-port\":\"8083\",\"oidc-tls-cert\":\"/etc/ssl/certs/oidc.crt\",\"oidc-tls-cert-key\":\"/etc/ssl/private/oidc.key\",\"secret-label-selector\":\"authorino.kuadrant.io/managed-by=authorino\",\"timeout\":\"0\",\"tls-cert\":\"/etc/ssl/certs/tls.crt\",\"tls-cert-key\":\"/etc/ssl/private/tls.key\",\"watch-namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669220527.9816976,\"logger\":\"authorino.controller-runtime.metrics\",\"msg\":\"Metrics server is starting to listen\",\"addr\":\":8080\"}\n{\"level\":\"info\",\"ts\":1669220527.9823213,\"logger\":\"authorino\",\"msg\":\"starting grpc auth service\",\"port\":50051,\"tls\":true}\n{\"level\":\"info\",\"ts\":1669220527.9823658,\"logger\":\"authorino\",\"msg\":\"starting http auth service\",\"port\":5001,\"tls\":true}\n{\"level\":\"info\",\"ts\":1669220527.9824295,\"logger\":\"authorino\",\"msg\":\"starting http oidc service\",\"port\":8083,\"tls\":true}\n{\"level\":\"info\",\"ts\":1669220527.9825335,\"logger\":\"authorino\",\"msg\":\"starting manager\"}\n{\"level\":\"info\",\"ts\":1669220527.982721,\"logger\":\"authorino\",\"msg\":\"Starting server\",\"path\":\"/metrics\",\"kind\":\"metrics\",\"addr\":\"[::]:8080\"}\n{\"level\":\"info\",\"ts\":1669220527.982766,\"logger\":\"authorino\",\"msg\":\"Starting server\",\"kind\":\"health probe\",\"addr\":\"[::]:8081\"}\n{\"level\":\"info\",\"ts\":1669220527.9829438,\"logger\":\"authorino.controller.secret\",\"msg\":\"Starting EventSource\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"source\":\"kind source: *v1.Secret\"}\n{\"level\":\"info\",\"ts\":1669220527.9829693,\"logger\":\"authorino.controller.secret\",\"msg\":\"Starting Controller\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669220527.9829714,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Starting EventSource\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\",\"source\":\"kind source: *v1beta1.AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669220527.9830208,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Starting Controller\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669220528.0834699,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Starting workers\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\",\"worker count\":1}\n{\"level\":\"info\",\"ts\":1669220528.0836608,\"logger\":\"authorino.controller.secret\",\"msg\":\"Starting workers\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"worker count\":1}\n{\"level\":\"info\",\"ts\":1669220529.041266,\"logger\":\"authorino\",\"msg\":\"starting status update manager\"}\n{\"level\":\"info\",\"ts\":1669220529.0418258,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Starting EventSource\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\",\"source\":\"kind source: *v1beta1.AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669220529.0418813,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Starting Controller\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669220529.1432905,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Starting workers\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\",\"worker count\":1}\n</code></pre> Reconciling an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"debug\",\"ts\":1669221208.7473805,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsNotLinked\",\"message\":\"No hosts linked to the resource\"},{\"type\":\"Ready\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Unknown\"}],\"summary\":{\"ready\":false,\"hostsReady\":[],\"numHostsReady\":\"0/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7496614,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7532616,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535005,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535596,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7536132,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221208.753772,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.753835,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsLinked\"},{\"type\":\"Ready\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Reconciled\"}],\"summary\":{\"ready\":true,\"hostsReady\":[\"talker-api-authorino.127.0.0.1.nip.io\"],\"numHostsReady\":\"1/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7571108,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7573664,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.757429,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586699,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586884,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7586913,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n{\"level\":\"debug\",\"ts\":1669221208.7597604,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n</code></pre> Enforcing an AuthConfig with authentication based on Kubernetes tokens:     - identity: k8s-auth, oidc, oauth2, apikey   - metadata: http, oidc userinfo   - authorization: opa, k8s-authz   - response: wristband    <pre><code>{\"level\":\"info\",\"ts\":1634830460.1486168,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1491194,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830460.150506,\"logger\":\"authorino.service.auth.authpipeline.identity.kubernetesauth\",\"msg\":\"calling kubernetes token review api\",\"request id\":\"8157480586935853928\",\"tokenreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"token\":\"eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"audiences\":[\"talker-api\"]},\"status\":{\"user\":{}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1509938,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830460.1517606,\"logger\":\"authorino.service.auth.authpipeline.identity.oauth2\",\"msg\":\"sending token introspection request\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/auth/realms/kuadrant/protocol/openid-connect/token/introspect\",\"data\":\"token=eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA&amp;token_type_hint=requesting_party_token\"}\n{\"level\":\"debug\",\"ts\":1634830460.1620777,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"}}\n{\"level\":\"debug\",\"ts\":1634830460.1622565,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/auth/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.1670353,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"8157480586935853928\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.169326,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/auth/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/auth/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830460.1753876,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"}}\n{\"level\":\"debug\",\"ts\":1634830460.2331996,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/auth/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830460.2495668,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/auth/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830460.2927864,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/auth/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830460.2930083,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"8157480586935853928\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830460.2955465,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"8157480586935853928\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"system:serviceaccount:authorino:api-consumer-1\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830460.2986183,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3044975,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3052874,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3NjAsImlhdCI6MTYzNDgzMDQ2MCwiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI4NDliMDk0ZDA4MzU0ZjM0MjA4ZGI3MjBmYWZmODlmNmM3NmYyOGY3MTcxOWI4NTQ3ZDk5NWNlNzAwMjU2ZGY4In0.Jn-VB5Q_0EX1ed1ji4KvhO4DlMqZeIl5H0qlukbTyYkp-Pgb4SnPGSbYWp5_uvG8xllsFAA5nuyBIXeba-dbkw\"}\n{\"level\":\"info\",\"ts\":1634830460.3054585,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830460.305476,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys     - identity: k8s-auth, oidc, oauth2, apikey   - metadata: http, oidc userinfo   - authorization: opa, k8s-authz   - response: wristband    <pre><code>{\"level\":\"info\",\"ts\":1634830413.2425854,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830413.2426975,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830413.2428744,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830413.2434332,\"logger\":\"authorino.service.auth.authpipeline\",\"msg\":\"skipping config\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/auth/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"context canceled\"}\n{\"level\":\"debug\",\"ts\":1634830413.2479305,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"object\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"}}\n{\"level\":\"debug\",\"ts\":1634830413.248768,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"7199257136822741594\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.2496722,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/auth/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/auth/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830413.2497928,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"7199257136822741594\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/auth/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.258932,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"}}\n{\"level\":\"debug\",\"ts\":1634830413.2945344,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/auth/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830413.3123596,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/auth/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830413.3340268,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/auth/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830413.3367748,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"7199257136822741594\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830413.339894,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3444238,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"7199257136822741594\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"john\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830413.3547812,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3558292,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3MTMsImlhdCI6MTYzNDgzMDQxMywiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI5NjhiZjViZjk3MDM3NWRiNjE0ZDFhMDgzZTg2NTBhYTVhMGVhMzAyOTdiYmJjMTBlNWVlMWZmYTkxYTYwZmY4In0.7G440sWgi2TIaxrGJf5KWR9UOFpNTjwVYeaJXFLzsLhVNICoMLbYzBAEo4M3ym1jipxxTVeE7anm4qDDc7cnVQ\"}\n{\"level\":\"info\",\"ts\":1634830413.3569078,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830413.3569596,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys (invalid API key)     - identity: k8s-auth, oidc, oauth2, apikey   - metadata: http, oidc userinfo   - authorization: opa, k8s-authz   - response: wristband    <pre><code>{\"level\":\"info\",\"ts\":1634830373.2066543,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830373.2068064,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830373,\"nanos\":198329000},\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY invalid\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"9e391846-afe4-489a-8716-23a2e1c1aa77\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830373.2070816,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-opaque\",\"ExtendedProperties\":[],\"OAuth2\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"TokenIntrospectionUrl\":\"http://keycloak:8080/auth/realms/kuadrant/protocol/openid-connect/token/introspect\",\"TokenTypeHint\":\"requesting_party_token\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.207225,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"the API Key provided is invalid\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072473,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072592,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/auth/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"info\",\"ts\":1634830373.2073083,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\"}}\n{\"level\":\"debug\",\"ts\":1634830373.2073889,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\",\"headers\":[{\"Location\":\"https://my-app.io/login\"}]}}\n</code></pre> Deleting an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"info\",\"ts\":1669221361.5032296,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221361.5057878,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n</code></pre> Shutting down the service <pre><code>{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136683,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136883,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0137057,\"logger\":\"authorino.controller.secret\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.013724,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.01375,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.013752,\"logger\":\"authorino.controller.secret\",\"msg\":\"All workers finished\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.0137632,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.013751,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137684,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137722,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.0138857,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0138955,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n{\"level\":\"info\",\"ts\":1669221635.0138893,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0139785,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n</code></pre>"},{"location":"authorino/user-guides/observability/#tracing","title":"Tracing","text":""},{"location":"authorino/user-guides/observability/#request-id","title":"Request ID","text":"<p>Processes related to the authorization request are identified and linked together by a request ID. The request ID can be: * generated outside of Authorino and passed in the authorization request \u2013 this is essentially the case of requests via GRPC authorization interface initiated by the Envoy; * generated by Authorino \u2013 requests via Raw HTTP Authorization interface.</p>"},{"location":"authorino/user-guides/observability/#propagation","title":"Propagation","text":"<p>Authorino propagates trace identifiers compatible with the W3C Trace Context format (https://www.w3.org/TR/trace-context/) and user-defined baggage data in the W3C Baggage format (https://www.w3.org/TR/baggage).</p>"},{"location":"authorino/user-guides/observability/#log-tracing","title":"Log tracing","text":"<p>Most log messages associated with an authorization request include the <code>request id</code> value. This value can be used to match incomming request and corresponding outgoing response log messages, including at deep level when more fine-grained log details are enabled (<code>debug</code> level level).</p>"},{"location":"authorino/user-guides/observability/#opentelemetry-integration","title":"OpenTelemetry integration","text":"<p>Integration with an OpenTelemetry collector can be enabled by supplying the <code>--tracing-service-endpoint</code> command-line flag (e.g. <code>authorino server --tracing-service-endpoint=http://jaeger:14268/api/traces</code>).</p> <p>The additional <code>--tracing-service-tags</code> command-line flag allow to specify fixed agent-level key-value tags for the trace signals emitted by Authorino (e.g. <code>authorino server --tracing-service-endpoint=... --tracing-service-tag=key1=value1 --tracing-service-tag=key2=value2</code>).</p> <p>Traces related to authorization requests are additionally tagged with the <code>authorino.request_id</code> attribute.</p>"},{"location":"authorino/user-guides/oidc-jwt-authentication/","title":"User guide: OpenID Connect Discovery and authentication with JWTs","text":"<p>Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> </ul>     Authorino validates JSON Web Tokens (JWT) issued by an OpenID Connect server that implements OpenID Connect Discovery. Authorino fetches the OpenID Connect configuration and JSON Web Key Set (JWKS) from the issuer endpoint, and verifies the JSON Web Signature (JWS) and time validity of the token.    _Important!_ Authorino does **not** implement [OAuth2 grants](https://datatracker.ietf.org/doc/html/rfc6749#section-4) nor [OIDC authentication flows](https://openid.net/specs/openid-connect-core-1_0.html#Authentication). As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak-kuadrant-realm\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\nEOF\n</code></pre>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#6-obtain-an-access-token-with-the-keycloak-server","title":"6. Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#7-consume-the-api","title":"7. Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid access token:</p> <pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-kuadrant-realm\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/user-guides/oidc-jwt-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/","title":"User guide: OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak","text":"<p>Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> <p>In this user guide, you will learn via example how to implement a simple Role-Based Access Control (RBAC) system to protect endpoints of an API, with roles assigned to users of an Identity Provider (Keycloak) and carried within the access tokens as JSON Web Token (JWT) claims. Users authenticate with the IdP via OAuth2/OIDC flow and get their access tokens verified and validated by Authorino on every request. Moreover, Authorino reads the role bindings of the user and enforces the proper RBAC rules based upon the context.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> </ul>     Check out as well the user guides about [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md) and [Simple pattern-matching authorization policies](./json-pattern-matching-authorization.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/oidc-rbac/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/oidc-rbac/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>In this example, the Keycloak realm defines a few users and 2 realm roles: 'member' and 'admin'. When users authenticate to the Keycloak server by any of the supported OAuth2/OIDC flows, Keycloak adds to the access token JWT a claim <code>\"realm_access\": { \"roles\": array }</code> that holds the list of roles assigned to the user. Authorino will verify the JWT on requests to the API and read from that claim to enforce the following RBAC rules:</p> Path Method Role /resources[/*] GET / POST / PUT member /resources/{id} DELETE admin /admin[/*] * member <p>Apply the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak-kuadrant-realm\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  patterns:\n    member-role:\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: member\n    admin-role:\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: admin\n  authorization:\n  # RBAC rule: 'member' role required for requests to /resources[/*]\n  - name: rbac-resources-api\n    when:\n    - selector: context.request.http.path\n      operator: matches\n      value: ^/resources(/.*)?$\n    json:\n      rules:\n      - patternRef: member-role\n  # RBAC rule: 'admin' role required for DELETE requests to /resources/{id}\n  - name: rbac-delete-resource\n    when:\n    - selector: context.request.http.path\n      operator: matches\n      value: ^/resources/\\d+$\n    - selector: context.request.http.method\n      operator: eq\n      value: DELETE\n    json:\n      rules:\n      - patternRef: admin-role\n  # RBAC rule: 'admin' role required for requests to /admin[/*]\n  - name: rbac-admin-api\n    when:\n    - selector: context.request.http.path\n      operator: matches\n      value: ^/admin(/.*)?$\n    json:\n      rules:\n      - patternRef: admin-role\nEOF\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/#6-obtain-an-access-token-and-consume-the-api","title":"6. Obtain an access token and consume the API","text":""},{"location":"authorino/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, who is asigned to the 'member' role:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-jane-memberadmin","title":"Obtain an access token and consume the API as Jane (member/admin)","text":"<p>Obtain an access token from within the cluster for the user Jane, who is asigned to the 'member' and 'admin' roles:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>As Jane, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/oidc-rbac/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-user-info/","title":"User guide: OpenID Connect UserInfo","text":"<p>Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> Authorino features in this guide: <ul> <li>External auth metadata \u2192 OIDC UserInfo</li> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> </ul>     Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline. Implementation requires an OpenID Connect issuer ([`spec.identity.oidc`](#openid-connect-oidc-jwtjose-verification-and-validation-identityoidc)) configured in the same `AuthConfig`.    Check out as well the user guide about [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/oidc-user-info/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oidc-user-info/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-user-info/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/oidc-user-info/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/oidc-user-info/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/oidc-user-info/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak-kuadrant-realm\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  metadata:\n  - name: userinfo\n    userInfo:\n      identitySource: keycloak-kuadrant-realm\n  authorization:\n  - name: active-tokens-only\n    json:\n      rules:\n      - selector: \"auth.metadata.userinfo.email\" # user email expected from the userinfo instead of the jwt\n        operator: neq\n        value: \"\"\nEOF\n</code></pre>"},{"location":"authorino/user-guides/oidc-user-info/#6-obtain-an-access-token-with-the-keycloak-server","title":"6. Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/user-guides/oidc-user-info/#7-consume-the-api","title":"7. Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/user-guides/oidc-user-info/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/","title":"User guide: Open Policy Agent (OPA) Rego policies","text":"<p>Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> Authorino features in this guide: <ul> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul>     Authorino supports [Open Policy Agent](https://www.openpolicyagent.org) policies, either inline defined in [Rego language](https://www.openpolicyagent.org/docs/latest/policy-language) as part of the `AuthConfig` or fetched from an external endpoint, such as an OPA Policy Registry.    Authorino's built-in OPA module precompiles the policies in reconciliation-time and cache them for fast evaluation in request-time, where they receive the Authorization JSON as input.    Check out as well the user guide about [Authentication with API keys](./api-key-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/opa-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/opa-authorization/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>In this example, we will use OPA to implement a read-only policy for requests coming from outside of a trusted network (IP range 192.168.1/24).</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> <p>Optional. Set <code>use_remote_address: true</code> in the Envoy route configuration, so the proxy will append its IP address instead of run in transparent mode. This setting will also ensure real remote address of the client connection passed in the <code>x-envoy-external-address</code> HTTP header, which can be used to simplify the read-only policy in remote environment.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: friends\n    apiKey:\n      selector:\n        matchLabels:\n          group: friends\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\n  authorization:\n  - name: read-only-outside\n    opa:\n      inlineRego: |\n        ips := split(input.context.request.http.headers[\"x-forwarded-for\"], \",\")\n        trusted_network { regex.match(`192\\.168\\.1\\.\\d+`, ips[0]) }\n        allow { trusted_network }\n        allow { not trusted_network; input.context.request.http.method == \"GET\" }\nEOF\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/#6-create-an-api-key","title":"6. Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/#7-consume-the-api","title":"7. Consume the API","text":"<p>Inside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 192.168.1.10' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 192.168.1.10' \\\n-X POST \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Ouside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 123.45.6.78' \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n-H 'X-Forwarded-For: 123.45.6.78' \\\n-X POST \\\nhttp://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/user-guides/opa-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/","title":"User guide: Passing credentials (<code>Authorization</code> header, cookie headers and others)","text":"<p>Customize where credentials are supplied in the request by each trusted source of identity.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Auth credentials</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul>     Authentication tokens can be supplied in the `Authorization` header, in a custom header, cookie or query string parameter.    Check out as well the user guide about [Authentication with API keys](./api-key-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/passing-credentials/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/passing-credentials/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>In this example, <code>member</code> users can authenticate supplying the API key in any of 4 different ways: - HTTP header <code>Authorization: APIKEY &lt;api-key&gt;</code> - HTTP header <code>X-API-Key: &lt;api-key&gt;</code> - Query string parameter <code>api_key=&lt;api-key&gt;</code> - Cookie <code>Cookie: APIKEY=&lt;api-key&gt;;</code></p> <p><code>admin</code> API keys are only accepted in the (default) HTTP header <code>Authorization: Bearer &lt;api-key&gt;</code>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: members-authorization-header\n    apiKey:\n      selector:\n        matchLabels:\n          group: members\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY # instead of the default prefix 'Bearer'\n  - name: members-custom-header\n    apiKey:\n      selector:\n        matchLabels:\n          group: members\n    credentials:\n      in: custom_header\n      keySelector: X-API-Key\n  - name: members-query-string-param\n    apiKey:\n      selector:\n        matchLabels:\n          group: members\n    credentials:\n      in: query\n      keySelector: api_key\n  - name: members-cookie\n    apiKey:\n      selector:\n        matchLabels:\n          group: members\n    credentials:\n      in: cookie\n      keySelector: APIKEY\n  - name: admins\n    apiKey:\n      selector:\n        matchLabels:\n          group: admins\nEOF\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/#6-create-a-couple-api-keys","title":"6. Create a couple API keys","text":"<p>For a member user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: members\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For an admin user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: admins\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/#7-consume-the-api","title":"7. Consume the API","text":"<p>As member user, passing the API key in the <code>Authorization</code> header:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the custom <code>X-API-Key</code> header:</p> <pre><code>curl -H 'X-API-Key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the query string parameter <code>api_key</code>:</p> <pre><code>curl \"http://talker-api-authorino.127.0.0.1.nip.io:8000/hello?api_key=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\"\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the <code>APIKEY</code> cookie header:</p> <pre><code>curl -H 'Cookie: APIKEY=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx;foo=bar' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As admin user:</p> <pre><code>curl -H 'Authorization: Bearer 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api-authorino.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Missing the API key:</p> <pre><code>curl http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"members-authorization-header\"\n# www-authenticate: X-API-Key realm=\"members-custom-header\"\n# www-authenticate: api_key realm=\"members-query-string-param\"\n# www-authenticate: APIKEY realm=\"members-cookie\"\n# www-authenticate: Bearer realm=\"admins\"\n# x-ext-auth-reason: {\"admins\":\"credential not found\",\"members-authorization-header\":\"credential not found\",\"members-cookie\":\"credential not found\",\"members-custom-header\":\"credential not found\",\"members-query-string-param\":\"credential not found\"}\n</code></pre>"},{"location":"authorino/user-guides/passing-credentials/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/","title":"User guide: Resource-level authorization with User-Managed Access (UMA) resource registry","text":"<p>Fetch resource metadata relevant for your authorization policies from Keycloak authorization clients, unsing User-Managed Access (UMA) protocol.</p> Authorino features in this guide: <ul> <li>External auth metadata \u2192 User-Managed Access (UMA) resource registry</li> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul>     Check out as well the user guides about [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md) and [Open Policy Agent (OPA) Rego policies](./opa-authorization.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>This user guide's implementation for resource-level authorization leverages part of Keycloak's User-Managed Access (UMA) support. Authorino will fetch resource attributes stored in a Keycloak resource server client.</p> <p>The Keycloak server also provides the identities. The <code>sub</code> claim of the Keycloak-issued ID tokens must match the owner of the requested resource, identitfied by the URI of the request.</p> <p>Create a required secret, used by Authorino to start the authentication with the UMA registry.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: talker-api-uma-credentials\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak-kuadrant-realm\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  metadata:\n  - name: resource-data\n    uma:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n      credentialsRef:\n        name: talker-api-uma-credentials\n  authorization:\n  - name: owned-resources\n    opa:\n      inlineRego: |\n        COLLECTIONS = [\"greetings\"]\n        http_request = input.context.request.http\n        http_method = http_request.method\n        requested_path_sections = split(trim_left(trim_right(http_request.path, \"/\"), \"/\"), \"/\")\n        get { http_method == \"GET\" }\n        post { http_method == \"POST\" }\n        put { http_method == \"PUT\" }\n        delete { http_method == \"DELETE\" }\n        valid_collection { COLLECTIONS[_] == requested_path_sections[0] }\n        collection_endpoint {\n          valid_collection\n          count(requested_path_sections) == 1\n        }\n        resource_endpoint {\n          valid_collection\n          some resource_id\n          requested_path_sections[1] = resource_id\n        }\n        identity_owns_the_resource {\n          identity := input.auth.identity\n          resource_attrs := object.get(input.auth.metadata, \"resource-data\", [])[0]\n          resource_owner := object.get(object.get(resource_attrs, \"owner\", {}), \"id\", \"\")\n          resource_owner == identity.sub\n        }\n        allow { get;    collection_endpoint }\n        allow { post;   collection_endpoint }\n        allow { get;    resource_endpoint; identity_owns_the_resource }\n        allow { put;    resource_endpoint; identity_owns_the_resource }\n        allow { delete; resource_endpoint; identity_owns_the_resource }\nEOF\n</code></pre> <p>The OPA policy <code>owned-resource</code> above enforces that all users can send GET and POST requests to <code>/greetings</code>, while only resource owners can send GET, PUT and DELETE requests to <code>/greetings/{resource-id}</code>.</p>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#6-obtain-access-tokens-with-the-keycloak-server-and-consume-the-api","title":"6. Obtain access tokens with the Keycloak server and consume the API","text":""},{"location":"authorino/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-john-and-consume-the-api","title":"Obtain an access token as John and consume the API","text":"<p>Obtain an access token for user John (owner of the resource <code>/greetings/1</code> in the UMA registry):</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-jane-and-consume-the-api","title":"Obtain an access token as Jane and consume the API","text":"<p>Obtain an access token for user Jane (owner of the resource <code>/greetings/2</code> in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/2\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-peter-and-consume-the-api","title":"Obtain an access token as Peter and consume the API","text":"<p>Obtain an access token for user Peter (does not own any resource in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/user-guides/resource-level-authorization-uma/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/talker-api-uma-credentials\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/sharding/","title":"User guide: Reducing the operational space","text":"<p>By default, Authorino will watch events related to all <code>AuthConfig</code> custom resources in the reconciliation space (namespace or entire cluster). Instances can be configured though to only watch a subset of the resources, thus allowing such as: - to reduce noise and lower memory usage inside instances meant for restricted scope (e.g. Authorino deployed as a dedicated sidecar to protect only one host); - sharding auth config data across multiple instances; - multiple environments (e.g. staging, production) inside of a same cluster/namespace; - providing managed instances of Authorino that all watch CRs cluster-wide, yet dedicated to organizations allowed to create and operate their own <code>AuthConfig</code>s across multiple namespaces.</p> Authorino features in this guide: <ul> <li>Sharding</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul>     Check out as well the user guide about [Authentication with API keys](./api-key-authentication.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/sharding/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre>"},{"location":"authorino/user-guides/sharding/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/sharding/#2-deploy-a-couple-instances-of-authorino","title":"2. Deploy a couple instances of Authorino","text":"<p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=staging</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-staging\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=staging\n  secretLabelSelectors: authorino/environment=staging\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=production</code>, ans NOT labeled <code>disabled</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-production\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=production,!disabled\n  secretLabelSelectors: authorino/environment=production,!disabled\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The commands above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>cluster-wide</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/sharding/#3-create-a-namespace-for-user-resources","title":"3. Create a namespace for user resources","text":"<pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/user-guides/sharding/#4-create-authconfigs-and-api-key-secrets-for-both-instances","title":"4. Create <code>AuthConfig</code>s and API key <code>Secret</code>s for both instances","text":""},{"location":"authorino/user-guides/sharding/#create-resources-for-authorino-staging","title":"Create resources for <code>authorino-staging</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: auth-config-1\n  labels:\n    authorino/environment: staging\nspec:\n  hosts:\n  - my-host.staging.io\n  identity:\n  - name: api-key\n    apiKey:\n      selector:\n        matchLabels:\n          authorino/api-key: \"true\"\n          authorino/environment: staging\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: staging\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-staging</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-staging -o name)\n# {\"level\":\"info\",\"ts\":1638382989.8327162,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638382989.837424,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638383144.9486837,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-1\"}\n</code></pre>"},{"location":"authorino/user-guides/sharding/#create-resources-for-authorino-production","title":"Create resources for <code>authorino-production</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: auth-config-2\n  labels:\n    authorino/environment: production\nspec:\n  hosts:\n  - my-host.io\n  identity:\n  - name: api-key\n    apiKey:\n      selector:\n        matchLabels:\n          authorino/api-key: \"true\"\n          authorino/environment: production\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: production\nstringData:\n  api_key: MUWdeBte7AbSWxl6CcvYNJ+3yEIm5CaL\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-production</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383423.86086,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383423.8608105,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383460.3515081,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-2\"}\n</code></pre>"},{"location":"authorino/user-guides/sharding/#9-remove-a-resource-from-scope","title":"9. Remove a resource from scope","text":"<pre><code>kubectl -n myapp label authconfig/auth-config-2 disabled=true\n# authconfig.authorino.kuadrant.io/auth-config-2 labeled\n</code></pre> <p>Verify in the logs that only the <code>authorino-production</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383515.6428752,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-2\"}\n</code></pre>"},{"location":"authorino/user-guides/sharding/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authorino/authorino-staging\nkubectl delete authorino/authorino-production\nkubectl delete namespace myapp\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/","title":"User guide: Token normalization","text":"<p>Broadly, the term token normalization in authentication systems usually implies the exchange of an authentication token, as provided by the user in a given format, and/or its associated identity claims, for another freshly issued token/set of claims, of a given (normalized) structure or format.</p> <p>The most typical use-case for token normalization envolves accepting tokens issued by multiple trusted sources and of often varied authentication protocols, while ensuring that the eventual different data structures adopted by each of those sources are normalized, thus allowing to simplify policies and authorization checks that depend on those values. In general, however, any modification to the identity claims can be for the purpose of normalization.</p> <p>This user guide focuses on the aspect of mutation of the identity claims resolved from an authentication token, to a certain data format and/or by extending them, so that required attributes can thereafter be trusted to be present among the claims, in a desired form. For such, Authorino allows to extend resolved identity objects with custom attributes (custom claims) of either static values or with values fetched from the Authorization JSON.</p> <p>For not only normalizing the identity claims for purpose of writing simpler authorization checks and policies, but also getting Authorino to issue a new token in a normalized format, check the Festival Wristband tokens feature.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 OpenID Connect (OIDC) JWT/JOSE verification and validation</li> <li>Authorization \u2192 JSON pattern-matching authorization rules</li> </ul>     Check out as well the user guides about [Authentication with API keys](./api-key-authentication.md), [OpenID Connect Discovery and authentication with JWTs](./oidc-jwt-authentication.md) and [Simple pattern-matching authorization policies](./user-guides/json-pattern-matching-authorization.md).    For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/token-normalization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#2-deploy-the-talker-api","title":"2. Deploy the Talker API","text":"<p>The Talker API is just an echo API, included in the Authorino examples. We will use it in this guide as the service to be protected with Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#3-deploy-authorino","title":"3. Deploy Authorino","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>namespaced</code> reconciliation mode, and with TLS termination disabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/token-normalization/#4-setup-envoy","title":"4. Setup Envoy","text":"<p>The following bundle from the Authorino examples (manifest referred in the command below) is to apply Envoy configuration and deploy Envoy proxy, that wire up the Talker API behind the reverse-proxy and external authorization with the Authorino instance.</p> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. For a simpler and straighforward way to manage an API, without having to manually install or configure Envoy and Authorino, check out Kuadrant.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The bundle also creates an <code>Ingress</code> with host name <code>talker-api-authorino.127.0.0.1.nip.io</code>, but if you are using a local Kubernetes cluster created with Kind, you need to forward requests on port 8000 to inside the cluster in order to actually reach the Envoy service:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#5-create-the-authconfig","title":"5. Create the <code>AuthConfig</code>","text":"<p>This example implements a policy that only users bound to the <code>admin</code> role can send <code>DELETE</code> requests.</p> <p>The config trusts access tokens issued by a Keycloak realm as well as API keys labeled specifically to a selected group (<code>friends</code>). The roles of the identities handled by Keycloak are managed in Keycloak, as realm roles. Particularly, users <code>john</code> and <code>peter</code> are bound to the <code>member</code> role, while user <code>jane</code> is bound to roles <code>member</code> and <code>admin</code>. As for the users authenticating with API key, they are all bound to the <code>admin</code> role.</p> <p>Without normalizing identity claims from these two different sources, the policy would have to handle the differences of data formats with additional ifs-and-elses. Instead, the config here uses the <code>identity.extendedProperties</code> option to ensure a custom <code>roles</code> (Array) claim is always present in the identity object. In the case of Keycloak ID tokens, the value is extracted from the <code>realm_access.roles</code> claim; for API key-resolved objects, the custom claim is set to the static value <code>[\"admin\"]</code>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n  - talker-api-authorino.127.0.0.1.nip.io\n  identity:\n  - name: keycloak-kuadrant-realm\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n    extendedProperties:\n    - name: roles\n      valueFrom:\n        authJSON: auth.identity.realm_access.roles\n  - name: api-key-friends\n    apiKey:\n      selector:\n        matchLabels:\n          group: friends\n    credentials:\n      in: authorization_header\n      keySelector: APIKEY\n    extendedProperties:\n    - name: roles\n      value: [\"admin\"]\n  authorization:\n  - name: only-admins-can-delete\n    when:\n    - selector: context.request.http.method\n      operator: eq\n      value: DELETE\n    json:\n      rules:\n      - selector: auth.identity.roles\n        operator: incl\n        value: admin\nEOF\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#6-create-an-api-key","title":"6. Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#7-consume-the-api","title":"7. Consume the API","text":""},{"location":"authorino/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>If otherwise your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>Consume the API as Jane:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' | jq -r .access_token)\n</code></pre> <p>Consume the API as John:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#consume-the-api-using-the-api-key-to-authenticate-admin","title":"Consume the API using the API key to authenticate (admin)","text":"<pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" -X DELETE http://talker-api-authorino.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/user-guides/token-normalization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/","title":"User guide: Using Authorino as ValidatingWebhook service","text":"<p>Authorino provides an interface for raw HTTP external authorization requests. This interface can be used for integrations other than the typical Envoy gRPC protocol, such as (though not limited to) using Authorino as a generic Kubernetes ValidatingWebhook service.</p> <p>The rules to validate a request to the Kubernetes API \u2013 typically a <code>POST</code>, <code>PUT</code> or <code>DELETE</code> request targeting a particular Kubernetes resource or collection \u2013, according to which either the change will be deemed accepted or not, are written in an Authorino <code>AuthConfig</code> custom resource. Authentication and authorization are performed by the Kubernetes API server as usual, with auth features of Authorino implementing the aditional validation within the scope of an <code>AdmissionReview</code> request.</p> <p>This user guide provides an example of using Authorino as a Kubernetes ValidatingWebhook service that validates requests to <code>CREATE</code> and <code>UPDATE</code> Authorino <code>AuthConfig</code> resources. In other words, we will use Authorino as a validator inside the cluster that decides what is a valid AuthConfig for any application which wants to rely on Authorino to protect itself.</p> <p>The AuthConfig to validate other AuthConfigs will enforce the following rules: - Authorino features that cannot be used by any application in their security schemes:   - Anonymous Access   - Plain identity object extracted from context   - Kubernetes authentication (TokenReview)   - Kubernetes authorization (SubjectAccessReview)   - Festival Wristband tokens - Authorino features that require a RoleBinding to a specific ClusterRole in the 'authorino' namespace, to be used in a AuthConfig:   - Authorino API key authentication - All metadata pulled from external sources must be cached for precisely 5 minutes (300 seconds)</p> <p>For convinience, the same instance of Authorino used to enforce the AuthConfig associated with the validating webhook will also be targeted for the sample AuthConfigs created to test the validation. For using different instances of Authorino for the validating webhook and for protecting applications behind a proxy, check out the section about sharding in the docs. There is also a user guide on the topic, with concrete examples.</p> Authorino features in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Common feature \u2192 Conditions</li> <li>Common feature \u2192 Priorities</li> </ul>     For further details about Authorino features in general, check the [docs](./../features.md).  <p></p>"},{"location":"authorino/user-guides/validating-webhook/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server</li> <li>cert-manager</li> <li>Auth server / Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> </ul> <p>Create a containerized Kubernetes server locally using Kind:</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Install cert-manager:</p> <pre><code>kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.4.0/cert-manager.yaml\n</code></pre> <p>Deploy a Keycloak server preloaded with all the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#1-install-the-authorino-operator","title":"1. Install the Authorino Operator","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#2-deploy-authorino","title":"2. Deploy Authorino","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace authorino\n</code></pre> <p>Create the TLS certificates:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre> <p>Create the Authorino instance:</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    ports:\n      grpc: 50051\n      http: 5001 # for admissionreview requests sent by the kubernetes api server\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre> <p>The command above will deploy Authorino as a separate service (as oposed to a sidecar of the protected API and other architectures), in <code>cluster-wide</code> reconciliation mode, and with TLS termination enabled. For other variants and deployment options, check out the Getting Started section of the docs, the Architecture page, and the spec for the <code>Authorino</code> CRD in the Authorino Operator repo.</p>"},{"location":"authorino/user-guides/validating-webhook/#3-create-the-authconfig-and-related-clusterrole","title":"3. Create the <code>AuthConfig</code> and related <code>ClusterRole</code>","text":"<p>Create the <code>AuthConfig</code>:</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: authconfig-validator\nspec:\n  # admissionreview requests will be sent to this host name\n  hosts:\n  - authorino-authorino-authorization.authorino.svc\n  # because we're using a single authorino instance for the validating webhook and to protect the user applications,\n  # skip operations related to this one authconfig in the 'authorino' namespace\n  when:\n  - selector: context.request.http.body.@fromstr|request.object.metadata.namespace\n    operator: neq\n    value: authorino\n  # kubernetes admissionreviews carry info about the authenticated user\n  identity:\n  - name: k8s-userinfo\n    plain:\n      authJSON: context.request.http.body.@fromstr|request.userInfo\n  authorization:\n  - name: features\n    opa:\n      inlineRego: |\n        authconfig = json.unmarshal(input.context.request.http.body).request.object\n        forbidden { count(object.get(authconfig.spec, \"identity\", [])) == 0 }\n        forbidden { authconfig.spec.identity[_].anonymous }\n        forbidden { authconfig.spec.identity[_].kubernetes }\n        forbidden { authconfig.spec.identity[_].plain }\n        forbidden { authconfig.spec.authorization[_].kubernetes }\n        forbidden { authconfig.spec.response[_].wristband }\n        apiKey { authconfig.spec.identity[_].apiKey }\n        allow { count(authconfig.spec.identity) &gt; 0; not forbidden }\n      allValues: true\n  - name: apikey-authn-requires-k8s-role-binding\n    priority: 1\n    when:\n    - selector: auth.authorization.features.apiKey\n      operator: eq\n      value: \"true\"\n    kubernetes:\n      user:\n        valueFrom: { authJSON: auth.identity.username }\n      resourceAttributes:\n        namespace: { value: authorino }\n        group: { value: authorino.kuadrant.io }\n        resource: { value: authconfigs-with-apikeys }\n        verb: { value: create }\n  - name: metadata-cache-ttl\n    priority: 1\n    opa:\n      inlineRego: |\n        invalid_ttl = input.auth.authorization.features.authconfig.spec.metadata[_].cache.ttl != 300\n        allow { not invalid_ttl }\nEOF\n</code></pre> <p>Define a <code>ClusterRole</code> to control the usage of protected features of Authorino:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: authorino-apikey\nrules:\n- apiGroups: [\"authorino.kuadrant.io\"]\n  resources: [\"authconfigs-with-apikeys\"] # not a real k8s resource\n  verbs: [\"create\"]\nEOF\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#4-create-the-validatingwebhookconfiguration","title":"4. Create the <code>ValidatingWebhookConfiguration</code>","text":"<pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: authconfig-authz\n  annotations:\n    cert-manager.io/inject-ca-from: authorino/authorino-ca-cert\nwebhooks:\n- name: check-authconfig.authorino.kuadrant.io\n  clientConfig:\n    service:\n      namespace: authorino\n      name: authorino-authorino-authorization\n      port: 5001\n      path: /check\n  rules:\n  - apiGroups: [\"authorino.kuadrant.io\"]\n    apiVersions: [\"v1beta1\"]\n    resources: [\"authconfigs\"]\n    operations: [\"CREATE\", \"UPDATE\"]\n    scope: Namespaced\n  sideEffects: None\n  admissionReviewVersions: [\"v1\"]\nEOF\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#5-try-it-out","title":"5. Try it out","text":"<p>Create a namespace:</p> <pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#with-a-valid-authconfig","title":"With a valid <code>AuthConfig</code>","text":"<pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: keycloak\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection created\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#with-forbidden-features","title":"With forbidden features","text":"<p>Anonymous access:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"identity\":null}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: anonymous-access\n    anonymous: {}\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"identity\\\":[{\\\"anonymous\\\":{},\\\"name\\\":\\\"anonymous-access\\\"}]}}\\n\"}},\"spec\":{\"identity\":[{\"anonymous\":{},\"name\":\"anonymous-access\"}]}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kuberentes TokenReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: k8s-tokenreview\n    kubernetes:\n      audiences: [\"myapp\"]\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"identity\\\":[{\\\"kubernetes\\\":{\\\"audiences\\\":[\\\"myapp\\\"]},\\\"name\\\":\\\"k8s-tokenreview\\\"}]}}\\n\"}},\"spec\":{\"identity\":[{\"kubernetes\":{\"audiences\":[\"myapp\"]},\"name\":\"k8s-tokenreview\"}]}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Plain identity extracted from context:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: envoy-jwt-authn\n    plain:\n      authJSON: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"identity\\\":[{\\\"name\\\":\\\"envoy-jwt-authn\\\",\\\"plain\\\":{\\\"authJSON\\\":\\\"context.metadata_context.filter_metadata.envoy\\\\\\\\.filters\\\\\\\\.http\\\\\\\\.jwt_authn|verified_jwt\\\"}}]}}\\n\"}},\"spec\":{\"identity\":[{\"name\":\"envoy-jwt-authn\",\"plain\":{\"authJSON\":\"context.metadata_context.filter_metadata.envoy\\\\.filters\\\\.http\\\\.jwt_authn|verified_jwt\"}}]}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kubernetes SubjectAccessReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: keycloak\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  authorization:\n  - name: k8s-subjectaccessreview\n    kubernetes:\n      user:\n        valueFrom: { authJSON: auth.identity.sub }\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authorization\\\":[{\\\"kubernetes\\\":{\\\"user\\\":{\\\"valueFrom\\\":{\\\"authJSON\\\":\\\"auth.identity.sub\\\"}}},\\\"name\\\":\\\"k8s-subjectaccessreview\\\"}],\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"identity\\\":[{\\\"name\\\":\\\"keycloak\\\",\\\"oidc\\\":{\\\"endpoint\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\\\"}}]}}\\n\"}},\"spec\":{\"authorization\":[{\"kubernetes\":{\"user\":{\"valueFrom\":{\"authJSON\":\"auth.identity.sub\"}}},\"name\":\"k8s-subjectaccessreview\"}],\"identity\":[{\"name\":\"keycloak\",\"oidc\":{\"endpoint\":\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\"}}]}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Festival Wristband tokens:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\n---\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: keycloak\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  response:\n  - name: wristband\n    wristband:\n      issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\n      signingKeyRefs:\n      - algorithm: ES256\n        name: wristband-signing-key\nEOF\n# secret/wristband-signing-key created\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"identity\\\":[{\\\"name\\\":\\\"keycloak\\\",\\\"oidc\\\":{\\\"endpoint\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\\\"}}],\\\"response\\\":[{\\\"name\\\":\\\"wristband\\\",\\\"wristband\\\":{\\\"issuer\\\":\\\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\\\",\\\"signingKeyRefs\\\":[{\\\"algorithm\\\":\\\"ES256\\\",\\\"name\\\":\\\"wristband-signing-key\\\"}]}}]}}\\n\"}},\"spec\":{\"identity\":[{\"name\":\"keycloak\",\"oidc\":{\"endpoint\":\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\"}}],\"response\":[{\"name\":\"wristband\",\"wristband\":{\"issuer\":\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\",\"signingKeyRefs\":[{\"algorithm\":\"ES256\",\"name\":\"wristband-signing-key\"}]}}]}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#with-features-that-require-additional-permissions","title":"With features that require additional permissions","text":"<p>Before adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: api-key\n    apiKey:\n      selector:\n        matchLabels: { app: myapp }\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"identity\\\":[{\\\"apiKey\\\":{\\\"selector\\\":{\\\"matchLabels\\\":{\\\"app\\\":\\\"myapp\\\"}}},\\\"name\\\":\\\"api-key\\\"}]}}\\n\"}},\"spec\":{\"identity\":[{\"apiKey\":{\"selector\":{\"matchLabels\":{\"app\":\"myapp\"}}},\"name\":\"api-key\"}]}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Not authorized: unknown reason\n</code></pre> <p>Add the required permissions:</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: authorino-apikey\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: authorino-apikey\nsubjects:\n- kind: User\n  name: kubernetes-admin\nEOF\n# rolebinding.rbac.authorization.k8s.io/authorino-apikey created\n</code></pre> <p>After adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: api-key\n    apiKey:\n      selector:\n        matchLabels: { app: myapp }\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#with-features-that-require-specific-property-validation","title":"With features that require specific property validation","text":"<p>Invalid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: keycloak\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  metadata:\n  - name: external-source\n    http:\n      endpoint: http://metadata.io\n      method: GET\n    cache:\n      key: { value: global }\n      ttl: 60\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta1\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"identity\\\":[{\\\"name\\\":\\\"keycloak\\\",\\\"oidc\\\":{\\\"endpoint\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\\\"}}],\\\"metadata\\\":[{\\\"cache\\\":{\\\"key\\\":{\\\"value\\\":\\\"global\\\"},\\\"ttl\\\":60},\\\"http\\\":{\\\"endpoint\\\":\\\"http://metadata.io\\\",\\\"method\\\":\\\"GET\\\"},\\\"name\\\":\\\"external-source\\\"}]}}\\n\"}},\"spec\":{\"identity\":[{\"name\":\"keycloak\",\"oidc\":{\"endpoint\":\"http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\"}}],\"metadata\":[{\"cache\":{\"key\":{\"value\":\"global\"},\"ttl\":60},\"http\":{\"endpoint\":\"http://metadata.io\",\"method\":\"GET\"},\"name\":\"external-source\"}]}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta1, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta1, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Valid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta1\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n  - myapp.io\n  identity:\n  - name: keycloak\n    oidc:\n      endpoint: http://keycloak.keycloak.svc.cluster.local:8080/auth/realms/kuadrant\n  metadata:\n  - name: external-source\n    http:\n      endpoint: http://metadata.io\n      method: GET\n    cache:\n      key: { value: global }\n      ttl: 300\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/user-guides/validating-webhook/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace myapp\nkubectl delete namespace authorino\nkubectl delete namespace clusterrole/authorino-apikey\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre>"},{"location":"authorino-operator/","title":"Authorino Operator","text":"<p>A Kubernetes Operator to manage Authorino instances.</p> <p></p>"},{"location":"authorino-operator/#installation","title":"Installation","text":"<p>The Operator can be installed by applying the manifests to the Kubernetes cluster or using Operator Lifecycle Manager (OLM)</p>"},{"location":"authorino-operator/#applying-the-manifests-to-the-cluster","title":"Applying the manifests to the cluster","text":"<ol> <li>Create the namespace for the Operator</li> </ol> <pre><code>kubectl create namespace authorino-operator\n</code></pre> <ol> <li>Install the Operator manifests</li> </ol> <pre><code>make install\n</code></pre> <ol> <li>Deploy the Operator</li> </ol> <pre><code>make deploy\n</code></pre> Tip: Deploy a custom image of the Operator    To deploy an image of the Operator other than the default <code>quay.io/kuadrant/authorino-operator:latest</code>, specify by setting the <code>OPERATOR_IMAGE</code> parameter. E.g.:    <pre><code>make deploy OPERATOR_IMAGE=authorino-operator:local\n</code></pre>"},{"location":"authorino-operator/#installing-via-olm","title":"Installing via OLM","text":"<p>To install the Operator using the Operator Lifecycle Manager, you need to make the Operator CSVs available in the cluster by creating a <code>CatalogSource</code> resource.</p> <p>The bundle and catalog images of the Operator are available in Quay.io:</p> Bundle quay.io/kuadrant/authorino-operator-bundle Catalog quay.io/kuadrant/authorino-operator-catalog <ol> <li>Create the namespace for the Operator</li> </ol> <pre><code>kubectl create namespace authorino-operator\n</code></pre> <ol> <li>Create the CatalogSource resource pointing to one of the images from in the Operator's catalog repo:</li> </ol> <pre><code>kubectl -n authorino-operator apply -f -&lt;&lt;EOF\napiVersion: operators.coreos.com/v1alpha1\nkind: CatalogSource\nmetadata:\n  name: operatorhubio-catalog\n  namespace: authorino-operator\nspec:\n  sourceType: grpc\n  image: quay.io/kuadrant/authorino-operator-catalog:latest\n  displayName: Authorino Operator\nEOF\n</code></pre>"},{"location":"authorino-operator/#requesting-an-authorino-instance","title":"Requesting an Authorino instance","text":"<p>Once the Operator is up and running, you can request instances of Authorino by creating <code>Authorino</code> CRs. E.g.:</p> <pre><code>kubectl -n myapi apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino-operator/#the-authorino-custom-resource-definition-crd","title":"The <code>Authorino</code> Custom Resource Definition (CRD)","text":"<p>API to install, manage and configure Authorino authorization services .</p> <p>Each <code>Authorino</code> Custom Resource (CR) represents an instance of Authorino deployed to the cluster. The Authorino Operator will reconcile the state of the Kubernetes Deployment and associated resources, based on the state of the CR.</p>"},{"location":"authorino-operator/#api-specification","title":"API Specification","text":"Field Type Description Required/Default spec AuthorinoSpec Specification of the Authorino deployment. Required"},{"location":"authorino-operator/#authorinospec","title":"AuthorinoSpec","text":"Field Type Description Required/Default clusterWide Boolean Sets the Authorino instance's watching scope \u2013 cluster-wide or namespaced. Default: <code>true</code> (cluster-wide) authConfigLabelSelectors String Label selectors used by the Authorino instance to filter <code>AuthConfig</code>-related reconciliation events. Default: empty (all AuthConfigs are watched) secretLabelSelectors String Label selectors used by the Authorino instance to filter <code>Secret</code>-related reconciliation events (API key and mTLS authentication methods). Default: <code>authorino.kuadrant.io/managed-by=authorino</code> replicas Integer Number of replicas desired for the Authorino instance. Values greater than 1 enable leader election in the Authorino service, where the leader updates the statuses of the <code>AuthConfig</code> CRs). Default: 1 evaluatorCacheSize Integer Cache size (in megabytes) of each Authorino evaluator (when enabled in an <code>AuthConfig</code>). Default: 1 image String Authorino image to be deployed (for dev/testing purpose only). Default: <code>quay.io/kuadrant/authorino:latest</code> imagePullPolicy String Sets the imagePullPolicy of the Authorino Deployment (for dev/testing purpose only). Default: k8s default logLevel String Defines the level of log you want to enable in Authorino (<code>debug</code>, <code>info</code> and <code>error</code>). Default: <code>info</code> logMode String Defines the log mode in Authorino (<code>development</code> or <code>production</code>). Default: <code>production</code> listener Listener Specification of the authorization service (gRPC interface). Required oidcServer OIDCServer Specification of the OIDC service. Required tracing Tracing Configuration of the OpenTelemetry tracing exporter. Optional metrics Metrics Configuration of the metrics server (port, level). Optional healthz Healthz Configuration of the health/readiness probe (port). Optional volumes VolumesSpec Additional volumes to be mounted in the Authorino pods. Optional"},{"location":"authorino-operator/#listener","title":"Listener","text":"<p>Configuration of the authorization server \u2013 gRPC and raw HTTP interfaces</p> Field Type Description Required/Default port Integer Port number of authorization server (gRPC interface). DEPRECATEDUse <code>ports</code> instead ports Ports Port numbers of the authorization server (gRPC and raw HTTPinterfaces). Optional tls TLS TLS configuration of the authorization server (GRPC and HTTP interfaces). Required timeout Integer Timeout of external authorization request (in milliseconds), controlled internally by the authorization server. Default: <code>0</code> (disabled)"},{"location":"authorino-operator/#oidcserver","title":"OIDCServer","text":"<p>Configuration of the OIDC Discovery server for Festival Wristband tokens.</p> Field Type Description Required/Default port Integer Port number of OIDC Discovery server for Festival Wristband tokens. Default: <code>8083</code> tls TLS TLS configuration of the OIDC Discovery server for Festival Wristband tokens Required"},{"location":"authorino-operator/#tls","title":"TLS","text":"<p>TLS configuration of server. Appears in <code>listener</code> and <code>oidcServer</code>.</p> Field Type Description Required/Default enabled Boolean Whether TLS is enabled or disabled for the server. Default: <code>true</code> certSecretRef LocalObjectReference The reference to the secret that contains the TLS certificates <code>tls.crt</code> and <code>tls.key</code>. Required when <code>enabled: true</code>"},{"location":"authorino-operator/#ports","title":"Ports","text":"<p>Port numbers of the authorization server.</p> Field Type Description Required/Default grpc Integer Port number of the gRPC interface of the authorization server. Set to 0 to disable this interface. Default: <code>50001</code> http Integer Port number of the raw HTTP interface of the authorization server. Set to 0 to disable this interface. Default: <code>5001</code>"},{"location":"authorino-operator/#tracing","title":"Tracing","text":"<p>Configuration of the OpenTelemetry tracing exporter.</p> Field Type Description Required/Default endpoint String Full endpoint of the OpenTelemetry tracing collector service (e.g. http://jaeger:14268/api/traces). Required tags Map Key-value map of fixed tags to add to all OpenTelemetry traces emitted by Authorino. Optional"},{"location":"authorino-operator/#metrics","title":"Metrics","text":"<p>Configuration of the metrics server.</p> Field Type Description Required/Default port Integer Port number of the metrics server. Default: <code>8080</code> deep Boolean Enable/disable metrics at the level of each evaluator config (if requested in the <code>AuthConfig</code>) exported by the metrics server. Default: <code>false</code>"},{"location":"authorino-operator/#healthz","title":"Healthz","text":"<p>Configuration of the health/readiness probe (port).</p> Field Type Description Required/Default port Integer Port number of the health/readiness probe. Default: <code>8081</code>"},{"location":"authorino-operator/#volumesspec","title":"VolumesSpec","text":"<p>Additional volumes to project in the Authorino pods. Useful for validation of TLS self-signed certificates of external services known to have to be contacted by Authorino at runtime.</p> Field Type Description Required/Default items []VolumeSpec List of additional volume items to project. Optional defaultMode Integer Mode bits used to set permissions on the files. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. Optional"},{"location":"authorino-operator/#volumespec","title":"VolumeSpec","text":"Field Type Description Required/Default name String Name of the volume and volume mount within the Deployment. It must be unique in the CR. Optional mountPath String Absolute path where to mount all the items. Required configMaps []String List of of Kubernetes ConfigMap names to mount. Required exactly one of: <code>confiMaps</code>, <code>secrets</code>. secrets []String List of of Kubernetes Secret names to mount. Required exactly one of: <code>confiMaps</code>, <code>secrets</code>. items []KeyToPath Mount details for selecting specific ConfigMap or Secret entries. Optional"},{"location":"authorino-operator/#full-example","title":"Full example","text":"<pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\nname: authorino\nspec:\nclusterWide: true\nauthConfigLabelSelectors: environment=production\nsecretLabelSelectors: authorino.kuadrant.io/component=authorino,environment=production\nreplicas: 2\nevaluatorCacheSize: 2 # mb\nimage: quay.io/kuadrant/authorino:latest\nimagePullPolicy: Always\nlogLevel: debug\nlogMode: production\nlistener:\nports:\ngrpc: 50001\nhttp: 5001\ntls:\nenabled: true\ncertSecretRef:\nname: authorino-server-cert # secret must contain `tls.crt` and `tls.key` entries\noidcServer:\nport: 8083\ntls:\nenabled: true\ncertSecretRef:\nname: authorino-oidc-server-cert # secret must contain `tls.crt` and `tls.key` entries\nmetrics:\nport: 8080\ndeep: true\nvolumes:\nitems:\n- name: keycloak-tls-cert\nmountPath: /etc/ssl/certs\nconfigMaps:\n- keycloak-tls-cert\nitems: # details to mount the k8s configmap in the authorino pods\n- key: keycloak.crt\npath: keycloak.crt\ndefaultMode: 420\n</code></pre>"},{"location":"limitador/","title":"Limitador","text":"<p>Limitador is a generic rate-limiter written in Rust. It can be used as a library, or as a service. The service exposes HTTP endpoints to apply and observe limits. Limitador can be used with Envoy because it also exposes a grpc service, on a different port, that implements the Envoy Rate Limit protocol (v3).</p> <ul> <li>Getting started</li> <li>How it works</li> <li>Development</li> <li>Testing Environment</li> <li>Kubernetes</li> <li>License</li> </ul> <p>Limitador is under active development, and its API has not been stabilized yet.</p>"},{"location":"limitador/#getting-started","title":"Getting started","text":"<ul> <li>Rust library</li> <li>Server</li> </ul>"},{"location":"limitador/#rust-library","title":"Rust library","text":"<p>Add this to your <code>Cargo.toml</code>: <pre><code>[dependencies]\nlimitador = { version = \"0.3.0\" }\n</code></pre></p> <p>For more information, see the <code>README</code> of the crate</p>"},{"location":"limitador/#server","title":"Server","text":"<p>Run with Docker (replace <code>latest</code> with the version you want): <pre><code>docker run --rm --net=host -it quay.io/kuadrant/limitador:v1.0.0\n</code></pre></p> <p>Run locally: <pre><code>cargo run --release --bin limitador-server -- --help\n</code></pre></p> <p>Refer to the help message on how to start up the server. More information are available in the server's <code>README.md</code></p>"},{"location":"limitador/#development","title":"Development","text":""},{"location":"limitador/#build","title":"Build","text":"<pre><code>cargo build\n</code></pre>"},{"location":"limitador/#run-the-tests","title":"Run the tests","text":"<p>Some tests need a redis deployed in <code>localhost:6379</code>. You can run it in Docker with: <pre><code>docker run --rm -p 6379:6379 -it redis\n</code></pre></p> <p>Some tests need a infinispan deployed in <code>localhost:11222</code>. You can run it in Docker with: <pre><code>docker run --rm -p 11222:11222 -it -e USER=username -e PASS=password infinispan/server:11.0.9.Final\n</code></pre></p> <p>Then, run the tests:</p> <pre><code>cargo test --all-features\n</code></pre> <p>or you can run tests disabling the \"redis storage\" feature: <pre><code>cd limitador; cargo test --no-default-features\n</code></pre></p>"},{"location":"limitador/#license","title":"License","text":"<p>Apache 2.0 License</p>"},{"location":"limitador/how-it-works/","title":"How it works","text":""},{"location":"limitador/how-it-works/#how-it-works","title":"How it works","text":"<p>Limitador ensures that the most restrictive limit configuration will apply.</p> <p>Limitador will try to match each incoming descriptor with the same namespaced counter's conditions and variables. The namespace for the descriptors is defined by the <code>domain</code> field whereas for the rate limit configuration the <code>namespace</code> field is being used. For each matching counter, the counter is increased and the limits checked.</p> <p>One example to illustrate:</p> <p>Let's say we have 1 rate limit configuration (one counter per config):</p> <pre><code>conditions: [\"KEY_A == 'VALUE_A'\"]\nmax_value: 1\nseconds: 60\nvariables: []\nnamespace: example.org\n</code></pre> <p>Limitador receives one descriptor with two entries:</p> <pre><code>domain: example.org\ndescriptors:\n- entries:\n- KEY_A: VALUE_A\n- OTHER_KEY: OTHER_VALUE\n</code></pre> <p>The counter's condition will match. Then, the counter will be increased and the limit checked. If the limit is exceeded, the request will be rejected with <code>429 Too Many Requests</code>, otherwise accepted.</p> <p>Note that the counter is being activated even though it does not match all the entries of the descriptor. The same rule applies for the variables field.</p> <p>Currently, the implementation of condition only allow for equal (<code>==</code>) and not equal (<code>!=</code>) operators. More operators will be implemented based off the use cases for them.</p> <p>The variables field is a list of keys. The matching rule is defined just as the existence of the list of descriptor entries with the same key values. If variables is <code>variables: [A, B, C]</code>, one descriptor matches if it has at least three entries with the same A, B, C keys.</p> <p>Few examples to illustrate.</p> <p>Having the following descriptors:</p> <pre><code>domain: example.org\ndescriptors:\n- entries:\n- KEY_A: VALUE_A\n- OTHER_KEY: OTHER_VALUE\n</code></pre> <p>the following counters would not be activated.</p> <p><pre><code>conditions: [\"KEY_B == 'VALUE_B'\"]\nmax_value: 1\nseconds: 60\nvariables: []\nnamespace: example.org\n</code></pre> Reason: conditions key does not exist</p> <p><pre><code>conditions:\n- \"KEY_A == 'VALUE_A'\"\n- \"OTHER_KEY == 'WRONG_VALUE'\"\nmax_value: 1\nseconds: 60\nvariables: []\nnamespace: example.org\n</code></pre> Reason: not all the conditions match</p> <p><pre><code>conditions: []\nmax_value: 1\nseconds: 60\nvariables: [\"MY_VAR\"]\nnamespace: example.org\n</code></pre> Reason: the variable name does not exist</p> <p><pre><code>conditions: [\"KEY_B == 'VALUE_B'\"]\nmax_value: 1\nseconds: 60\nvariables: [\"MY_VAR\"]\nnamespace: example.org\n</code></pre> Reason: Both variables and conditions must match. In this particular case, only conditions match</p>"},{"location":"limitador/topologies/","title":"Deployment topologies","text":""},{"location":"limitador/topologies/#in-memory","title":"In-memory","text":""},{"location":"limitador/topologies/#redis","title":"Redis","text":""},{"location":"limitador/topologies/#redis-active-active-storage","title":"Redis active-active storage","text":"<p>The RedisLabs version of Redis supports active-active replication. Limitador is compatible with that deployment mode, but there are a few things to take into account regarding limit accuracy.</p>"},{"location":"limitador/topologies/#considerations","title":"Considerations","text":"<p>With an active-active deployment, the data needs to be replicated between instances. An update in an instance takes a short time to be reflected in the other. That time lag depends mainly on the network speed between the Redis instances, and it affects the accuracy of the rate-limiting performed by Limitador because it can go over limits while the updates of the counters are being replicated.</p> <p>The impact of that greatly depends on the use case. With limits of a few seconds, and a low number of hits, we could easily go over limits. On the other hand, if we have defined limits with a high number of hits and a long period, the effect will be basically negligible. For example, if we define a limit of one hour, and we know that the data takes around one second to be replicated, the accuracy loss is going to be negligible.</p>"},{"location":"limitador/topologies/#set-up","title":"Set up","text":"<p>In order to try active-active replication, you can follow this tutorial from RedisLabs.</p>"},{"location":"limitador/limitador/","title":"Limitador (library)","text":"<p>An embeddable rate-limiter library supporting in-memory, Redis and Infinispan data stores. Limitador can also be compiled to WebAssembly.</p> <p>For the complete documentation of the crate's API, please refer to docs.rs</p>"},{"location":"limitador/limitador/#features","title":"Features","text":"<ul> <li><code>redis_storage</code>: support for using Redis as the data storage backend.</li> <li><code>infinispan_storage</code>: support for using Infinispan as the data storage backend.</li> <li><code>lenient_conditions</code>: support for the deprecated syntax of <code>Condition</code>s</li> <li><code>default</code>: <code>redis_storage</code>.</li> </ul>"},{"location":"limitador/limitador/#webassembly-support","title":"WebAssembly support","text":"<p>To use Limitador in a project that compiles to WASM, there are some features that need to be disabled. Add this to your <code>Cargo.toml</code> instead:</p> <pre><code>[dependencies]\nlimitador = { version = \"0.3.0\", default-features = false }\n</code></pre>"},{"location":"limitador/limitador-server/","title":"Limitador (server)","text":"<p>By default, Limitador starts the HTTP server in <code>localhost:8080</code> and the grpc service that implements the Envoy Rate Limit protocol in <code>localhost:8081</code>. That can be configured with these ENVs: <code>ENVOY_RLS_HOST</code>, <code>ENVOY_RLS_PORT</code>, <code>HTTP_API_HOST</code>, and <code>HTTP_API_PORT</code>.</p> <p>Or using the command line arguments:</p> <pre><code>Limitador Server\nThe Kuadrant team - github.com/Kuadrant\nRate Limiting Server\n\nUSAGE:\n    limitador-server [OPTIONS] &lt;LIMITS_FILE&gt; [STORAGE]\n\nARGS:\n    &lt;LIMITS_FILE&gt;    The limit file to use\n\nOPTIONS:\n    -b, --rls-ip &lt;ip&gt;\n            The IP to listen on for RLS [default: 0.0.0.0]\n\n    -p, --rls-port &lt;port&gt;\n            The port to listen on for RLS [default: 8081]\n\n    -B, --http-ip &lt;http_ip&gt;\n            The IP to listen on for HTTP [default: 0.0.0.0]\n\n    -P, --http-port &lt;http_port&gt;\n            The port to listen on for HTTP [default: 8080]\n\n    -l, --limit-name-in-labels\n            Include the Limit Name in prometheus label\n\n    -v\n            Sets the level of verbosity\n\n        --validate\n            Validates the LIMITS_FILE and exits\n\n    -H, --rate-limit-headers &lt;rate_limit_headers&gt;\n            Enables rate limit response headers [default: NONE] [possible values: NONE,\n            DRAFT_VERSION_03]\n\n    -h, --help\n            Print help information\n\n    -V, --version\n            Print version information\n\nSTORAGES:\n    memory          Counters are held in Limitador (ephemeral)\n    redis           Uses Redis to store counters\n    redis_cached    Uses Redis to store counters, with an in-memory cache\n</code></pre> <p>When using environment variables, these will override the defaults. While environment variable are themselves overridden by the command line arguments provided. See the individual <code>STORAGES</code> help for more options relative to each of the storages.</p> <p>The OpenAPI spec of the HTTP service is here.</p> <p>Limitador has to be started with a YAML file that has some limits defined. There's an example file that allows 10 requests per minute and per <code>user_id</code> when the HTTP method is <code>\"GET\"</code> and 5 when it is a <code>\"POST\"</code>. You can run it with Docker (replace <code>latest</code> with the version you want): <pre><code>docker run --rm --net=host -it -v $(pwd)/examples/limits.yaml:/home/limitador/my_limits.yaml:ro quay.io/kuadrant/limitador:latest limitador-server /home/limitador/my_limits.yaml\n</code></pre></p> <p>You can also use the YAML file when running locally: <pre><code>cargo run --release --bin limitador-server ./examples/limits.yaml\n</code></pre></p> <p>If you want to use Limitador with Envoy, there's a minimal Envoy config for testing purposes here. The config forwards the \"userid\" header and the request method to Limitador. It assumes that there's an upstream API deployed on port 1323. You can use echo, for example.</p> <p>Limitador has several options that can be configured via ENV. This doc specifies them.</p>"},{"location":"limitador/limitador-server/#limits-storage","title":"Limits storage","text":"<p>Limitador can store its limits and counters in-memory or in Redis. In-memory is faster, but the limits are applied per instance. When using Redis, multiple instances of Limitador can share the same limits, but it's slower.</p>"},{"location":"limitador/limitador-server/kubernetes/","title":"Index","text":""},{"location":"limitador/limitador-server/kubernetes/#kubernetes","title":"Kubernetes","text":"<p>The purpose of this documentation is to deploy a sample application published via AWS ELB, that will be ratelimited at infrastructure level, thanks to the use the envoyproxy sidecar container, that will be in charge of contacting to a  ratelimit service (limitador), that will allow the request (or not) if it is within the permitted  limits.</p> <p>There are mainly two recommended way of using limitador in kubernetes: 1. There is an ingress based on envoyproxy that contacts with limitador ratelimit service before forwarding (or not) the request to the application 1. There is an envoyproxy sidecar container living in the application pod that contacts with limitador ratelimit service before forwarding (or not) the request to the main application container in the same pod</p> <p>In this example it will be described the second scenario (where there is an application with an envoyproxy sidecar container contacting to limitador service).</p> <p>NOTE  If you don't want to manually manage the sidecar container definitions on your deployments (harcoding the container spec, loading the envoy configuration from a configmap that requires a pod restart to reload possibles configuration changes...), you can use marin3r, a light weight envoy control plane that allows you to inject envoyproxy sidecar containers and dynamically consume configs from Kubernetes custom resources.</p> <p>This is the network diagram of the deployed example:</p> <p></p>"},{"location":"limitador/limitador-server/kubernetes/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Components</li> <li>Mandatory</li> <li>Optional</li> <li>K8s deployment</li> <li>Monitoring</li> <li>Prometheus</li> <li>Grafana dashboard</li> <li>Benchmarking</li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#components","title":"Components","text":"<p>In order to that that ratelimit test, you need to deploy a few components. Some of them are mandatory, and a few are optional:</p>"},{"location":"limitador/limitador-server/kubernetes/#mandatory","title":"Mandatory","text":"<ul> <li>Application (a sample application deployment called <code>kuard</code>):</li> <li>App has an <code>envoyproxy</code> sidecar container with its configuration file in a configmap, composed by:<ul> <li>Cluster <code>kuard</code> points to main application container (<code>127.0.0.1:8080</code>)</li> <li>Cluster <code>kuard_ratelimit</code> points to limitador headless service (<code>limitador:8081</code>)</li> <li>Listener HTTP points to envoyproxy sidecar (<code>0.0.0.0:38080</code>)</li> <li>When envoy contacts with the ratelimit service, you can define a timeout, and if there is no response within that timeout (because ratelimit is overloaded taking more time to process the request, or because rateliit service is down), you can choose from envoy to deny the request or pass it to the application. In this case, there is set a 1s timeout, and if there is no answer in this 1 second, request is passed to the application (<code>failure_mode_deny: false</code>), so we guarantee that the maximum overhead added by a non working ratelimit service is 1 extra second to the final response time.</li> </ul> </li> <li> <p>App service published with <code>type: LoadBalancer</code>, which creates a AWS ELB. This service has an annotation to enable proxy protocol on the AWS Load balancer in order to be able to keep the real client IP at envoy level (instead of the k8s node private IP), so it can be used to ratelimit per each real client IP if desired.</p> </li> <li> <p>Ratelimit application (a deployment called <code>limitador</code>):</p> </li> <li>Limitador Configmap with limits definition (1000 rps per hostname).</li> <li> <p>Limitador headless service published on <code>limitador:8081</code>. It is important to use a headless service in order to balance correctly the traffic between limitador pods, otherwise GRPC connections are not well balanced.</p> </li> <li> <p>Redis database to persist ratelimit configuration:</p> </li> <li>Redis service</li> <li>Redis statefulset with a persistent volume</li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#optional","title":"Optional","text":"<ul> <li>Centos pod:</li> <li>Used to executed <code>hey</code> tool benchmarks from the cluster, so we ensure network latency does not affect the results. Actually, to achieve better results, this pod should be on another cluster (to not share the network between client and network) and be placed on the same Region (to reduce latency). The client could be a bottle neck for the performance test.</li> <li>This centos is going to public AWS ELB to access the app, so simulating it is a normal client from the same Region</li> <li>Prometheus monitoring and grafana dashboard resources</li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#k8s-deployment","title":"K8s deployment","text":"<ul> <li> <p>Deploy the redis instance that will keep the limits for different limitador pods: <pre><code>kubectl apply -f redis-service.yaml\nkubectl apply -f redis-statefulset.yaml\n</code></pre></p> </li> <li> <p>Deploy limitador application. It is important to create the configmap with limitador limits before the deployment, in order to load it from limitador pods. At the moment, if you update the limits configmap you need to restart the pods. Additionally, limitador has an API in order to load limits dynamically, but for simplicity for this test a configmap has been used: <pre><code>kubectl apply -f limitador-config-configmap.yaml\nkubectl apply -f limitador-service.yaml\nkubectl apply -f limitador-deployment.yaml\n</code></pre></p> </li> <li> <p>Deploy sample kuard application with the envoyproxy sidecar container (if you do any change on the envoy configmap, remember you need to restart app pods in order to reload the config): <pre><code>kubectl apply -f kuard-envoy-config-configmap.yaml\nkubectl apply -f kuard-service.yaml\nkubectl apply -f kuard-deployment.yaml\n</code></pre></p> </li> <li> <p>At this point you shoud see all pods running, and kuard pods should have 2 containers (the main  kuard container, and the envoyproxy sidecar container): <pre><code>\u25b6 kubectl get pods\nNAME                         READY   STATUS    RESTARTS   AGE\nkuard-f859bb896-gmzxn        2/2     Running   0          7m\nkuard-f859bb896-z95w8        2/2     Running   0          7m\nlimitador-68d494f54c-qv996   1/1     Running   0          8m\nlimitador-68d494f54c-zzmhn   1/1     Running   0          8m\nredis-0                      1/1     Running   0          9m\n</code></pre></p> </li> <li> <p>Now you should be able to access to kuard application using the load balancer DNS name: <pre><code>\u25b6 kubectl get service kuard\nNAME    TYPE           CLUSTER-IP       EXTERNAL-IP                                                              PORT(S)        AGE\nkuard   LoadBalancer   172.30.117.198   a96d5449fbc3f4cd892e15e5b36cde48-457963259.us-east-1.elb.amazonaws.com   80:31450/TCP   4m\n</code></pre></p> </li> <li> <p>If you go to the browser and paste the <code>EXTERNAL-IP</code>, your request will follow the next workflow:</p> </li> <li>The requests will go from your local machine through internet to the public AWS ELB where the app is published</li> <li>Then it will go to the <code>NodePort</code> of your k8s cluster nodes</li> <li>Once on a k8s node, it will go to kuard <code>Service</code> Virtual IP, and will arrive to an envoyproxy sidecar container inside kuard pod</li> <li>Envoyproxy sidecar container will contact with limitador headless <code>Service</code>, to authorize the requests or not:<ul> <li>If the request is authorized (within the configured limits), it will send the request to the app container (<code>0.0.0.0:8080</code>) in the same pod, and request will end up with a <code>HTTP 200</code> response</li> <li>If the request is limited (beyond the limits), request will end up with <code>HTTP 429</code> response</li> </ul> </li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#monitoring","title":"Monitoring","text":"<p>Both <code>envoyproxy</code> sidecar and <code>limitador</code> applications include built-in prometheus metrics.</p>"},{"location":"limitador/limitador-server/kubernetes/#prometheus","title":"Prometheus","text":"<p>In order to scrape that metrics within a prometheus-operator deployed in the cluster, you need to create a <code>PodMonitor</code> resource for every application: <pre><code>kubectl apply -f kuard-podmonitor.yaml\nkubectl apply -f limitador-podmonitor.yaml\n</code></pre></p>"},{"location":"limitador/limitador-server/kubernetes/#grafana-dashboard","title":"Grafana dashboard","text":"<p>Then, if you have grafana deployed in the cluster, you can import a Kuadrant Limitador grafana dashboard that we have prepared, which includes: - Kuard envoyproxy sidecar metrics (globally and per pod) - Limitador metrics (globally and per pod) - And for every deployed component (limitador, kuard, redis):   - Number of pods (total, available, unavaible, pod restarts...)   - CPU usage per pod   - Memory usage per pod   - Network usage per pod</p>"},{"location":"limitador/limitador-server/kubernetes/#benchmarking","title":"Benchmarking","text":"<ul> <li>In order to check that the ratelimit is working as expected, you can use any benchmarking tool, like hey</li> <li>You can use if you want a centos pod (better to create it on a different custer within the same Region): <pre><code>kubectl apply -f centos-pod.yaml\n</code></pre></li> <li>Connect to centos pod: <pre><code>kubectl exec --stdin --tty centos -- /bin/bash\n</code></pre></li> <li>And install <code>hey</code> with: <pre><code>[root@centos /]# curl -sf https://gobinaries.com/rakyll/hey | sh\n</code></pre></li> <li>Now you can execute the benchmark using the following escenario:</li> </ul> Item Value Target AWS ELB DNS Name App pods 2 Limitador pods 2 Limits 1.000 rps per hostname Hey duration 1 minute Hey Traffic -c 60 -q 20 (around 1.200 rps) <ul> <li>Theoretically:</li> <li>It should let pass 1.000 requests, and limit 200 requests per second</li> <li>It should let pass 60 * 1.000 = 60.0000 requests, and limit 60 * 200 = 12.000 requests per minute</li> <li>Each limitador pod should handle half of the traffic (500 rps OK, and 200 rps limited)</li> </ul> <p><pre><code>[root@centos /]# hey -z 60s -c 60 -q 20 \"http://a96d5449fbc3f4cd892e15e5b36cde48-457963259.us-east-1.elb.amazonaws.com\"\nSummary:\n  Total:    60.0131 secs\n  Slowest:  0.1028 secs\n  Fastest:  0.0023 secs\n  Average:  0.0075 secs\n  Requests/sec: 1199.3721\n\nTotal data:   106581650 bytes\n  Size/request: 1480 bytes\n\nResponse time histogram:\n  0.002 [1] |\n0.012 [70626] |\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\n  0.022 [1291]  |\u25a0\n  0.032 [0] |\n0.043 [0] |\n0.053 [0] |\n0.063 [0] |\n0.073 [0] |\n0.083 [0] |\n0.093 [23]    |\n0.103 [37]    |\nLatency distribution:\n  10% in 0.0053 secs\n  25% in 0.0063 secs\n  50% in 0.0073 secs\n  75% in 0.0085 secs\n  90% in 0.0096 secs\n  95% in 0.0102 secs\n  99% in 0.0139 secs\n\nDetails (average, fastest, slowest):\n  DNS+dialup:   0.0001 secs, 0.0023 secs, 0.1028 secs\n  DNS-lookup:   0.0001 secs, 0.0000 secs, 0.0711 secs\n  req write:    0.0000 secs, 0.0000 secs, 0.0014 secs\n  resp wait:    0.0074 secs, 0.0023 secs, 0.0303 secs\n  resp read:    0.0000 secs, 0.0000 secs, 0.0049 secs\n\nStatus code distribution:\n  [200] 60046 responses\n  [429] 11932 responses\n</code></pre> * We can see that:   - Client could send 1192.2171rps (about 1200rps)   - 60046 requests (about 60000) were OK (HTTP 200)   - 11932 requests (about 12000) were limited (HTTP 429)   - Average latency (since the request goes out from the client to AWS ELB, k8s node, envoyproxy container, limitador+redis, kuar app container) is 10ms</p> <ul> <li>In addition, if we do a longer test with 5 minutes traffic for example, you can check with the grafana dashboard how these requests are processed by envoyproxy sidecar container of kuard pods and limitador pods:</li> <li>Kuard Envoyproxy Sidecar Metrics:<ul> <li>Globally it handles around 1200rps: it permits around 1krps and limits around 200rps  </li> <li>Each envoyproxy sidecar of each kuard pod handles around half of the traffic: it permits around 500rps and limits around 100rps. The balance between pods is not 100% perfect, caused by random iptables forwarding when using a k8s service  </li> </ul> </li> <li>Limitador Metrics:<ul> <li>Globally it handles around 1200rps: it permits around 1krps and limits around 200rps  </li> <li>Each limitador pod handles around half of the traffic: it permits around 500rps and limits around 100rps. The balance between pods is perfect thanks to using a headless service with GRPC connections  </li> </ul> </li> </ul>"},{"location":"limitador/limitador-server/vendor/protobufs/","title":"Vendored protobuf definitions","text":"<p>This directory contains the protobufs definitions needed to build the GRPC server that implements the Envoy Rate Limit Service protocol. These files are used from the build script (<code>build.rs</code>). The Envoy protobuf definitions have several dependencies both in the \"data-plane-api\" repository and external ones.</p> <p>What I did was clone the 3 repos needed, keep only the .proto files, and remove all the empty directories. Keeping the directory structure is needed to make things work.</p> <p>This solution is not ideal, but I have not found a better way to import proto definitions and all their dependencies.</p> <p>Here are the repos and the revisions:</p> <ul> <li>https://github.com/envoyproxy/data-plane-api.git 863f431e56cecb1114a122eb467db7739b5df154</li> <li>https://github.com/envoyproxy/protoc-gen-validate.git 7898287a95aefb07aeff95f5f17b8d422d4a5ded</li> <li>https://github.com/cncf/xds.git 4a2b9fdd466b16721f8c058d7cadf5a54e229d66</li> </ul> <p>My first solution was to do the clone and the filtering in the build.rs. However, that does not really work because it means that we need to download dependencies at build time, which is not supported by docs.rs.</p>"},{"location":"limitador/limitador-server/vendor/protobufs/#deprecated-udpa-definitions","title":"Deprecated UDPA definitions","text":"<p>The UDPA repository has been replaced by the XDS one, but some definitions still reference UDPA. When you update the XDS repository, take into account that you must move the UDPA definitions around to ensure the code generation picks them up.</p>"},{"location":"limitador/migrations/conditions/","title":"New condition syntax","text":"<p>With <code>limitador-server</code> version <code>1.0.0</code> (and the <code>limitador</code> crate version <code>0.3.0</code>), the syntax for <code>condition</code>s within  <code>limit</code> definitions has changed.</p>"},{"location":"limitador/migrations/conditions/#changes","title":"Changes","text":""},{"location":"limitador/migrations/conditions/#the-new-syntax","title":"The new syntax","text":"<p>The new syntax formalizes what part of an expression is the identifier and which is the value to test against.  Identifiers are simple string value, while string literals are to be demarcated by single quotes (<code>'</code>) or double quotes (<code>\"</code>) so that <code>foo == \" bar\"</code> now makes it explicit that the value is to be prefixed with a space character.</p> <p>A few remarks:  - Only <code>string</code> values are supported, as that's what they really are  - There is no escape character sequence supported in string literals  - A new operator has been added, <code>!=</code></p>"},{"location":"limitador/migrations/conditions/#the-issue-with-the-deprecated-syntax","title":"The issue with the deprecated syntax","text":"<p>The previous syntax wouldn't differentiate between values and the identifier, so that <code>foo == bar</code> was valid. In this case <code>foo</code> was the identifier of the variable, while <code>bar</code> was the value to evaluate it against. Whitespaces before and after the operator <code>==</code> would be equally important. SO that <code>foo  ==  bar</code> would test for a <code>foo</code> variable being equal to <code>bar</code> where the trailing whitespace after the identifier, and the one prefixing the value, would have been evaluated.</p>"},{"location":"limitador/migrations/conditions/#server-binary-users","title":"Server binary users","text":"<p>The server still allows for the deprecated syntax, but warns about its usage. You can easily migrate your limits file,  using the following command:</p> <pre><code>limitador-server --validate old_limits.yaml &gt; updated_limits.yaml\n</code></pre> <p>Which should output <code>Deprecated syntax for conditions corrected!</code> to <code>stderr</code> while <code>stdout</code> would be the limits using  the new syntax. It is recommended you manually verify the resulting <code>LIMITS_FILE</code>.</p>"},{"location":"limitador/migrations/conditions/#crate-users","title":"Crate users","text":"<p>A feature <code>lenient_conditions</code> has been added, which lets you use the syntax used in previous version of the crate. The function <code>limitador::limit::check_deprecated_syntax_usages_and_reset()</code> lets you verify if the deprecated syntax  has been used as <code>limit::Limit</code>s are created with their condition strings using the deprecated syntax.</p>"},{"location":"limitador/server/configuration/","title":"Limitador configuration","text":""},{"location":"limitador/server/configuration/#command-line-configuration","title":"Command line configuration","text":"<p>The preferred way of starting and configuring the Limitador server is using the command line:</p> <pre><code>USAGE:\n    limitador-server [OPTIONS] &lt;LIMITS_FILE&gt; [STORAGE]\n\nARGS:\n    &lt;LIMITS_FILE&gt;    The limit file to use\n\nOPTIONS:\n    -b, --rls-ip &lt;ip&gt;\n            The IP to listen on for RLS [default: 0.0.0.0]\n\n    -p, --rls-port &lt;port&gt;\n            The port to listen on for RLS [default: 8081]\n\n    -B, --http-ip &lt;http_ip&gt;\n            The IP to listen on for HTTP [default: 0.0.0.0]\n\n    -P, --http-port &lt;http_port&gt;\n            The port to listen on for HTTP [default: 8080]\n\n    -l, --limit-name-in-labels\n            Include the Limit Name in prometheus label\n\n    -v\n            Sets the level of verbosity\n\n        --validate\n            Validates the LIMITS_FILE and exits\n\n    -H, --rate-limit-headers &lt;rate_limit_headers&gt;\n            Enables rate limit response headers [default: NONE] [possible values: NONE,\n            DRAFT_VERSION_03]\n\n    -h, --help\n            Print help information\n\n    -V, --version\n            Print version information\n\nSTORAGES:\n    memory          Counters are held in Limitador (ephemeral)\n    redis           Uses Redis to store counters\n    redis_cached    Uses Redis to store counters, with an in-memory cache\n</code></pre> <p>The values used are authoritative over any environment variables independently set.</p>"},{"location":"limitador/server/configuration/#limit-definitions","title":"Limit definitions","text":"<p>The <code>LIMITS_FILE</code> provided is the source of truth for all the limits that will be enforced. The file location will be  monitored by the server for any changes and be hot reloaded. If the changes are invalid, they will be ignored on hot reload, or the server will fail to start. </p>"},{"location":"limitador/server/configuration/#the-limits_files-format","title":"The <code>LIMITS_FILE</code>'s format","text":"<p>When starting the server, you point it to a <code>LIMITS_FILE</code>, which is expected to be a yaml file with an array of <code>limit</code> definitions, with the following format:</p> <pre><code>---\n\"$schema\": http://json-schema.org/draft-04/schema#\ntype: object\nproperties:\nname:\ntype: string\nnamespace:\ntype: string\nseconds:\ntype: integer\nmax_value:\ntype: integer\nconditions:\ntype: array\nitems:\n- type: string\nvariables:\ntype: array\nitems:\n- type: string\nrequired:\n- namespace\n- seconds\n- max_value\n- conditions\n- variables\n</code></pre> <p>Here is an example of such a limit definition:</p> <pre><code>namespace: example.org\nmax_value: 10\nseconds: 60\nconditions:\n- \"req.method == 'GET'\"\nvariables:\n- user_id\n</code></pre> <ul> <li><code>namespace</code> namespaces the limit, will generally be the domain, see here</li> <li><code>seconds</code> is the duration for which the limit applies, in seconds: e.g. <code>60</code> is a span of time of one minute</li> <li><code>max_value</code> is the actual limit, e.g. <code>100</code> would limit to 100 requests</li> <li><code>name</code> lets the user optionally name the limit</li> <li><code>variables</code> is an array of variables, which once resolved, will be used to qualify counters for the limit,     e.g. <code>api_key</code> to limit per api keys</li> <li><code>conditions</code> is an array of conditions, which once evaluated will decide whether to apply the limit or not</li> </ul>"},{"location":"limitador/server/configuration/#condition-syntax","title":"<code>condition</code> syntax","text":"<p>Each <code>condition</code> is an expression producing a boolean value (<code>true</code> or <code>false</code>). All <code>conditions</code> must evaluate to  <code>true</code> for the <code>limit</code> to be applied on a request. </p> <p>Expressions follow the following syntax: <code>$IDENTIFIER $OP $STRING_LITERAL</code>, where: </p> <ul> <li><code>$IDENTIFIER</code> will be used to resolve the value at evaluation time, e.g. <code>role</code></li> <li><code>$OP</code> is an operator, either <code>==</code> or <code>!=</code></li> <li><code>$STRING_LITERAL</code> is a literal string value, <code>\"</code> or <code>'</code> demarcated, e.g. <code>\"admin\"</code></li> </ul> <p>So that <code>role != \"admin\"</code> would apply the limit on request from all users, but <code>admin</code>'s.</p>"},{"location":"limitador/server/configuration/#counter-storages","title":"Counter storages","text":"<p>Limitador will load all the <code>limit</code> definitions from the <code>LIMITS_FILE</code> and keep these in memory. To enforce these  limits, Limitador needs to track requests in the form of counters. There would be at least one counter per limit, but  that number grows when <code>variables</code> are used to qualify counters per some arbitrary values.  </p>"},{"location":"limitador/server/configuration/#memory","title":"<code>memory</code>","text":"<p>As the name implies, Limitador will keep all counters in memory. This yields the best results in terms of latency as  well as accuracy. By default, only up to <code>1000</code> \"concurrent\" counters will be kept around, evicting the oldest entries. \"Concurrent\" in this context means counters that need to exist at the \"same time\", based of the period of the limit,  as \"expired\" counters are discarded.</p> <p>This storage is ephemeral, as if the process is restarted, all the counters are lost and effectively \"reset\" all the  limits as if no traffic had been rate limited, which can be fine for short-lived limits, less for longer-lived ones.</p>"},{"location":"limitador/server/configuration/#redis","title":"<code>redis</code>","text":"<p>When you want persistence of your counters, such as for disaster recovery or across restarts, using <code>redis</code> will store  the counters in a redis instance using the provided <code>URL</code>. Increments to individual counters is made within redis  itself, providing accuracy over these, races tho can occur when multiple Limitador servers are used against a single  redis and using \"stacked\" limits (i.e. over different periods). Latency is also impacted, as it results in one  additional hop to talk to redis and maintain the counters.</p>"},{"location":"limitador/server/configuration/#redis_cached","title":"<code>redis_cached</code>","text":"<p>In order to avoid some communication overhead to redis, <code>redis_cached</code> adds an in memory caching layer within the  Limitador servers. This lowers the latency, but sacrifices some accuracy as it will not only cache counters, but also coalesce counters updates to redis over time. See this configuration option for more  information.</p> <p>For an in-depth coverage of the different topologies supported and how they affect the behavior, see the  topologies' document.</p>"},{"location":"limitador/server/configuration/#infinispan-optional-storage-experimental","title":"<code>infinispan</code> optional storage - experimental","text":"<p>The default binary will not support Infinispan as a storage backend for counters. If you  want to give it a try, you would need to build your own binary of the server using:</p> <pre><code>cargo build --release --features=infinispan\n</code></pre> <p>Which will add the <code>infinispan</code> to the supported <code>STORAGES</code>. </p> <pre><code>USAGE:\n    limitador-server &lt;LIMITS_FILE&gt; infinispan [OPTIONS] &lt;URL&gt;\n\nARGS:\n    &lt;URL&gt;    Infinispan URL to use\n\nOPTIONS:\n    -n, --cache-name &lt;cache name&gt;      Name of the cache to store counters in [default: limitador]\n    -c, --consistency &lt;consistency&gt;    The consistency to use to read from the cache [default:\n                                       Strong] [possible values: Strong, Weak]\n    -h, --help                         Print help information\n</code></pre>"},{"location":"limitador/server/configuration/#configuration-using-environment-variables","title":"Configuration using environment variables","text":"<p>The Limitador server has some options that can be configured with environment variables. These will override the  default values the server uses. Any argument used when starting the server will prevail over the  environment variables.</p>"},{"location":"limitador/server/configuration/#envoy_rls_host","title":"<code>ENVOY_RLS_HOST</code>","text":"<ul> <li>Host where the Envoy RLS server listens.</li> <li>Optional. Defaults to <code>\"0.0.0.0\"</code>.</li> <li>Format: <code>string</code>.</li> </ul>"},{"location":"limitador/server/configuration/#envoy_rls_port","title":"<code>ENVOY_RLS_PORT</code>","text":"<ul> <li>Port where the Envoy RLS server listens.</li> <li>Optional. Defaults to <code>8081</code>.</li> <li>Format: <code>integer</code>.</li> </ul>"},{"location":"limitador/server/configuration/#http_api_host","title":"<code>HTTP_API_HOST</code>","text":"<ul> <li>Host where the HTTP server listens.</li> <li>Optional. Defaults to <code>\"0.0.0.0\"</code>.</li> <li>Format: <code>string</code>.</li> </ul>"},{"location":"limitador/server/configuration/#http_api_port","title":"<code>HTTP_API_PORT</code>","text":"<ul> <li>Port where the HTTP API listens.</li> <li>Optional. Defaults to <code>8080</code>.</li> <li>Format: <code>integer</code>.</li> </ul>"},{"location":"limitador/server/configuration/#limits_file","title":"<code>LIMITS_FILE</code>","text":"<ul> <li>YAML file that contains the limits to create when Limitador boots. If the limits specified already have counters associated, Limitador will not delete them. Changes to the file will be picked up by the running server.</li> <li>Required. No default</li> <li>Format: <code>string</code>, file path.</li> </ul>"},{"location":"limitador/server/configuration/#limit_name_in_prometheus_labels","title":"<code>LIMIT_NAME_IN_PROMETHEUS_LABELS</code>","text":"<ul> <li>Enables using limit names as labels in Prometheus metrics. This is disabled by default because for a few limits it should be fine, but it could become a problem when defining lots of limits. See the caution note in the Prometheus docs</li> <li>Optional. Disabled by default.</li> <li>Format: <code>bool</code>, set to <code>\"1\"</code> to enable.</li> </ul>"},{"location":"limitador/server/configuration/#redis_local_cache_enabled","title":"<code>REDIS_LOCAL_CACHE_ENABLED</code>","text":"<ul> <li>Enables a storage implementation that uses Redis, but also caches some data in memory. The idea is to improve throughput and latencies by caching the counters in memory to reduce the number of accesses to Redis. To achieve that, this mode sacrifices some rate-limit accuracy. This mode does two things:<ul> <li>Batches counter updates. Instead of updating the counters on every request, it updates them in memory and commits them to Redis in batches. The flushing interval can be configured with the <code>REDIS_LOCAL_CACHE_FLUSHING_PERIOD_MS</code> env. The trade-off is that when running several instances of Limitador, other instances will not become aware of the counter updates until they're committed to Redis.</li> <li>Caches counters. Instead of fetching the value of a counter every time it's needed, the value is cached for a configurable period. The trade-off is that when running several instances of Limitador, an instance will not become aware of the counter updates other instances do while the value is cached. When a counter is already at 0 (limit exceeded), it's cached until it expires in Redis. In this case, no matter what other instances do, we know that the quota will not be reestablished until the key expires in Redis, so in this case, rate-limit accuracy is not affected. When a counter has still some quota remaining the situation is different, that's why we can tune for how long it will be cached. The formula is as follows: MIN(ttl_in_redis/<code>REDIS_LOCAL_CACHE_TTL_RATIO_CACHED_COUNTERS</code>, <code>REDIS_LOCAL_CACHE_MAX_TTL_CACHED_COUNTERS_MS</code>). For example, let's image that the current TTL (time remaining until the limit resets) in Redis for a counter is 10 seconds, and we set the ratio to 2, and the max time for 30s. In this case, the counter will be cached for 5s (min(10/2, 30)). During those 5s, Limitador will not fetch the value of that counter from Redis, so it will answer faster, but it will also miss the updates done by other instances, so it can go over the limits in that 5s interval.</li> </ul> </li> <li>Optional. Disabled by default.</li> <li>Format: set to \"1\" to enable.</li> <li>Note: \"REDIS_URL\" needs to be set.</li> </ul>"},{"location":"limitador/server/configuration/#redis_local_cache_flushing_period_ms","title":"<code>REDIS_LOCAL_CACHE_FLUSHING_PERIOD_MS</code>","text":"<ul> <li>Used to configure the local cache when using Redis. See <code>REDIS_LOCAL_CACHE_ENABLED</code>. This env only applies when <code>\"REDIS_LOCAL_CACHE_ENABLED\" == 1</code>.</li> <li>Optional. Defaults to <code>1000</code>.</li> <li>Format: <code>integer</code>. Duration in milliseconds.</li> </ul>"},{"location":"limitador/server/configuration/#redis_local_cache_max_ttl_cached_counters_ms","title":"<code>REDIS_LOCAL_CACHE_MAX_TTL_CACHED_COUNTERS_MS</code>","text":"<ul> <li>Used to configure the local cache when using Redis. See <code>REDIS_LOCAL_CACHE_ENABLED</code>. This env only applies when <code>\"REDIS_LOCAL_CACHE_ENABLED\" == 1</code>.</li> <li>Optional. Defaults to <code>5000</code>.</li> <li>Format: <code>integer</code>. Duration in milliseconds.</li> </ul>"},{"location":"limitador/server/configuration/#redis_local_cache_ttl_ratio_cached_counters","title":"<code>REDIS_LOCAL_CACHE_TTL_RATIO_CACHED_COUNTERS</code>","text":"<ul> <li>Used to configure the local cache when using Redis. See <code>REDIS_LOCAL_CACHE_ENABLED</code>. This env only applies when <code>\"REDIS_LOCAL_CACHE_ENABLED\" == 1</code>.</li> <li>Optional. Defaults to <code>10</code>.</li> <li>Format: <code>integer</code>.</li> </ul>"},{"location":"limitador/server/configuration/#redis_url","title":"<code>REDIS_URL</code>","text":"<ul> <li>Redis URL. Required only when you want to use Redis to store the limits.</li> <li>Optional. By default, Limitador stores the limits in memory and does not require Redis.</li> <li>Format: <code>string</code>, URL in the format of <code>\"redis://127.0.0.1:6379\"</code>.</li> </ul>"},{"location":"limitador/server/configuration/#rust_log","title":"<code>RUST_LOG</code>","text":"<ul> <li>Defines the log level.</li> <li>Optional. Defaults to <code>\"error\"</code>.</li> <li>Format: <code>enum</code>: <code>\"debug\"</code>, <code>\"error\"</code>, <code>\"info\"</code>, <code>\"warn\"</code>, or <code>\"trace\"</code>.</li> </ul>"},{"location":"limitador/server/configuration/#when-built-with-the-infinispan-feature-experimental","title":"When built with the <code>infinispan</code> feature - experimental","text":""},{"location":"limitador/server/configuration/#infinispan_cache_name","title":"<code>INFINISPAN_CACHE_NAME</code>","text":"<ul> <li>The name of the Infinispan cache that Limitador will use to store limits and   counters. This variable applies only when <code>INFINISPAN_URL</code> is   set.</li> <li>Optional. By default, Limitador will use a cache called <code>\"limitador\"</code>.</li> <li>Format: <code>string</code>.</li> </ul>"},{"location":"limitador/server/configuration/#infinispan_counters_consistency","title":"<code>INFINISPAN_COUNTERS_CONSISTENCY</code>","text":"<ul> <li>Defines the consistency mode for the Infinispan counters created by Limitador.   This variable applies only when <code>INFINISPAN_URL</code> is set.</li> <li>Optional. Defaults to <code>\"strong\"</code>.</li> <li>Format: <code>enum</code>: <code>\"Strong\"</code> or <code>\"Weak\"</code>.</li> </ul>"},{"location":"limitador/server/configuration/#infinispan_url","title":"<code>INFINISPAN_URL</code>","text":"<ul> <li>Infinispan URL. Required only when you want to use Infinispan to store the   limits.</li> <li>Optional. By default, Limitador stores the limits in memory and does not   require Infinispan.</li> <li>Format: <code>URL</code>, in the format of <code>http://username:password@127.0.0.1:11222</code>.</li> </ul>"},{"location":"limitador/server/configuration/#rate_limit_headers","title":"<code>RATE_LIMIT_HEADERS</code>","text":"<ul> <li>Enables rate limit response headers. Only supported by the RLS server.</li> <li>Optional. Defaults to <code>\"NONE\"</code>.</li> <li>Must be one of: </li> <li><code>\"NONE\"</code> - Does not add any additional headers to the http response. </li> <li><code>\"DRAFT_VERSION_03\"</code>.  Adds response headers per https://datatracker.ietf.org/doc/id/draft-polli-ratelimit-headers-03.html</li> </ul>"},{"location":"multicluster-gateway-controller/","title":"multicluster-gateway-controller","text":""},{"location":"multicluster-gateway-controller/#description","title":"Description:","text":"<p>When deploying the multicluster gateway controller using the make targets, the following will be created:  * Kind cluster(s) * Gateway API CRDs in the control plane cluster * Ingress controller * Cert manager * ArgoCD instance * K8s Dashboard * LetsEncrypt certs</p>"},{"location":"multicluster-gateway-controller/#prerequisites","title":"Prerequisites:","text":"<ul> <li>AWS</li> <li>Kind <ul> <li><code>make kind</code></li> </ul> </li> <li>yq <ul> <li><code>make yq</code></li> </ul> </li> <li>openssl&gt;=3<ul> <li>On macos a later version is available with <code>brew install openssl</code>. You'll need to update your PATH as macos provides an older version via libressl as well</li> <li>On fedora use <code>dnf install openssl</code></li> </ul> </li> <li>go &gt;= 1.20</li> </ul>"},{"location":"multicluster-gateway-controller/#1-running-the-controller-in-the-cluster","title":"1. Running the controller in the cluster:","text":"<ol> <li> <p>Create env files:</p> <ul> <li>One called <code>aws-credentials.env</code> containing AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY and AWS_REGION</li> <li>One called <code>controller-config.env</code> containing AWS_DNS_PUBLIC_ZONE_ID and ZONE_ROOT_DOMAIN</li> </ul> </li> <li> <p>Setup your local environment      <pre><code>make local-setup MGC_WORKLOAD_CLUSTERS_COUNT=&lt;NUMBER_WORKLOAD_CLUSTER&gt;\n</code></pre></p> </li> <li> <p>Build the controller image and load it into the control plane     <code>sh    kubectl config use-context kind-mgc-control-plane     make kind-load-controller</code></p> </li> <li> <p>Deploy the controller to the control plane cluster     <pre><code>make deploy-controller\n</code></pre></p> </li> <li> <p>(Optional) View the logs of the deployed controller     <pre><code>kubectl logs -f $(kubectl get pods -n multi-cluster-gateways | grep \"mgc-\" | awk '{print $1}') -n multi-cluster-gateways\n</code></pre></p> </li> </ol>"},{"location":"multicluster-gateway-controller/#2-running-the-controller-locally","title":"2. Running the controller locally:","text":"<ol> <li> <p>Create env files:</p> <ul> <li>One called <code>aws-credentials.env</code> containing AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY and AWS_REGION</li> <li>One called <code>controller-config.env</code> containing AWS_DNS_PUBLIC_ZONE_ID and ZONE_ROOT_DOMAIN</li> </ul> </li> <li> <p>Setup your local environment </p> <pre><code>make local-setup MGC_WORKLOAD_CLUSTERS_COUNT=&lt;NUMBER_WORKLOAD_CLUSTER&gt;\n</code></pre> </li> <li> <p>Run the controller locally:     <pre><code>kubectl config use-context kind-mgc-control-plane (export $(cat ./controller-config.env | xargs) &amp;&amp; export $(cat ./aws-credentials.env | xargs) &amp;&amp; make build-controller install run-controller)\n</code></pre></p> </li> </ol>"},{"location":"multicluster-gateway-controller/#3-running-the-agent-in-the-cluster","title":"3. Running the agent in the cluster:","text":"<ol> <li> <p>Build the agent image and load it into the workload cluster     <pre><code>kubectl config use-context kind-mgc-workload-1 make kind-load-agent\n</code></pre></p> </li> <li> <p>Deploy the agent to the workload cluster     <pre><code>make deploy-agent\n</code></pre></p> </li> </ol>"},{"location":"multicluster-gateway-controller/#4-running-the-agent-locally","title":"4. Running the agent locally","text":"<ol> <li>Target the workload cluster you wish to run on: <pre><code>export KUBECONFIG=./tmp/kubeconfigs/mgc-workload-1.kubeconfig\n</code></pre></li> <li>Run the agent locally: <pre><code>make build-agent run-agent\n</code></pre></li> </ol>"},{"location":"multicluster-gateway-controller/#license","title":"License","text":"<p>Copyright 2022 Red Hat.</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"multicluster-gateway-controller/how-to/kuadrant-addon-walkthrough/","title":"Kuadrant operator addon","text":""},{"location":"multicluster-gateway-controller/how-to/kuadrant-addon-walkthrough/#introduction","title":"Introduction","text":"<p>The following walkthrough will show you how to install/setup the Kuadrant operator via OCM (Open cluster management addons)</p> <p>NOTE:  A good walkthrough to have done before this is Open Cluster Management and Multi-Cluster gateways</p>"},{"location":"multicluster-gateway-controller/how-to/kuadrant-addon-walkthrough/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kind </li> </ul>"},{"location":"multicluster-gateway-controller/how-to/kuadrant-addon-walkthrough/#open-terminal-sessions","title":"Open terminal sessions","text":"<p>For this walkthrough, we're going to use multiple terminal sessions/windows, all using <code>multicluster-gateway-controller</code> as the <code>pwd</code>.</p> <p>Open 2 windows, which we'll refer to throughout this walkthrough as:</p> <ul> <li><code>T1</code> (Hub/control plane cluster, Where we'll run our controller locally)</li> <li><code>T2</code> (Hub/control plane cluster)</li> <li><code>T3</code> (Spoke/workload cluster 1)</li> </ul>"},{"location":"multicluster-gateway-controller/how-to/kuadrant-addon-walkthrough/#setup-up-local-environment","title":"Setup up local environment","text":"<ol> <li>Clone this repo locally</li> <li> <p>In <code>T1</code> run the following command to bring up the kind clusters. The number of spoke cluster you want is dictated by the env var <code>MGC_WORKLOAD_CLUSTERS_COUNT</code></p> <pre><code>make local-setup MGC_WORKLOAD_CLUSTERS_COUNT=1\n</code></pre> <p> Linux users may encounter the following error: <code>ERROR: failed to create cluster: could not find a log line that matches \"Reached target .*Multi-User System.*|detected cgroup v1\" make: *** [Makefile:75: local-setup] Error 1ERROR: failed to create cluster: could not find a log line that matches \"Reached target .*Multi-User System.*|detected cgroup v1\" make: *** [Makefile:75: local-setup] Error 1</code>  This is a known issue with Kind. Follow the steps here to resolve it.</p> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/kuadrant-addon-walkthrough/#running-the-addon-manager-controller-and-deploying-kuadrant-resources","title":"Running the addon manager controller and deploying Kuadrant resources","text":"<p>NOTE:  Your terminal should have the context of the Hub cluster or the control plane cluster. This is by default the context after you run the make local setup. To get the context run the following command      <code>kind export kubeconfig --name=mgc-control-plane --kubeconfig=$(pwd)/local/kube/control-plane.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/control-plane.yaml</code></p> <ol> <li>In <code>T1</code> run the following to bring up the controller.     <pre><code>make run-ocm\n</code></pre></li> <li>Update the managed cluster addon <code>namespace</code> to the spoke cluster name you want to deploy Kuadrant to e.g <code>kind-mgc-workload-1</code>. Then in <code>T2</code> deploy it to the hub cluster     <pre><code>kubectl apply -f config/kuadrant/deploy/hub\n</code></pre></li> <li>In the <code>T3</code> change the context to the workload cluster via      <pre><code>kind export kubeconfig --name=mgc-workload-1 --kubeconfig=$(pwd)/local/kube/workload1.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/workload1.yaml`\n</code></pre></li> <li>In <code>T3</code> Running the following:     <pre><code>kubectl get pods -n kuadrant-system\n</code></pre>     you should see the namespace <code>kuadrant-system</code> be created and the following pods come up:</li> <li>authorino-value</li> <li>authorino-operator-value</li> <li>kuadrant-operator-controller-manager-value</li> <li>limitador-value</li> <li>limitador-operator-controller-manager-value</li> </ol>"},{"location":"multicluster-gateway-controller/how-to/kuadrant-addon-walkthrough/#follow-on-walkthroughs","title":"Follow on Walkthroughs","text":"<p>Some good follow on walkthroughs that build on this walkthrough</p> <ul> <li>Deploying/Configuring Redis, Limitador and Rate limit policies.</li> </ul>"},{"location":"multicluster-gateway-controller/how-to/managedZone/","title":"Creating and using a ManagedZone resource.","text":""},{"location":"multicluster-gateway-controller/how-to/managedZone/#what-is-a-managedzone","title":"What is a ManagedZone","text":"<p>A ManagedZone is a reference to a DNS zone.  By creating a ManagedZone we are instructing the MGC about a domain or subdomain that can be used as a host by any gateways in the same namespace. These gateways can use a subdomain of the ManagedZone.</p> <p>If a gateway attempts to a use a domain as a host, and there is no matching ManagedZone for that host, then that host on that gateway will fail to function.</p> <p>A gateway's host will be matched to any ManagedZone that the host is a subdomain of, i.e. <code>test.api.hcpapps.net</code> will be matched by any managedzone (in the same namespace) of: <code>test.api.hcpapps.net</code>, <code>api.hcpapps.net</code> or <code>hcpapps.net</code>.</p> <p>When MGC wants to create the DNS Records for a host, it will create them in the most exactly matching ManagedZone. e.g. given the zones <code>hcpapps.net</code> and <code>api.hcpapps.net</code> the DNS Records for the host <code>test.api.hcpapps.net</code> will be created in the <code>api.hcpapps.net</code> zone.</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#delegation","title":"Delegation","text":"<p>Delegation allows you to give control of a subdomain of a root domain to MGC while the root domain has it's DNS zone elsewhere.</p> <p>In the scenario where a root domain has a zone outside Route53, e.g. <code>external.com</code>, and a ManagedZone for <code>delegated.external.com</code> is required, the following steps can be taken: - Create the ManagedZone for <code>delegated.external.com</code> and wait until the status is updated with an array of nameservers (e.g. <code>ns1.hcpapps.net</code>, <code>ns2.hcpapps.net</code>).  - Copy these nameservers to your root zone for <code>external.com</code>, you can create a NS record for each nameserver against the <code>delegated.external.com</code> record.</p> <p>For example: <pre><code>delegated.external.com. 3600 IN NS ns1.hcpapps.net.\ndelegated.external.com. 3600 IN NS ns2.hcpapps.net.\n</code></pre></p> <p>Now, when MGC creates a DNS record in it's Route53 zone for <code>delegated.external.com</code>, it will be resolved correctly.</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#walkthrough","title":"Walkthrough","text":"<p>There is an existing walkthrough, which involves using a managed zone.</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#current-limitations","title":"Current limitations","text":"<p>At the moment the MGC is given credentials to connect to the DNS provider at startup using environment variables, because of that, MGC is limited to one provider type (Route53), and all zones must be in the same Route53 account.</p> <p>There are plans to make this more customizable and dynamic in the future, work tracked here.</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#spec-of-a-managedzone","title":"Spec of a ManagedZone","text":"<p>The ManagedZone is a simple resource with an uncomplicated API, see a sample here.</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#mandatory-fields","title":"Mandatory fields","text":"<p>The ManagedZone spec has 1 required field <code>domainName</code>: <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: ManagedZone\nmetadata:\n  name: testmz.hcpapps.net\nspec:\n  domainName: testmz.hcapps.net\n</code></pre></p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#optional-fields","title":"Optional fields","text":"<p>The following fields are optional:</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#id","title":"ID","text":"<p>By setting the ID, you are referring to an existing zone in the DNS provider which MGC will use to manage the DNS of this zone. By leaving the ID empty, MGC will create a zone in the DNS provider, and store the reference in this field.</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#description","title":"Description","text":"<p>This is simply a human-readable description of this resource (e.g. \"Use this zone for the staging environment\")</p>"},{"location":"multicluster-gateway-controller/how-to/managedZone/#parentmanagedzone","title":"ParentManagedZone","text":"<p>This allows a zone to be owned by another zone (e.g test.api.domain.com could be owned by api.domain.com), MGC will use this owner relationship to manage the NS values for the subdomain in the parent domain. Note that for this to work, both the owned and owner zones must be in the Route53 account accessible by MGC.</p>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/","title":"Open Cluster Management and Multi-Cluster gateways","text":""},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#introduction","title":"Introduction","text":"<p>This document will walk you through using Open Cluster Management (OCM) and Kuadrant to configure and deploy a multi-cluster gateway.  You will also deploy a simple application that uses that gateway for ingress and protects that applications endpoints with a rate limit policy.  We will start with a single cluster and move to multiple clusters to illustrate how a single gateway definition can be used across multiple clusters and highlight the automatic TLS integration and also the automatic DNS load balancing between gateway instances.</p>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#requirements","title":"Requirements","text":"<ul> <li>Kind</li> <li>go &gt;= 1.20</li> <li>openssl &gt;= 3</li> <li>AWS account with Route 53 enabled</li> <li>https://github.com/chipmk/docker-mac-net-connect (for macos users)</li> </ul> <p>Note:  this walkthrough will setup a zone in your AWS account and make changes to it for DNS purposes</p>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#installation-and-setup","title":"Installation and Setup","text":"<ul> <li>Clone this repo locally </li> <li> <p>Setup a <code>./controller-config.env</code> file in the root of the repo with the following key values</p> <pre><code># this sets up your default managed zone\nAWS_DNS_PUBLIC_ZONE_ID=&lt;AWS ZONE ID&gt;\n# this is the domain at the root of your zone (foo.example.com)\nZONE_ROOT_DOMAIN=test.hcpapps.net # replace this with your root domain\nLOG_LEVEL=1\n</code></pre> </li> <li> <p>setup a <code>./aws-credentials.env</code> with credentials to access route 53</p> <p>For example: <pre><code>AWS_ACCESS_KEY_ID=&lt;access_key_id&gt;\nAWS_SECRET_ACCESS_KEY=&lt;secret_access_key&gt;\nAWS_REGION=eu-west-1\n</code></pre></p> </li> <li> <p>We're going to use an environment variable, <code>MGC_SUB_DOMAIN</code>, throughout this walkthrough. Simply run the below in each window you create:</p> </li> </ul> <pre><code>export MGC_SUB_DOMAIN=myapp.test.hcpapps.net # replace this\n</code></pre> <ul> <li>Alternatively, to set a default, add the above environment variable to your <code>.zshrc</code> or <code>.bash_profile</code>. To override this as a once-off, simply <code>export MGC_SUB_DOMAIN</code>.</li> </ul>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#open-terminal-sessions","title":"Open terminal sessions","text":"<p>For this walkthrough, we're going to use multiple terminal sessions/windows, all using <code>multicluster-gateway-controller</code> as the <code>pwd</code>.</p> <p>Open three windows, which we'll refer to throughout this walkthrough as:</p> <ul> <li><code>T1</code> (Hub Cluster)</li> <li> <p><code>T2</code> (Workloads cluster)</p> </li> <li> <p>To setup a local instance, in <code>T1</code>, run:</p> <pre><code>make local-setup OCM_SINGLE=true MGC_WORKLOAD_CLUSTERS_COUNT=1\n</code></pre> <p> Linux users may encounter the following error: <code>ERROR: failed to create cluster: could not find a log line that matches \"Reached target .*Multi-User System.*|detected cgroup v1\" make: *** [Makefile:75: local-setup] Error 1ERROR: failed to create cluster: could not find a log line that matches \"Reached target .*Multi-User System.*|detected cgroup v1\" make: *** [Makefile:75: local-setup] Error 1</code>  This is a known issue with Kind. Follow the steps here to resolve it.</p> </li> <li> <p>Once this is completed your kubeconfig context should be set to the hub cluster. </p> <p>Optional Step:  If you need to reset this run the following in <code>T1</code>: <pre><code>kind export kubeconfig --name=mgc-control-plane --kubeconfig=$(pwd)/local/kube/control-plane.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/control-plane.yaml\n</code></pre></p> </li> <li> <p>In the hub cluster (<code>T1</code>) we are going to label the control plane managed cluster as an Ingress cluster:</p> <pre><code>kubectl label managedcluster kind-mgc-control-plane ingress-cluster=true\n</code></pre> </li> <li> <p>Next, in <code>T1</code>, create the ManagedClusterSet that uses the ingress label to select clusters:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta2\nkind: ManagedClusterSet\nmetadata:\n  name: gateway-clusters\nspec:\n  clusterSelector:\n    labelSelector: \n      matchLabels:\n        ingress-cluster: \"true\"\n    selectorType: LabelSelector\nEOF\n</code></pre> </li> <li> <p>Next, in <code>T1</code> we need to bind this cluster set to our multi-cluster-gateways namespace so that we can use those clusters to place gateways on:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta2\nkind: ManagedClusterSetBinding\nmetadata:\n  name: gateway-clusters\n  namespace: multi-cluster-gateways\nspec:\n  clusterSet: gateway-clusters\nEOF\n</code></pre> </li> </ul>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#create-a-placement-for-our-gateways","title":"Create a placement for our gateways","text":"<ol> <li> <p>In order to place our gateways onto clusters, we need to setup a placement resource. Again, in <code>T1</code>, run:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta1\nkind: Placement\nmetadata:\n  name: http-gateway\n  namespace: multi-cluster-gateways\nspec:\n  numberOfClusters: 1\n  clusterSets:\n    - gateway-clusters\nEOF\n</code></pre> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#create-the-gateway-class","title":"Create the gateway class","text":"<ol> <li> <p>Lastly, we will set up our multi-cluster gateway class. In <code>T1</code>, run:</p> <pre><code>kubectl create -f hack/ocm/gatewayclass.yaml\n</code></pre> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#start-the-gateway-controller","title":"Start the Gateway Controller","text":"<ol> <li> <p>In <code>T1</code> run the following to start the Gateway Controller:</p> <pre><code>make build-controller kind-load-controller deploy-controller\n</code></pre> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#check-the-managed-zone","title":"Check the managed zone","text":"<ol> <li> <p>Lets ensure our <code>managedzone</code> is present. In <code>T1</code>, run the following:</p> <p><pre><code>export KUBECONFIG=$(pwd)/local/kube/control-plane.yaml\nkubectl get managedzone -n multi-cluster-gateways\n</code></pre> 1. You should see the following:   <pre><code>NAME          DOMAIN NAME      ID                                  RECORD COUNT   NAMESERVERS                                                                                        READY\nmgc-dev-mz   test.hcpapps.net   /hostedzone/Z08224701SVEG4XHW89W0   7              [\"ns-1414.awsdns-48.org\",\"ns-1623.awsdns-10.co.uk\",\"ns-684.awsdns-21.net\",\"ns-80.awsdns-10.com\"]   True\n</code></pre></p> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#create-a-gateway","title":"Create a gateway","text":"<ol> <li>We know will create a multi-cluster gateway definition in the hub cluster. In <code>T1</code>, run the following: </li> </ol> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: prod-web\n  namespace: multi-cluster-gateways\nspec:\n  gatewayClassName: kuadrant-multi-cluster-gateway-instance-per-cluster\n  listeners:\n  - allowedRoutes:\n      namespaces:\n        from: All\n    name: api\n    hostname: $MGC_SUB_DOMAIN\n    port: 443\n    protocol: HTTPS\nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#place-the-gateway","title":"Place the gateway","text":"<p>In the hub cluster there will be a single gateway definition but no actual gateway for handling traffic yet.</p> <p>This is because we haven't placed the gateway yet onto any of our ingress clusters (in this case the hub and ingress cluster are the same)</p> <ol> <li> <p>To place the gateway, we need to add a placement label to gateway resource to instruct the gateway controller where we want this gateway instantiated. In <code>T1</code>, run:</p> <pre><code>kubectl label gateway prod-web \"cluster.open-cluster-management.io/placement\"=\"http-gateway\" -n multi-cluster-gateways\n</code></pre> </li> <li> <p>Now on the hub cluster you should find there is a configured gateway and instantiated gateway. In <code>T1</code>, run:</p> <p><pre><code>kubectl get gateway -A\n</code></pre> you'll see the following:</p> <pre><code>kuadrant-multi-cluster-gateways   prod-web   istio                                         172.32.200.0                29s\nmulti-cluster-gateways            prod-web   kuadrant-multi-cluster-gateway-instance-per-cluster                  True         2m42s\n</code></pre> <p>The instantiated gateway in this case is handled by Istio and has been assigned the 172.x address. You can definition of this gateway is handled in multi-cluster-gateways namespace.  As we are in a single cluster you can see both. Later on we will add in another ingress cluster and in that case you will only see the instantiated gateway.</p> <p>Additionally you should be able to see a secret containing a self signed certificate. It is possible to also use a letsencrypt certificate, but for simplicity in this walkthrough we are using a self signed cert. </p> </li> <li> <p>In <code>T1</code>, run:</p> <p><pre><code>kubectl get secrets -n kuadrant-multi-cluster-gateways\n</code></pre> you'll see the following: <pre><code>myapp.test.hcpapps.net   kubernetes.io/tls   3      4m33s\n</code></pre></p> </li> </ol> <p>The listener is configured to use this TLS secret also. So now our gateway has been placed and is running in the right locations with the right configuration and TLS has been setup for the HTTPS listeners.</p> <p>So what about DNS how do we bring traffic to these gateways?</p>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#create-and-attach-a-httproute","title":"Create and attach a HTTPRoute","text":"<p>We only configure DNS once a HTTPRoute has been attached to a listener in the gateway. </p> <ol> <li> <p>In <code>T1</code>, using the following command in the hub cluster, you will see we currently have no DNSRecord resources.</p> <p><pre><code>kubectl get dnsrecord -A\n</code></pre> <pre><code>No resources found\n</code></pre></p> </li> <li> <p>Lets create a simple echo app with a HTTPRoute in one of the gateway clusters. Remember to replace the hostnames. Again we are creating this in the single hub cluster for now. In <code>T1</code>, run:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: my-route\nspec:\n  parentRefs:\n  - kind: Gateway\n    name: prod-web\n    namespace: kuadrant-multi-cluster-gateways\n  hostnames:\n  - \"$MGC_SUB_DOMAIN\"  \n  rules:\n  - backendRefs:\n    - name: echo\n      port: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo\nspec:\n  ports:\n    - name: http-port\n      port: 8080\n      targetPort: http-port\n      protocol: TCP\n  selector:\n    app: echo     \n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: echo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - name: echo\n          image: docker.io/jmalloc/echo-server\n          ports:\n            - name: http-port\n              containerPort: 8080\n              protocol: TCP       \nEOF\n</code></pre> <p>Once this is done, the Kuadrant multi-cluster gateway controller will pick up that a HTTPRoute has been attached to the Gateway it is managing from the hub and it will setup a DNS record to start bringing traffic to that gateway for the host defined in that listener.</p> </li> <li> <p>You should now see a DNSRecord resource in the hub cluster. In <code>T1</code>, run:</p> <p><pre><code>kubectl get dnsrecord -A\n</code></pre> <pre><code>NAMESPACE                NAME                 READY\nmulti-cluster-gateways   myapp.test.hcpapps.net   True\n</code></pre></p> </li> <li> <p>You should also be able to see there is only 1 endpoint added which corresponds to address assigned to the gateway where the HTTPRoute was created. In <code>T1</code>, run:</p> <pre><code>kubectl get dnsrecord -n multi-cluster-gateways -o=yaml\n</code></pre> </li> <li> <p>Give DNS a minute or two to update. You should then be able to executethe following and get back the correct A record. </p> <p><pre><code>dig $MGC_SUB_DOMAIN\n</code></pre> 1. You should also be able to curl that endpoint</p> <pre><code>curl -k https://$MGC_SUB_DOMAIN\n# Request served by echo-XXX-XXX\n</code></pre> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#introducing-the-second-cluster","title":"Introducing the second cluster","text":"<p>So now we have a working gateway with DNS and TLS configured. Let place this gateway on a second cluster and bring traffic to that gateway also.</p> <ol> <li> <p>First add the second cluster to the clusterset, by running the following in <code>T1</code>:</p> <pre><code>kubectl label managedcluster kind-mgc-workload-1 ingress-cluster=true\n</code></pre> </li> <li> <p>This has added our workload-1 cluster to the ingress clusterset. Next we need to modify our placement. In <code>T1</code>, run:</p> <pre><code>kubectl edit placement http-gateway -n multi-cluster-gateways\n</code></pre> </li> <li> <p>This will open your <code>$EDITOR</code> - in here, edit the spec change the <code>numberOfClusters</code> to be 2, and save.</p> </li> <li> <p>In <code>T2</code> window execute the following to see the gateway on the workload-1 cluster:</p> <p><pre><code>kind export kubeconfig --name=mgc-workload-1 --kubeconfig=$(pwd)/local/kube/workload1.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/workload1.yaml\nkubectl get gateways -A\n</code></pre> You'll see the following <pre><code>NAMESPACE                         NAME       CLASS   ADDRESS        PROGRAMMED   AGE\nkuadrant-multi-cluster-gateways   prod-web   istio   172.32.201.0                90s\n</code></pre></p> <p>So now we have second ingress cluster configured with the same Gateway. </p> </li> <li> <p>In <code>T2</code>, targeting the second cluster, go ahead and create the HTTPRoute in the second gateway cluster.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: my-route\nspec:\n  parentRefs:\n  - kind: Gateway\n    name: prod-web\n    namespace: kuadrant-multi-cluster-gateways\n  hostnames:\n  - \"$MGC_SUB_DOMAIN\"  \n  rules:\n  - backendRefs:\n    - name: echo\n      port: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo\nspec:\n  ports:\n    - name: http-port\n      port: 8080\n      targetPort: http-port\n      protocol: TCP\n  selector:\n    app: echo     \n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: echo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - name: echo\n          image: docker.io/jmalloc/echo-server\n          ports:\n            - name: http-port\n              containerPort: 8080\n              protocol: TCP       \nEOF\n</code></pre> </li> <li> <p>Now if you move back to the hub context in <code>T1</code> and take a look at the dnsrecord, you will see we now have two A records configured:</p> </li> </ol> <pre><code>kubectl get dnsrecord -n multi-cluster-gateways -o=yaml\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#watching-dns-changes","title":"Watching DNS changes","text":"<p>If you want you can use <code>watch dig $MGC_SUB_DOMAIN</code> to see the DNS switching between the two addresses </p>"},{"location":"multicluster-gateway-controller/how-to/ocm-control-plane-walkthrough/#follow-on-walkthroughs","title":"Follow on Walkthroughs","text":"<p>Some good follow on walkthroughs that build on this walkthrough</p> <ul> <li>Installing the Kuadrant operator via OCM Addon</li> <li>Deploying/Configuring Redis, Limitador and Rate limit policies.</li> </ul>"},{"location":"multicluster-gateway-controller/how-to/ratelimiting-shared-redis/","title":"Deploying/Configuring Redis, Limitador and Rate limit policies.","text":""},{"location":"multicluster-gateway-controller/how-to/ratelimiting-shared-redis/#introduction","title":"Introduction","text":"<p>The following document is going to show you how to deploy Redis as storage for Limitador, configure Limitador itself and how to configure and setup Rate Limit Policies against a <code>HTTP route</code> using Limitador .</p>"},{"location":"multicluster-gateway-controller/how-to/ratelimiting-shared-redis/#requirements","title":"Requirements","text":"<ul> <li>Kind</li> <li>Kuadrant operator Walkthrough to install Kuadrant can be found here</li> <li>Gateways setup Walkthrough to setup gateways in you clusters can be found here</li> </ul> <p>## Installation and Setup 1. Clone this repo locally  2. Run through the walkthroughs from requirements</p>"},{"location":"multicluster-gateway-controller/how-to/ratelimiting-shared-redis/#open-terminal-sessions","title":"Open terminal sessions","text":"<p>For this walkthrough, we're going to be continuing on from a previous walkthrough that uses the following multiple terminal sessions/windows, all using <code>multicluster-gateway-controller</code> as the <code>pwd</code>.</p> <p>Open three windows, which we'll refer to throughout this walkthrough as:</p> <ul> <li><code>T1</code> (Hub/Spoke Cluster)</li> <li><code>T2</code> (Hub Cluster Where we'll run our controller locally (needed for previous walkthrough))</li> <li><code>T3</code> (Workloads cluster)</li> </ul>"},{"location":"multicluster-gateway-controller/how-to/ratelimiting-shared-redis/#configuring-limitador-in-spoke-clusters","title":"Configuring limitador in spoke clusters","text":"<ol> <li>In <code>T1</code> get the ip address of your control-plane cluster using:     <pre><code>kubectl get nodes -o wide\n</code></pre></li> <li>If needs be update the URL located in <code>config/kuadrant/redis/limitador</code> to include the ip address from above step.</li> <li>In the clusters that have Kuadrant operator installed i.e <code>T1 &amp; T3</code> run the following to configure limitador to use Redis as storage rather then local cluster storage:     <pre><code>kustomize build config/kuadrant/limitador/ | kubectl apply -f -\n</code></pre></li> </ol>"},{"location":"multicluster-gateway-controller/how-to/ratelimiting-shared-redis/#configuring-rate-limit-policies","title":"Configuring Rate Limit Policies","text":"<ol> <li> <p>In <code>T1 &amp; T3 both spoke clusters</code> run the following command to create a Rate Limit Policy for the HTTP route created in the walkthrough linked above called <code>Open Cluster Management and Multi-Cluster gateways</code>. The policy is limiting the route to have 8 successful requests in 10 seconds, these values can be changed to whatever you want.</p> <p><pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: RateLimitPolicy\nmetadata:\nname: echo-rlp\nspec:\ntargetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: prod-web\nrateLimits:\n    - configurations:\n    - actions:\n        - generic_key:\n            descriptor_key: \"limited\"\n            descriptor_value: \"1\"\n    - rules:\n    - hosts: [ \"replace.this\" ]\n    limits:\n        - conditions:\n            - 'limited == \"1\"'\n        maxValue: 8\n        seconds: 10\nEOF\n</code></pre> 1.  In <code>T1 and T3</code> test the RLP you can run the following command: <pre><code>while true; do curl -k -s -o /dev/null -w \"%{http_code}\\n\"  replace.this.with.host &amp;&amp; sleep 1; done\n</code></pre> 2. You should see your host be limited to whatever limit you've chosen. This will be across all clusters. Meaning if you trying make a curl request to both clusters at the same time, it will maintain the limit and wont reset allowoing successful requests when it should be limited.</p> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/","title":"Submariner proof of concept 2 clusters &amp; gateways resiliency walkthrough","text":""},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#introduction","title":"Introduction","text":"<p>This walkthrough shows how submariner can be used to provide service resiliency across 2 clusters. Each cluster is running a Gateway with a HttpRoute in front of an application Service. By leveraging Submariner (and the Multi Cluster Services API), the application Service can be exported (via a ServiceExport resource) from either cluster, and imported (via a ServiceImport resource) to either cluster. This provides a clusterset hostname for the service in either cluster e.g. echo.default.svc.clusterset.local The HttpRoute has a backendRef to a Service that points to this hostname. If the Service is unavailable on the local cluster, it will be routed to another cluster that has exported that Service.</p>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#requirements","title":"Requirements","text":"<ul> <li>Local development environment has been set up as per the main README i.e. local env files have been created with AWS credentials &amp; a zone</li> </ul> <p>Note:  this walkthrough will setup a zone in your AWS account and make changes to it for DNS purposes</p> <p>Note: <code>replace.this</code> is a place holder that you will need to replace with your own domain</p>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#installation-and-setup","title":"Installation and Setup","text":"<p>For this walkthrough, we're going to use multiple terminal sessions/windows, all using <code>multicluster-gateway-controller</code> as the <code>pwd</code>.</p> <p>Open three windows, which we'll refer to throughout this walkthrough as:</p> <ul> <li><code>T1</code> (Hub Cluster)</li> <li><code>T2</code> (Where we'll run our controller locally)</li> <li><code>T3</code> (Workloads cluster)</li> </ul> <p>To setup a local instance with submariner, in <code>T1</code>, run:</p> <pre><code>make local-setup OCM_SINGLE=true SUBMARINER=true MGC_WORKLOAD_CLUSTERS_COUNT=1\n</code></pre> <p>In the hub cluster (<code>T1</code>) we are going to label the control plane managed cluster as an Ingress cluster:</p> <pre><code>kubectl label managedcluster kind-mgc-control-plane ingress-cluster=true\nkubectl label managedcluster kind-mgc-workload-1 ingress-cluster=true\n</code></pre> <p>Next, in <code>T1</code>, create the ManagedClusterSet that uses the ingress label to select clusters:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta2\nkind: ManagedClusterSet\nmetadata:\n  name: gateway-clusters\nspec:\n  clusterSelector:\n    labelSelector: \n      matchLabels:\n        ingress-cluster: \"true\"\n    selectorType: LabelSelector\nEOF\n</code></pre> <p>Next, in <code>T1</code> we need to bind this cluster set to our multi-cluster-gateways namespace so that we can use those clusters to place Gateways on:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta2\nkind: ManagedClusterSetBinding\nmetadata:\n  name: gateway-clusters\n  namespace: multi-cluster-gateways\nspec:\n  clusterSet: gateway-clusters\nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#create-a-placement-for-our-gateways","title":"Create a placement for our Gateways","text":"<p>In order to place our Gateways onto clusters, we need to setup a placement resource. Again, in <code>T1</code>, run:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta1\nkind: Placement\nmetadata:\n  name: http-gateway\n  namespace: multi-cluster-gateways\nspec:\n  numberOfClusters: 2\n  clusterSets:\n    - gateway-clusters\nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#create-the-gateway-class","title":"Create the Gateway class","text":"<p>Lastly, we will set up our multi-cluster GatewayClass. In <code>T1</code>, run:</p> <pre><code>kubectl create -f hack/ocm/gatewayclass.yaml\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#start-the-gateway-controller","title":"Start the Gateway Controller","text":"<p>In <code>T2</code> run the following to start the Gateway Controller:</p> <pre><code>(export $(cat ./controller-config.env | xargs) &amp;&amp; export $(cat ./aws-credentials.env | xargs) &amp;&amp; make build-controller install run-controller)\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#create-a-gateway","title":"Create a Gateway","text":"<p>We know will create a multi-cluster Gateway definition in the hub cluster. In <code>T1</code>, run the following: </p> <p>Important:  Make sure to replace <code>sub.replace.this</code> with a subdomain of your root domain.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: prod-web\n  namespace: multi-cluster-gateways\nspec:\n  gatewayClassName: kuadrant-multi-cluster-gateway-instance-per-cluster\n  listeners:\n  - allowedRoutes:\n      namespaces:\n        from: All\n    name: api\n    hostname: sub.replace.this\n    port: 443\n    protocol: HTTPS\nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#place-the-gateway","title":"Place the Gateway","text":"<p>To place the Gateway, we need to add a placement label to Gateway resource to instruct the Gateway controller where we want this Gateway instantiated. In <code>T1</code>, run:</p> <pre><code>kubectl label gateways.gateway.networking.k8s.io prod-web \"cluster.open-cluster-management.io/placement\"=\"http-gateway\" -n multi-cluster-gateways\n</code></pre> <p>Now on the hub cluster you should find there is a configured Gateway and instantiated Gateway. In <code>T1</code>, run:</p> <pre><code>kubectl get gateways.gateway.networking.k8s.io -A\n</code></pre> <pre><code>kuadrant-multi-cluster-gateways   prod-web   istio                                         172.32.200.0                29s\nmulti-cluster-gateways            prod-web   kuadrant-multi-cluster-gateway-instance-per-cluster                  True         2m42s\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#create-and-attach-a-httproute","title":"Create and attach a HTTPRoute","text":"<p>Lets create a simple echo app with a HTTPRoute and 2 Services (one that routes to the app, and one that uses an externalName) in the first cluster. Remember to replace the hostnames. Again we are creating this in the single hub cluster for now. In <code>T1</code>, run:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: my-route\nspec:\n  parentRefs:\n  - kind: Gateway\n    name: prod-web\n    namespace: kuadrant-multi-cluster-gateways\n  hostnames:\n  - \"sub.replace.this\"  \n  rules:\n  - backendRefs:\n    - name: echo-import-proxy\n      port: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo-import-proxy\nspec:\n  type: ExternalName\n  externalName: echo.default.svc.clusterset.local\n  ports:\n  - port: 8080\n    targetPort: 8080\n    protocol: TCP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo\nspec:\n  ports:\n    - name: http-port\n      port: 8080\n      targetPort: http-port\n      protocol: TCP\n  selector:\n    app: echo\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: echo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - name: echo\n          image: docker.io/jmalloc/echo-server\n          ports:\n            - name: http-port\n              containerPort: 8080\n              protocol: TCP   \nEOF\n</code></pre> <p>Once this is done, the Kuadrant multi-cluster Gateway controller will pick up that a HTTPRoute has been attached to the Gateway it is managing from the hub and it will setup a DNS record to start bringing traffic to that Gateway for the host defined in that listener.</p> <p>You should now see a DNSRecord and only 1 endpoint added which corresponds to address assigned to the Gateway where the HTTPRoute was created. In <code>T1</code>, run:</p> <pre><code>kubectl get dnsrecord -n multi-cluster-gateways -o=yaml\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#introducing-the-second-cluster","title":"Introducing the second cluster","text":"<p>In <code>T3</code>, targeting the second cluster, go ahead and create the HTTPRoute &amp; 2 Services in the second Gateway cluster.</p> <pre><code>kind export kubeconfig --name=mgc-workload-1 --kubeconfig=$(pwd)/local/kube/workload1.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/workload1.yaml\n\nkubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: my-route\nspec:\n  parentRefs:\n  - kind: Gateway\n    name: prod-web\n    namespace: kuadrant-multi-cluster-gateways\n  hostnames:\n  - \"sub.replace.this\"  \n  rules:\n  - backendRefs:\n    - name: echo-import-proxy\n      port: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo-import-proxy\nspec:\n  type: ExternalName\n  externalName: echo.default.svc.clusterset.local\n  ports:\n  - port: 8080\n    targetPort: 8080\n    protocol: TCP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo\nspec:\n  ports:\n    - name: http-port\n      port: 8080\n      targetPort: http-port\n      protocol: TCP\n  selector:\n    app: echo\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: echo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - name: echo\n          image: docker.io/jmalloc/echo-server\n          ports:\n            - name: http-port\n              containerPort: 8080\n              protocol: TCP   \nEOF\n</code></pre> <p>Now if you move back to the hub context in <code>T1</code> and take a look at the dnsrecord, you will see we now have two A records configured:</p> <pre><code>kubectl get dnsrecord -n multi-cluster-gateways -o=yaml\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#create-the-serviceexports-and-serviceimports","title":"Create the ServiceExports and ServiceImports","text":"<p>In <code>T1</code>, export the Apps echo service from cluster 1 to cluster 2, and vice versa.</p> <pre><code>./bin/subctl export service --kubeconfig ./tmp/kubeconfigs/external/mgc-control-plane.kubeconfig --namespace default echo\n./bin/subctl export service --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-1.kubeconfig --namespace default echo\n</code></pre> <p>In <code>T1</code>, verify the ServiceExport was created on cluster 1 and cluster 2</p> <pre><code>kubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-control-plane.kubeconfig get serviceexport echo\nkubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-1.kubeconfig get serviceexport echo\n</code></pre> <p>In <code>T1</code>, verify the ServiceImport was created on both clusters</p> <pre><code>kubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-1.kubeconfig get serviceimport echo\nkubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-control-plane.kubeconfig get serviceimport echo\n</code></pre> <p>At this point you should get a 200 response. It might take a minute for dns to propegate internally after importing the services above.</p> <pre><code>curl -Ik https://sub.replace.this\n</code></pre> <p>You can force resolve the IP to either cluster and verify a 200 is returned when routed to both cluster Gateways.</p> <pre><code>curl -Ik --resolve sub.replace.this:443:172.32.200.0 https://sub.replace.this\ncurl -Ik --resolve sub.replace.this:443:172.32.201.0 https://sub.replace.this\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#testing-resiliency","title":"Testing resiliency","text":"<p>In <code>T1</code>, stop the echo pod on cluster 2</p> <pre><code>kubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-1.kubeconfig scale deployment/echo --replicas=0\n</code></pre> <p>Verify a 200 is still returned when routed to either cluster</p> <pre><code>curl -Ik --resolve sub.replace.this:443:172.32.200.0 https://sub.replace.this\ncurl -Ik --resolve sub.replace.this:443:172.32.201.0 https://sub.replace.this\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-2-gateways-resiliency-walkthrough/#known-issues","title":"Known issues","text":"<p>At the time of writing, Istio does not support adding a ServiceImport as a backendRef directly as per the Gateway API proposal - GEP-1748. This is why the walkthrough uses a Service of type ExternalName to route to the clusterset host instead. There is an issue questioning the current state of support.</p> <p>The install of the <code>subctl</code> cli fails on macs with arm architecture. The error is <code>curl: (22) The requested URL returned error: 404</code>. A workaround for this is to download the amd64 darwin release manually from the releases page and extract it to the <code>./bin</code> directory.</p>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/","title":"Submariner proof of concept with a Hub Gateway &amp; 2 Workload Clusters","text":""},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#introduction","title":"Introduction","text":"<p>This walkthrough shows how submariner can be used to provide service resiliency across 2 clusters with a hub cluster as the Gateway. The hub cluster is running a Gateway with a HttpRoute in front of an application Service. By leveraging Submariner (and the Multi Cluster Services API), the application Service can be exported (via a ServiceExport resource) from the 2 workload clusters, and imported (via a ServiceImport resource) to the hub cluster. This provides a clusterset hostname for the service in the hub cluster e.g. echo.kuadrant-multi-cluster-gateways.svc.clusterset.local The HttpRoute has a backendRef to a Service that points to this hostname. If the Service is unavailable in either workload cluster, it will be routed to the other workload cluster.</p> <p></p>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#requirements","title":"Requirements","text":"<ul> <li>Local development environment has been set up as per the main README i.e. local env files have been created with AWS credentials &amp; a zone</li> </ul> <p>Note:  this walkthrough will setup a zone in your AWS account and make changes to it for DNS purposes</p> <p>Note: <code>replace.this</code> is a place holder that you will need to replace with your own domain</p>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#installation-and-setup","title":"Installation and Setup","text":"<p>For this walkthrough, we're going to use multiple terminal sessions/windows, all using <code>multicluster-gateway-controller</code> as the <code>pwd</code>.</p> <p>Open three windows, which we'll refer to throughout this walkthrough as:</p> <ul> <li><code>T1</code> (Hub Cluster)</li> <li><code>T2</code> (Where we'll run our controller locally)</li> <li><code>T3</code> (Workload cluster 1)</li> <li><code>T4</code> (Workload cluster 2)</li> </ul> <p>To setup a local instance with submariner, in <code>T1</code>, run:</p> <pre><code>make local-setup OCM_SINGLE=true SUBMARINER=true MGC_WORKLOAD_CLUSTERS_COUNT=2\n</code></pre> <p>In the hub cluster (<code>T1</code>) we are going to label the control plane managed cluster as an Ingress cluster:</p> <pre><code>kubectl label managedcluster kind-mgc-control-plane ingress-cluster=true\n</code></pre> <p>Next, in <code>T1</code>, create the ManagedClusterSet that uses the ingress label to select clusters:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta2\nkind: ManagedClusterSet\nmetadata:\n  name: gateway-clusters\nspec:\n  clusterSelector:\n    labelSelector: \n      matchLabels:\n        ingress-cluster: \"true\"\n    selectorType: LabelSelector\nEOF\n</code></pre> <p>Next, in <code>T1</code> we need to bind this cluster set to our multi-cluster-gateways namespace so that we can use that cluster to place Gateway on:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta2\nkind: ManagedClusterSetBinding\nmetadata:\n  name: gateway-clusters\n  namespace: multi-cluster-gateways\nspec:\n  clusterSet: gateway-clusters\nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#create-a-placement-for-our-gateway","title":"Create a placement for our Gateway","text":"<p>In order to place our Gateway onto the hub clusters, we need to setup a placement resource. Again, in <code>T1</code>, run:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cluster.open-cluster-management.io/v1beta1\nkind: Placement\nmetadata:\n  name: http-gateway\n  namespace: multi-cluster-gateways\nspec:\n  numberOfClusters: 1\n  clusterSets:\n    - gateway-clusters\nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#create-the-gatewayclass","title":"Create the GatewayClass","text":"<p>Lastly, we will set up our multi-cluster GatewayClass. In <code>T1</code>, run:</p> <pre><code>kubectl create -f hack/ocm/gatewayclass.yaml\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#start-the-gateway-controller","title":"Start the Gateway Controller","text":"<p>In <code>T2</code> run the following to start the Gateway Controller:</p> <pre><code>kind export kubeconfig --name=mgc-control-plane --kubeconfig=$(pwd)/local/kube/control-plane.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/control-plane.yaml\n(export $(cat ./controller-config.env | xargs) &amp;&amp; export $(cat ./aws-credentials.env | xargs) &amp;&amp; make build-controller install run-controller)\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#create-a-gateway","title":"Create a Gateway","text":"<p>We know will create a multi-cluster Gateway definition in the hub cluster. In <code>T1</code>, run the following: </p> <p>Important:  Make sure to replace <code>sub.replace.this</code> with a subdomain of your root domain.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: prod-web\n  namespace: multi-cluster-gateways\nspec:\n  gatewayClassName: kuadrant-multi-cluster-gateway-instance-per-cluster\n  listeners:\n  - allowedRoutes:\n      namespaces:\n        from: All\n    name: api\n    hostname: sub.replace.this\n    port: 443\n    protocol: HTTPS\nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#place-the-gateway","title":"Place the gateway","text":"<p>To place the Gateway, we need to add a placement label to Gateway resource to instruct the Gateway controller where we want this Gateway instantiated. In <code>T1</code>, run:</p> <pre><code>kubectl label gateways.gateway.networking.k8s.io prod-web \"cluster.open-cluster-management.io/placement\"=\"http-gateway\" -n multi-cluster-gateways\n</code></pre> <p>Now on the hub cluster you should find there is a configured Gateway and instantiated Gateway. In <code>T1</code>, run:</p> <pre><code>kubectl get gateways.gateway.networking.k8s.io -A\n</code></pre> <pre><code>kuadrant-multi-cluster-gateways   prod-web   istio                                         172.32.200.0                29s\nmulti-cluster-gateways            prod-web   kuadrant-multi-cluster-gateway-instance-per-cluster                  True         2m42s\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#deploy-the-app-to-the-2-workload-clusters","title":"Deploy the App to the 2 workload clusters","text":"<p>We do this before the HttpRoute is created for the purposes of the walkthrough. If we don't do it in this order, there may be negative dns caching of the ServiceImport clusterset host resulting in 503 responses. In <code>T3</code>, targeting the 1st workload cluster, go ahead and create Service and Deployment.</p> <pre><code>kind export kubeconfig --name=mgc-workload-1 --kubeconfig=$(pwd)/local/kube/workload1.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/workload1.yaml\nkubectl create namespace kuadrant-multi-cluster-gateways\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo\n  namespace: kuadrant-multi-cluster-gateways\nspec:\n  ports:\n    - name: http-port\n      port: 8080\n      targetPort: http-port\n      protocol: TCP\n  selector:\n    app: echo\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: echo\n  namespace: kuadrant-multi-cluster-gateways\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - name: echo\n          image: docker.io/jmalloc/echo-server\n          ports:\n            - name: http-port\n              containerPort: 8080\n              protocol: TCP   \nEOF\n</code></pre> <p>In <code>T4</code>, targeting the 2nd workload cluster, go ahead and create Service and Deployment there too.</p> <pre><code>kind export kubeconfig --name=mgc-workload-2 --kubeconfig=$(pwd)/local/kube/workload2.yaml &amp;&amp; export KUBECONFIG=$(pwd)/local/kube/workload2.yaml\nkubectl create namespace kuadrant-multi-cluster-gateways\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo\n  namespace: kuadrant-multi-cluster-gateways\nspec:\n  ports:\n    - name: http-port\n      port: 8080\n      targetPort: http-port\n      protocol: TCP\n  selector:\n    app: echo\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: echo\n  namespace: kuadrant-multi-cluster-gateways\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - name: echo\n          image: docker.io/jmalloc/echo-server\n          ports:\n            - name: http-port\n              containerPort: 8080\n              protocol: TCP   \nEOF\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#create-the-serviceexports-and-serviceimports","title":"Create the ServiceExports and ServiceImports","text":"<p>In <code>T1</code>, export the Apps echo service from the workload clusters.</p> <pre><code>./bin/subctl export service --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-1.kubeconfig --namespace kuadrant-multi-cluster-gateways echo\n./bin/subctl export service --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-2.kubeconfig --namespace kuadrant-multi-cluster-gateways echo\n</code></pre> <p>In <code>T1</code>, verify the ServiceExport was created on both clusters</p> <pre><code>kubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-1.kubeconfig get serviceexport echo -n kuadrant-multi-cluster-gateways\nkubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-workload-2.kubeconfig get serviceexport echo -n kuadrant-multi-cluster-gateways\n</code></pre> <p>In <code>T1</code>, verify the ServiceImport was created in the hub</p> <pre><code>kubectl --kubeconfig ./tmp/kubeconfigs/external/mgc-control-plane.kubeconfig get serviceimport echo -n kuadrant-multi-cluster-gateways\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#create-and-attach-a-httproute-and-service","title":"Create and attach a HTTPRoute and Service","text":"<p>Lets create a HTTPRoute and a Service (that uses an externalName) in the hub cluster. Remember to replace the hostnames. In <code>T1</code>, run:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: my-route\n  namespace: kuadrant-multi-cluster-gateways\nspec:\n  parentRefs:\n  - kind: Gateway\n    name: prod-web\n    namespace: kuadrant-multi-cluster-gateways\n  hostnames:\n  - \"sub.replace.this\"  \n  rules:\n  - backendRefs:\n    - name: echo-import-proxy\n      port: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo-import-proxy\n  namespace: kuadrant-multi-cluster-gateways\nspec:\n  type: ExternalName\n  externalName: echo.kuadrant-multi-cluster-gateways.svc.clusterset.local\n  ports:\n  - port: 8080\n    targetPort: 8080\n    protocol: TCP\nEOF\n</code></pre> <p>Once this is done, the Kuadrant multi-cluster Gateway controller will pick up that a HTTPRoute has been attached to the Gateway it is managing from the hub and it will setup a DNS record to start bringing traffic to that Gateway for the host defined in that listener.</p> <p>You should now see a DNSRecord and only 1 endpoint added which corresponds to address assigned to the Gateway where the HTTPRoute was created. In <code>T1</code>, run:</p> <pre><code>kubectl get dnsrecord -n multi-cluster-gateways -o=yaml\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#verify-the-httproute-works","title":"Verify the HttpRoute works","text":"<p>At this point you should get a 200 response. It might take a minute for dns to propegate internally by submariner after importing the services above.</p> <pre><code>curl -Ik https://sub.replace.this\n</code></pre> <p>If DNS is not resolving for you yet you may get a 503. In that case you can force resolve the IP to the hub cluster and verify a 200 is returned.</p> <pre><code>curl -Ik --resolve sub.replace.this:443:172.32.200.0 https://sub.replace.this\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/submariner-poc-hub-gateway-walkthrough/#known-issues","title":"Known issues","text":"<p>At the time of writing, Istio does not support adding a ServiceImport as a backendRef directly as per the Gateway API proposal - GEP-1748. This is why the walkthrough uses a Service of type ExternalName to route to the clusterset host instead. There is an issue questioning the current state of support.</p> <p>The install of the <code>subctl</code> cli fails on macs with arm architecture. The error is <code>curl: (22) The requested URL returned error: 404</code>. A workaround for this is to download the amd64 darwin release manually from the releases page and extract it to the <code>./bin</code> directory.</p>"},{"location":"multicluster-gateway-controller/how-to/template/","title":"Title","text":""},{"location":"multicluster-gateway-controller/how-to/template/#introduction","title":"Introduction","text":"<p>blah blah amazing and wonderful feature blah blah gateway blah blah DNS </p>"},{"location":"multicluster-gateway-controller/how-to/template/#requirements","title":"Requirements","text":"<ul> <li>A computer</li> <li>Electricity</li> <li>Kind</li> <li>AWS Account</li> <li>Route 53 enabled</li> <li>Other Walkthroughs</li> </ul> <p>## Installation and Setup 1. Clone this repo locally  1. Setup a <code>./controller-config.env</code> file in the root of the repo with the following key values</p> <pre><code>```bash\n# this sets up your default managed zone\nAWS_DNS_PUBLIC_ZONE_ID=&lt;AWS ZONE ID&gt;\n# this is the domain at the root of your zone (foo.example.com)\nZONE_ROOT_DOMAIN=&lt;replace.this&gt;\nLOG_LEVEL=1\n```\n</code></pre> <ol> <li> <p>setup a <code>./aws-credentials.env</code> with credentials to access route 53</p> <p>For example:</p> <pre><code>AWS_ACCESS_KEY_ID=&lt;access_key_id&gt;\nAWS_SECRET_ACCESS_KEY=&lt;secret_access_key&gt;\nAWS_REGION=eu-west-1\n</code></pre> </li> </ol>"},{"location":"multicluster-gateway-controller/how-to/template/#open-terminal-sessions","title":"Open terminal sessions","text":"<p>For this walkthrough, we're going to use multiple terminal sessions/windows, all using <code>multicluster-gateway-controller</code> as the <code>pwd</code>.</p> <p>Open three windows, which we'll refer to throughout this walkthrough as:</p> <ul> <li><code>T1</code> (Hub Cluster)</li> <li><code>T2</code> (Where we'll run our controller locally)</li> <li><code>T3</code> (Workloads cluster)</li> </ul> <p>To setup a local instance, in <code>T1</code>, run:</p>"},{"location":"multicluster-gateway-controller/how-to/template/#known-bugs","title":"Known bugs","text":"<p>buzzzzz</p>"},{"location":"multicluster-gateway-controller/how-to/template/#follow-on-walkthroughs","title":"Follow on Walkthroughs","text":"<p>Some good follow on walkthroughs that build on this walkthrough</p>"},{"location":"multicluster-gateway-controller/how-to/template/#helpful-symbols-for-dev-use","title":"Helpful symbols (For dev use)","text":"<p>  * for more see https://gist.github.com/rxaviers/7360908</p>"},{"location":"multicluster-gateway-controller/how-to/vscode-debugging/","title":"Debugging in VS code","text":""},{"location":"multicluster-gateway-controller/how-to/vscode-debugging/#introduction","title":"Introduction","text":"<p>The following document will show how to setup debugging for multi gateway controller.</p> <p>There is an included VSCode <code>launch.json</code>.</p>"},{"location":"multicluster-gateway-controller/how-to/vscode-debugging/#starting-the-controller","title":"Starting the controller","text":"<p>Instead of starting the Gateway Controller via something like:</p> <pre><code>(export $(cat ./controller-config.env | xargs) &amp;&amp; export $(cat ./aws-credentials.env | xargs) &amp;&amp; make build-controller install run-controller)\n</code></pre> <p>You can now simply hit <code>F5</code> in VSCode. The controller will launch with the following config:</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Debug\",\n      \"type\": \"go\",\n      \"request\": \"launch\",\n      \"mode\": \"auto\",\n      \"program\": \"./cmd/controller/main.go\",\n      \"args\": [\n        \"--metrics-bind-address=:8080\",\n        \"--health-probe-bind-address=:8081\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"multicluster-gateway-controller/how-to/vscode-debugging/#running-debugger","title":"Running Debugger","text":""},{"location":"multicluster-gateway-controller/how-to/vscode-debugging/#debugging-tests","title":"Debugging Tests","text":""},{"location":"multicluster-gateway-controller/milestone3/gateway_deletion/","title":"Gateway deletion","text":""},{"location":"multicluster-gateway-controller/milestone3/gateway_deletion/#gateway-deletion","title":"Gateway deletion","text":"<p>When deleting a gateway it should ONLY be deleted in the control plane cluster. This will the trigger the following events:</p>"},{"location":"multicluster-gateway-controller/milestone3/gateway_deletion/#workload-clusters","title":"Workload cluster(s):","text":"<ol> <li>The corresponding gateway in the workload clusters will also be deleted.</li> </ol>"},{"location":"multicluster-gateway-controller/milestone3/gateway_deletion/#control-plane-clusters","title":"Control plane cluster(s):","text":"<ol> <li> <p>DNS Record deletion:</p> <p>Gateways and DNS records have a 1:1 relationship only, when a gateway gets deleted the corresponding DNS record also gets marked for deletion. This then triggers the DNS record to be removed from the managed zone in the DNS provider (currently only route 53 is accepted). 3. Certs and secrets deletion :</p> <p>When a gateway is created a cert is also created for the host in the gateway, this is also removed when the gateway is deleted.</p> </li> </ol>"},{"location":"multicluster-gateway-controller/proposals/","title":"Index","text":""},{"location":"multicluster-gateway-controller/proposals/#proposals","title":"Proposals","text":"<p>This directory contains proposals accepted into the MGC. The template for add a proposal is located in this directory. Make a copy of the template and use it to define your own proposal.  </p>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/","title":"Multiple DNS Provider Support","text":"<p>Authors: Michael Nairn @mikenairn</p> <p>Epic: https://github.com/Kuadrant/multicluster-gateway-controller/issues/189</p> <p>Date: 25th May 2023</p>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#job-stories","title":"Job Stories","text":"<ul> <li>As a developer, I want to use MGC with a domain hosted in one of the major cloud DNS providers (Google Cloud DNS, Azure DNS or AWS Route53) </li> <li>As a developer, I want to use multiple domains with a single instance of MGC, each hosted on different cloud providers</li> </ul>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#goals","title":"Goals","text":"<ul> <li>Add ManagedZone and DNSRecord support for Google Cloud DNS</li> <li>Add ManagedZone and DNSRecord support for Azure DNS</li> <li>Add DNSRecord support for CoreDNS (Default for development environment)</li> <li>Update ManagedZone and DNSRecord support for AWS Route53</li> <li>Add support for multiple providers with a single instance of MGC</li> </ul>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#non-goals","title":"Non Goals","text":"<ul> <li>Support for every DNS provider</li> <li>Support for health checks</li> </ul>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#current-approach","title":"Current Approach","text":"<p>Currently, MGC only supports AWS Route53 as a dns provider. A single instance of a DNSProvider resource is created per MGC instance which is configured with AWS config loaded from the environment.  This provider is loaded into all controllers requiring dns access (ManagedZone and DNSRecord reconciliations), allowing a single instance of MGC to operate against a single account on a single dns provider.</p>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#proposed-solution","title":"Proposed Solution","text":"<p>MGC has three features it requires of any DNS provider in order to offer full support, DNSRecord management, Zone management and DNS Health checks.  We do not however want to limit to providers that only offer this functionality, so to add support for a provider the minimum that provider should offer is API access to managed DNS records. MGC will continue to provide Zone management and DNS Health checks support on a per-provider basis.</p> <p>Support will be added for AWS(Route53), Google(Google Cloud DNS), Azure and investigation into possible adding CoreDNS (intended for local dev purposes), with the following proposed initial support:</p> Provider DNS Records DNS Zones DNS Health AWS Route53 X X X Google Cloud DNS X X - AzureDNS X X - CoreDNS X - - <p>Add DNSProvider as an API for MGC which contains all the required config for that particular provider including the credentials. This can be thought of in a similar way to a cert manager Issuer. Update ManagedZone to add a reference to a DNSProvider. This will be a required field on the ManagedZone and a DNSProvider must exist before a ManagedZone can be created. Update all controllers load the DNSProvider directly from the ManagedZone during reconciliation loops and remove the single controller wide instance.  Add new provider implementations for google, azure and coredns.     * All providers constructors should accept a single struct containing all required config for that particular provider.     * Providers must be configured from credentials passed in the config and not rely on environment variables.</p>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#other-solutions-investigated","title":"Other Solutions investigated","text":"<p>Investigation was carried out into the suitability of [External DNS] (https://github.com/kubernetes-sigs/external-dns) as the sole means of managing dns resources. Unfortunately, while external dns does offer support for basic dns record management with a wide range of providers, there were too many features missing making it unsuitable at this time for integration.</p>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#external-dns-as-a-separate-controller","title":"External DNS as a separate controller","text":"<p>Run external dns, as intended, as a separate controller alongside mgc, and pass all responsibility for reconciling DNSRecord resources to it. All DNSRecord reconciliation is removed from MGC.</p> <p>Issues:</p> <ul> <li>A single instance of external dns will only work with a single provider and a single set of credentials. As it is, in order to support more than a single provider, more than one external dns instance would need to be created, one for each provider/account pair.</li> <li>Geo and Weighted routing policies are not implemented for any provider other than AWS Route53.</li> <li>Only supports basic dns record management (A,CNAME, NS records etc ..), with no support for managed zones or health checks.</li> </ul>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#external-dns-as-a-module-dependency","title":"External DNS as a module dependency","text":"<p>Add external dns as a module dependency in order to make use of their DNS Providers, but continue to reconcile DNSRecords in MGC.</p> <p>Issues:</p> <ul> <li>External DNS Providers all create clients using the current environment. Would require extensive refactoring in order to modify each provider to optionally be constructed using static credentials.</li> <li>Clients were all internal making it impossible, without modification, to use the upstream code to extend the provider behaviour to support additional functionality such as managed zone creation.</li> </ul>"},{"location":"multicluster-gateway-controller/proposals/multiple-dns-provider-support/#checklist","title":"Checklist","text":"<ul> <li>[ ] An epic has been created and linked to</li> <li>[ ] Reviewers have been added. It is important that the right reviewers are selected.</li> </ul>"},{"location":"multicluster-gateway-controller/proposals/status-aggregation/","title":"Proposal: Aggregation of Status Conditions","text":""},{"location":"multicluster-gateway-controller/proposals/status-aggregation/#background","title":"Background","text":"<p>Status conditions are used to represent the current state of a resource and provide information about any problems or issues that might be affecting it. They are defined as an array of Condition objects within the status section of a resource's YAML definition.</p>"},{"location":"multicluster-gateway-controller/proposals/status-aggregation/#problem-statement","title":"Problem Statement","text":"<p>When multiple instances of a resource (e.g. a Gateway) are running across multiple clusters, it can be difficult to know the current state of each instance without checking each one individually. This can be time-consuming and error-prone, especially when there are a large number of clusters or resources.</p>"},{"location":"multicluster-gateway-controller/proposals/status-aggregation/#proposal","title":"Proposal","text":"<p>To solve this problem, I'm proposing we leverage the status conditions in the control plane instance of that resource, aggregating the statuses to convey the necessary information.</p> <p>For example, if the <code>ListenersValid</code> status condition type of a <code>Gateway</code> is <code>True</code> for all instances of the <code>Gateway</code> resource across all clusters, then the <code>Gateway</code> in the control plane will have the <code>ListenersValid</code> status condition type also set to <code>True</code>.</p> <pre><code>status:\nconditions:\n- type: ListenersValid\nstatus: True\nmessage: All listeners are valid\n</code></pre> <p>If the <code>ListenersValid</code> status condition type of some instances is not <code>True</code>, the <code>ListenersValid</code> status condition type of the <code>Gateway</code> in the control plane will be <code>False</code>.</p> <pre><code>status:\nconditions:\n- type: ListenersValid\nstatus: False\n</code></pre> <p>In addition, if the <code>ListenersValid</code> status condition type is <code>False</code>, the <code>Gateway</code> in the control plane should include a status message for each <code>Gateway</code> instance where <code>ListenersValid</code> is <code>False</code>. This message would indicate the reason why the condition is not true for each <code>Gateway</code>.</p> <pre><code>status:\nconditions:\n- type: ListenersValid\nstatus: False\nmessage: \"gateway-1 Listener certificate is expired; gateway-3 No listener configured for port 80\"\n</code></pre> <p>In this example, the <code>ListenersValid</code> status condition type is <code>False</code> because two of the three Gateway instances (gateway-1 and gateway-3) have issues with their listeners. For gateway-1, the reason for the <code>False</code> condition is that the listener certificate is expired, and for gateway-3, the reason is that no listener is configured for port 80. These reasons are included as status messages in the <code>Gateway</code> resource in the control plane.</p> <p>As there may be different reasons for the condition being <code>False</code> across different clusters, it doesn't make sense to aggregate the <code>reason</code> field. The <code>reason</code> field is intended to be a programatic identifier, while the <code>message</code> field allows for a human readable message i.e. a semi-colon separated list of messages.</p> <p>The <code>lastTransitionTime</code> and <code>observedGeneration</code> fields will behave as normal for the resource in the control plane.</p>"},{"location":"multicluster-gateway-controller/proposals/template/","title":"Proposal Template","text":"<p>Authors: {authors names} Epic: {Issue of type epic this relates to} Date: {date proposed}</p>"},{"location":"multicluster-gateway-controller/proposals/template/#job-stories","title":"Job Stories","text":"<p>{ A bullet point list of stories this proposal solves}</p>"},{"location":"multicluster-gateway-controller/proposals/template/#goals","title":"Goals","text":"<p>{A bullet point list of the goals this will achieve}</p>"},{"location":"multicluster-gateway-controller/proposals/template/#non-goals","title":"Non Goals","text":"<p>{A bullet point list of goals that this will not achieve, IE scoping}</p>"},{"location":"multicluster-gateway-controller/proposals/template/#current-approach","title":"Current Approach","text":"<p>{outline the current approach if any}</p>"},{"location":"multicluster-gateway-controller/proposals/template/#proposed-solution","title":"Proposed Solution","text":"<p>{outline the proposed solution, links to diagrams and PRs can go here along with the details of your solution}</p>"},{"location":"multicluster-gateway-controller/proposals/template/#testing","title":"Testing","text":"<p>{outline any testing considerations. Does this need some form of load/performance test. Are there any considerations when thinking about an e2e test}</p>"},{"location":"multicluster-gateway-controller/proposals/template/#checklist","title":"Checklist","text":"<ul> <li>[ ] An epic has been created and linked to</li> <li>[ ] Reviewers have been added. It is important that the right reviewers are selected. </li> </ul>"},{"location":"multicluster-gateway-controller/proposals/assets/multiple-dns-provider-support/azure/azure/","title":"Azure","text":""},{"location":"multicluster-gateway-controller/proposals/assets/multiple-dns-provider-support/azure/azure/#azure","title":"Azure","text":"<p>https://portal.azure.com/</p> <p>Azure supports Weighted and Geolocation routing policies, but requires records to alias to a Traffic Manager resource that must also be created in the users acocunt https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-routing-methods</p> <p>Notes:</p> <ul> <li>A Traffic Manager Profile is created per record set and is created with a routing method (Weighted or Geographic) https://portal.azure.com/#view/Microsoft_Azure_Network/LoadBalancingHubMenuBlade/~/TrafficManagers</li> <li>Only a singe IP can be added to a DNSRecord set. A traffic manager profile must be created and aliased from a DNSRecord set for anything that involves more than a single target.</li> <li>Significantly more resources to manage in order to achieve functionality comparable with google and aws. </li> <li>The modelling of the records is significantly different from AWS Route53, but the current DNSRecord spec could still work. The azure implementation will have to process the endpoint list and create traffic manager policies as required to satisfy the record set.</li> </ul> <p>Given the example DNSRecord here describing a record set for a geo location routing policy with four clusters, two in two regions (North America and Europe), the following Azure resources are required.</p> <p>Three DNSRecords, each aliased to a different traffic manager:</p> <p></p> <ul> <li>dnsrecord-geo-azure-hcpapps-net (dnsrecord-geo.azure.hcpapps.net) aliased to Traffic Manager Profile 1 (dnsrecord-geo-azure-hcpapps-net)</li> <li>dnsrecord-geo-na.azure-hcpapps-net (dnsrecord-geo.na.azure.hcpapps.net) aliased to Traffic Manager Profile 2 (dnsrecord-geo-na-azure-hcpapps-net)</li> <li>dnsrecord-geo-eu.azure-hcpapps-net (dnsrecord-geo.eu.azure.hcpapps.net) aliased to Traffic Manager Profile 3 (dnsrecord-geo-eu-azure-hcpapps-net)</li> </ul> <p>Three Traffic Manager Profiles:</p> <p></p> <ul> <li>Traffic Manager Profile 1 (dnsrecord-geo-azure-hcpapps-net): Geolocation routing policy with two region specific FQDN targets (dnsrecord-geo.eu.azure.hcpapps.net and dnsrecord-geo.na.azure.hcpapps.net).</li> <li>Traffic Manager Profile 2 (dnsrecord-geo-na-azure-hcpapps-net): Weighted routed policy with two IP address endpoints (172.32.0.1 and 172.32.0.2) with equal weighting.</li> <li>Traffic Manager Profile 3 (dnsrecord-geo-eu-azure-hcpapps-net): Weighted routed policy with two IP address endpoints (172.32.0.3 and 172.32.0.4) with equal weighting. </li> </ul> <pre><code>dig dnsrecord-geo.azure.hcpapps.net\n\n; &lt;&lt;&gt;&gt; DiG 9.18.12 &lt;&lt;&gt;&gt; dnsrecord-geo.azure.hcpapps.net\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 16236\n;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 65494\n;; QUESTION SECTION:\n;dnsrecord-geo.azure.hcpapps.net. IN    A\n\n;; ANSWER SECTION:\ndnsrecord-geo.azure.hcpapps.net. 60 IN  CNAME   dnsrecord-geo-azure-hcpapps-net.trafficmanager.net.\ndnsrecord-geo-azure-hcpapps-net.trafficmanager.net. 60 IN CNAME dnsrecord-geo.eu.azure.hcpapps.net.\ndnsrecord-geo.eu.azure.hcpapps.net. 60 IN A     172.32.0.3\n\n;; Query time: 88 msec\n;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)\n;; WHEN: Tue May 30 15:05:07 IST 2023\n;; MSG SIZE  rcvd: 168\n</code></pre>"},{"location":"multicluster-gateway-controller/proposals/assets/multiple-dns-provider-support/google/google/","title":"Google","text":""},{"location":"multicluster-gateway-controller/proposals/assets/multiple-dns-provider-support/google/google/#google","title":"Google","text":"<p>https://console.cloud.google.com/net-services/dns/zones</p> <p>Google supports Weighted(Weighted Round Robin) and Geolocation routing policies https://cloud.google.com/dns/docs/zones/manage-routing-policies. Both of these can be configured directly on records in Google Cloud DNS and no secondary Traffic Management resource is required.</p> <p>Notes:</p> <ul> <li>Record sets are modelled as a single endpoint with routing policy embedded. This is a different approach to Route53 where each individual A/CNAME would have its own record entry. </li> <li>Weight must be an integer between 0 - 10000</li> <li>There are no continent options for region, only finer grained regions such as us-east1, europe-west-1 etc...</li> <li>There appears to be no way to set a default region, google just routes requests to the nearest supported region.</li> <li>The current approach used in AWS Route53 for geo routing will work in the same way on Google DNS. A single CNAME record with geo routing policy specifying multiple geo specific A record entries as targets.</li> <li>Geo and weighted routing can be combined, as with AWS Route53, allowing traffic with a region to be routed using weightings.</li> <li>The modelling of the records is slightly different from AWS, but the current DNSRecord spec could still work. The google implemention of AddRecords will have to process the list of endpoints in order to group related endpoints in order to build up the required API request. In this case there would not be a 1:1 mapping between an endpoint in a DNSRecord and the dns provider, but the DNSRecord contents would be kept consistent across all providers and compatibility with external-dns would be maintained.</li> </ul> <p>Example request for Geo CNAME record:</p> <p>POST https://dns.googleapis.com/dns/v1beta2/projects/it-cloud-gcp-rd-midd-san/managedZones/google-hcpapps-net/rrsets <pre><code>{\n\"name\": \"dnsrecord-geo.google.hcpapps.net.\",\n\"routingPolicy\": {\n\"geo\": {\n\"item\": [\n{\n\"location\": \"us-east1\",\n\"rrdata\": [\n\"dnsrecord-geo.na.google.hcpapps.net.\"\n]\n},\n{\n\"location\": \"europe-west1\",\n\"rrdata\": [\n\"dnsrecord-geo.eu.google.hcpapps.net.\"\n]\n}\n],\n\"enableFencing\": false\n}\n},\n\"ttl\": 60,\n\"type\": \"CNAME\"\n}\n</code></pre></p> <p>Example request for Weighted A record:</p> <p>POST https://dns.googleapis.com/dns/v1beta2/projects/it-cloud-gcp-rd-midd-san/managedZones/google-hcpapps-net/rrsets <pre><code>{\n\"name\": \"dnsrecord-geo.na.google.hcpapps.net.\",\n\"routingPolicy\": {\n\"wrr\": {\n\"item\": [\n{\n\"weight\": 60.0,\n\"rrdata\": [\n\"172.32.0.1\"\n]\n},\n{\n\"weight\": 60.0,\n\"rrdata\": [\n\"172.32.0.2\"\n]\n}\n]\n}\n},\n\"ttl\": 60,\n\"type\": \"A\"\n}\n</code></pre></p> <p>Given the example DNSRecord here describing a record set for a geo location routing policy with four clusters, two in two regions (North America and Europe), the following resources are required.</p> <p>Three DNSRecords, one CNAME (dnsrecord-geo.google.hcpapps.net) and 2 A records (dnsrecord-geo.na.google.hcpapps.net and dnsrecord-geo.eu.google.hcpapps.net)</p> <p></p> <pre><code>dig dnsrecord-geo.google.hcpapps.net\n\n; &lt;&lt;&gt;&gt; DiG 9.18.12 &lt;&lt;&gt;&gt; dnsrecord-geo.google.hcpapps.net\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 22504\n;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 65494\n;; QUESTION SECTION:\n;dnsrecord-geo.google.hcpapps.net. IN   A\n\n;; ANSWER SECTION:\ndnsrecord-geo.google.hcpapps.net. 60 IN CNAME   dnsrecord-geo.eu.google.hcpapps.net.\ndnsrecord-geo.eu.google.hcpapps.net. 60 IN A    172.32.0.4\n\n;; Query time: 33 msec\n;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)\n;; WHEN: Tue May 30 15:05:25 IST 2023\n;; MSG SIZE  rcvd: 108\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>The purpose of this repo is to hold architecture documents that relate to overall architecture and design of Kuadrant. Note currently this repo is being updated and for know it is better to look at the individual components in this repo</p>"},{"location":"architecture/#what-belongs-here","title":"What belongs here:","text":"<ul> <li>Cross cutting proposal that involves or impacts on more than one component within Kuadrant</li> <li>Documents describing the overall architecture or a sub context (control plane / data plane) within the architecture </li> </ul>"},{"location":"architecture/#kuadrant-rfcs","title":"Kuadrant RFCs","text":"<p>The RFC (Request For Comments) process is aiming at providing a consistent and well understood way of adding new features or introducing breaking changes in the Kuadrant stack. It provides a mean for all stakeholders and community at large to provide feedback and be confident about the evolution of our solution.</p> <p>Many, if not most of the changes will not require to follow this process. Bug fixes, refactoring, performance improvements or documentation additions/improvements can be implemented using the tradition PR (Pull Request) model straight to the targeted repositories on Github. </p> <p>Additions or any other changes that impact the end user experience will need to follow this process.</p>"},{"location":"architecture/#when-is-an-rfc-required","title":"When is an RFC required?","text":"<p>This process is meant for any changes that affect the user's experience in any way: addition of new APIs, changes to existing APIs - whether they are backwards compatible or not - and any other change to behaviour that affects the user of any components of Kuadrant.</p> <ul> <li>API additions;</li> <li>API changes;</li> <li>\u2026 any change in behaviour.</li> </ul>"},{"location":"architecture/#when-no-rfc-is-required","title":"When no RFC is required?","text":"<ul> <li>bugfixes;</li> <li>refactoring; </li> <li>performance improvements.</li> </ul>"},{"location":"architecture/#the-rfc-process","title":"The RFC process","text":"<p>The first step in adding a new feature to Kuadrant, or a starting a major change, is the having a RFC merged into the repository. One the file has been merged, the RFC is considered active and ready to be worked on.</p> <ol> <li>Fork the RFC repo</li> <li>Use the template <code>0000-template.md</code> to copy and rename it into the <code>rfcs</code> directory. Change the <code>template</code> suffix to something descriptive. But this is still a proposal and as no assigned RFC number to it yet.</li> <li>Fill the template out. Try to be as thorough as possible. While some sections may not apply to your feature/change request, try to complete as much as possible, as this will be the basis for further discussions.</li> <li>Submit a pull request for the proposal. That's when the RFC is open for actual comments by other members of team and the broader community.</li> <li>The PR is to be handled just like a \"code PR\", wait on people's review and integrate the feedback provided. These RFCs can also be discussed during our weekly technical call meeting, yet the summary would need to be captured on the PR.</li> <li>How ever much the orignal proposal changes during this process, never force push or otherwise squash the history, or even rebase your branch. Try keeping the commit history as clean as possible on that PR, in order to keep a trace of how the RFC evolved.</li> <li>Once all point of views have been shared and input has been integrated in the PR, the author can push the RFC in the final comment period (FCP) which lasts a week. This is the last chance for anyone to provide input. If during the FCP, consensus cannot be reached, it can be decided to extend that period by another week. Consensus is achieved by getting two approvals from the core team.</li> <li>As the PR is merged, it gets a number assigned, making the RFC active. </li> <li>If on the other hand the consensus is to not implement the feature as discussed, the PR is closed.</li> </ol>"},{"location":"architecture/#the-rfc-lifecycle","title":"The RFC lifecycle","text":"<ul> <li>Open: A new RFC as been submitted as a proposal</li> <li>FCP: Final comment period of one week for last comments</li> <li>Active: RFC got a number assigned and is ready for implementation with the work tracked in an issue, which summarizes the state of the implementation work.</li> </ul>"},{"location":"architecture/#implementation","title":"Implementation","text":"<p>The work is itself tracked in a \"master\" issue with all the individual, manageable implementation tasks tracked.  The state of that issue is initially \"open\" and ready for work, which doesn't mean it'd be worked on immediately or by the RFC's author. That work will be planned and integrated as part of the usual release cycle of the Kuadrant stack. </p>"},{"location":"architecture/#amendments","title":"Amendments","text":"<p>It isn't expected for an RFC to change, once it has become active. Minor changes are acceptable, but any major change to an active RFC should be treated as an independent RFC and go through the cycle described here.</p>"},{"location":"architecture/#what-doesnt-belong-here","title":"What doesn't belong here:","text":"<ul> <li>Specific component level documents that relate to the internal design of a component, these should reside within individual component repos</li> <li>Development process docs for individual components</li> </ul>"},{"location":"architecture/#technical-discussion-and-community-meetings","title":"Technical Discussion and Community meetings","text":"<ul> <li>Agenda</li> </ul>"},{"location":"architecture/design/modular_installation/","title":"Kuadrant Proposal - Modular Installation","text":"<p>Kuadrant is developing a set of loosely coupled functionalities built directly on top of Kubernetes. Kuadrant aims to allow customers to just install, use and understand those functionalities they need.</p>"},{"location":"architecture/design/modular_installation/#problem-statement","title":"Problem Statement","text":"<p>Currently, the installation tool of kuadrant, the kuadrantctl CLI, installs all or nothing. Installing more than the customer needs adds unneeded complexity and operational effort. For example, if a customer is looking for rate limiting and not interested in authentication functionality, then the customer should be able to just install and run that part of Kuadrant.</p>"},{"location":"architecture/design/modular_installation/#high-level-goals","title":"High Level Goals","text":"<ul> <li>Install only required components. Operate only required components.</li> </ul> <p>Reduce system complexity and operational effort to the minimum required. Components in this context make reference to deployments and running instances.</p> <ul> <li>Expose only the activated functionalities</li> </ul> <p>A user of a partial Kuadrant install should not be confronted with data in custom resources that has no meaning or is not accessible in their partial Kuadrant install. The design of the kuadrant API should have this goal into account.</p>"},{"location":"architecture/design/modular_installation/#proposed-solution","title":"Proposed Solution","text":"<p>The kuadrant installation mechanism should offer modular installation to enable/disable loosely coupled pieces of kuadrant. Modular installation options should be feature oriented rather than deployment component oriented. Then, it is up to the installation tool to decide what components need to be deployed and how to configure it.</p> <p>Each feature, or part of it, is eligible to be included or excluded when installing kuadrant.</p> <p>Some profiles can be defined to group set of commonly required features. Naming the profiles allows the customer to easily express wanted installation configuration. Furthermore, profiles not only can be used to group a set of features, profiles can be used to define deployment options.</p> Name Description Minimal Minimal installation required to run an API without any protection, analytics or API management. Default deployment option AuthZ Authentication and authorization mechanisms activated RateLimit Basic rate limit (only pre-auth rate limit) features Full Full featured kuadrant installation <p>A kuadrant operator, together with a design of a kuadrant CRD is desired. Not only for kuadrant installation, but also for lifecycle management. Additionally, the kuadrantctl CLI tool can also be useful to either deploy kuadrant components and manifests or just deploy the kuadrant operator.</p> <p>The kuadrant control plane should be aware of the installed profile via env vars or command line params in the control plane running components. With that information, the control plane can decide to enable or disable CRD watching, label and annotation monitoring and ultimately reject any configuration object that relies on disabled functionality. The least a customer can expect from kuadrant is to be consistent and reject any functionality request that cannot provide.</p>"}]}